{"pages":[{"title":"About","date":"2020-03-19T01:48:23.941Z","path":"about/index.html","text":""},{"title":"Categories","date":"2020-03-19T01:48:23.942Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2020-03-19T01:48:23.942Z","path":"tags/index.html","text":""}],"posts":[{"title":"Sass","date":"2020-03-14T10:04:47.000Z","path":"wiki/vue-good-table/sass/","text":"SassVue-Good-Table’s styling is written in Sass. The source files are made available as part of the npm dependency. Vue-Good-Table’s root Sass file: 1@import \"../node_modules/vue-good-table/src/styles/style.scss\"; Vue-Good-Table has an optional feature to filter a column based on a multi-select dropdown. We use Vue-Select for this feature. Vue-Select’s root Sass file 1@import \"../node_modules/vue-select/src/scss/vue-select.scss\";","tags":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/tags/Vue-good-table/"}],"categories":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/categories/Vue-good-table/"}]},{"title":"Style Classes","date":"2020-03-13T10:04:47.000Z","path":"wiki/vue-good-table/style-classes/","text":"Style ClassesVue-good-table allows providing your own css classes for the table via styleClass option but it also has in-built classes that you can make use of. ::: tip NOTEby default, tables have ‘vgt-table striped bordered’::: .vgt-tableBase class that initializes all the core styles for the table. 12345&lt;vue-good-table :columns=&quot;columns&quot; :rows=&quot;rows&quot; styleClass=&quot;vgt-table&quot;&gt;&lt;/vue-good-table&gt; .vgt-table .stripedAdd row striping in your data table. 12345&lt;vue-good-table :columns=&quot;columns&quot; :rows=&quot;rows&quot; styleClass=&quot;vgt-table striped&quot;&gt;&lt;/vue-good-table&gt; .vgt-table .borderedAdd borders to columns/rows 12345&lt;vue-good-table :columns=&quot;columns&quot; :rows=&quot;rows&quot; styleClass=&quot;vgt-table bordered&quot;&gt;&lt;/vue-good-table&gt; .vgt-table .condensedHave lots of rows? use condensed class to get more compact rows. 12345&lt;vue-good-table :columns=&quot;columns&quot; :rows=&quot;rows&quot; styleClass=&quot;vgt-table condensed&quot;&gt;&lt;/vue-good-table&gt;","tags":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/tags/Vue-good-table/"}],"categories":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/categories/Vue-good-table/"}]},{"title":"Themes","date":"2020-03-12T10:04:47.000Z","path":"wiki/vue-good-table/style-configuration/","text":"ThemesDefault1234&lt;vue-good-table :columns=\"columns\" :rows=\"rows\"&gt;&lt;/vue-good-table&gt; Black-rhino12345&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" theme=\"black-rhino\"&gt;&lt;/vue-good-table&gt; Nocturnal12345&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" theme=\"nocturnal\"&gt;&lt;/vue-good-table&gt;","tags":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/tags/Vue-good-table/"}],"categories":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/categories/Vue-good-table/"}]},{"title":"Server Side Table","date":"2020-03-11T10:04:47.000Z","path":"wiki/vue-good-table/remote-workflow/","text":"Server Side TableWhy Remote Mode?Vue-good-table’s in-built features like sorting, paging, filtering etc. are all performed client side and therefore are great for most of the use-cases. Sometimes though, we might have too much data to render all of it at once on the UI. In such cases, we would want to do things like sorting, paging, filtering on the server side. Fortunately, vue-good-table comes with remote mode to switch from client side to server side. When remote mode is on, vue-good-table does not perform sorting, paging, filtering etc. on the client side but instead emits events that we can use to then send proper parameters to the back-end. The server then is expected to send the correct rows to display on the UI. Following is a workflow you can use to get a server powered vue-good-table instance: Prep WorkWhat do we send to server?Before we dive into remote mode, lets agree on what we’re going to be sending to the server. A set of parameters that tells the server exactly what rows I need to get back. Here’s a proposed parameter object to send: 1234567891011121314serverParams: &#123; // a map of column filters example: &#123;name: 'john', age: '20'&#125; columnFilters: &#123; &#125;, sort: [ &#123; field: '', // example: 'name' type: '' // 'asc' or 'desc' &#125; ], page: 1, // what page I want to show perPage: 10 // how many items I'm showing per page&#125; With the above information, server should be able to generate the relevant rows to send back. What does the server send back?Two things are required for the server to send back relevant rows - set of rows for the current page, matching the current filter and sort. totalRecords - number of total records matching the params we sent (not just the current page). This is required for the pagination to work correctly. Set mode to remote12345678&lt;vue-good-table mode=\"remote\" :pagination-options=\"&#123; enabled: true, &#125;\" :totalRows=\"totalRecords\" :rows=\"rows\" :columns=\"columns\"/&gt; this tells VGT to not do client side paging/sorting/filtering Provide handlers for user eventsNow instead of doing the above client side, each user interaction will generate events. So lets provide handlers for those events: 12345678910111213&lt;vue-good-table mode=\"remote\" @on-page-change=\"onPageChange\" @on-sort-change=\"onSortChange\" @on-column-filter=\"onColumnFilter\" @on-per-page-change=\"onPerPageChange\" :totalRows=\"totalRecords\" :isLoading.sync=\"isLoading\" :pagination-options=\"&#123; enabled: true, &#125;\" :rows=\"rows\" :columns=\"columns\"/&gt; … in data 1234567891011121314151617181920data() &#123; return &#123; isLoading: false, columns: [ //... ], rows: [], totalRecords: 0, serverParams: &#123; columnFilters: &#123; &#125;, sort: &#123; field: '', type: '', &#125;, page: 1, perPage: 10 &#125; &#125;; &#125;, … handlers 1234567891011121314151617181920212223242526272829303132333435363738methods: &#123; updateParams(newProps) &#123; this.serverParams = Object.assign(&#123;&#125;, this.serverParams, newProps); &#125;, onPageChange(params) &#123; this.updateParams(&#123;page: params.currentPage&#125;); this.loadItems(); &#125;, onPerPageChange(params) &#123; this.updateParams(&#123;perPage: params.currentPerPage&#125;); this.loadItems(); &#125;, onSortChange(params) &#123; this.updateParams(&#123; sort: [&#123; type: params.sortType, field: this.columns[params.columnIndex].field, &#125;], &#125;); this.loadItems(); &#125;, onColumnFilter(params) &#123; this.updateParams(params); this.loadItems(); &#125; // load items is what brings back the rows from server loadItems() &#123; getFromServer(this.serverParams).then(response =&gt; &#123; this.totalRecords = response.totalRecords; this.rows = response.rows; &#125;); &#125;&#125; So, what is happening? Everytime the user interacts with the table, an appropriate event is emitted. Along with this, VGT knows that this event will now result in fetching things from the backend. So it starts a loading screen. In the handler of that event, we first update the serverParams and then send a request to the backend. When we get the response back, we update both the totalRecords and the rows data objects. Row object’s update signifies to VGT that the loading event is now done, and VGT shows the new rows on the table. ::: tipIf you want to show loading notification manually, you can do so using table’s :isLoading.sync=&quot;isLoading&quot; property.::: ::: tipto style the loading dom, you can use the slot - loadingContent::: ConclusionSo that wasn’t too bad. You now have VGT that’s powered completely by your backend server.","tags":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/tags/Vue-good-table/"}],"categories":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/categories/Vue-good-table/"}]},{"title":"Grouped Table","date":"2020-03-10T10:04:47.000Z","path":"wiki/vue-good-table/grouped-table/","text":"Grouped TableTo create grouped rows, you need two things. 1. Add groupOptions to table component12345678&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :groupOptions=\"&#123; enabled: true &#125;\"&gt;&lt;/vue-good-table&gt; 2. Make sure the rows are formatted correctly. Grouped rows need to be nested within header rows containing data rows in their children property. For example:1234567891011rows: [ &#123; mode: \"span\", // span means this header will span all columns label: \"Mammal\", // this is the label that'll be used for the header html: false, // if this is true, label will be rendered as html children: [ &#123; name: \"Elephant\", diet: \"herbivore\", count: 5 &#125;, &#123; name: \"Cat\", diet: \"carnivore\", count: 28 &#125; ] &#125;]; 3. Sometimes, you might want a summary row instead of a header row. For example, if you want to show total count for your group1234567891011rows: [ &#123; name: \"Mammals Total\", // this is the label that'll be used for the header diet: undefined, count: \"\", // total count will be displayed here children: [ &#123; name: \"Elephant\", diet: \"herbivore\", count: 5 &#125;, &#123; name: \"Cat\", diet: \"carnivore\", count: 28 &#125; ] &#125;]; 4. If you want the header/summary row to show up at the bottom of the group, you can specify that in the groupOptions property of the table.123456789&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :groupOptions=\"&#123; enabled: true, headerPosition: 'bottom', &#125;\"&gt;&lt;/vue-good-table&gt; 5. What if you wanted to add a total count in summary rows?In your column definition add a property, headerField. This is just like field property but for summary/header rows only. So lets say we wanted to add a sum function to this field. 12345678910111213141516171819// in columns&#123; label: 'Count', field: 'count', headerField: this.sumCount, type: 'number',&#125;,// in methods we define sumCountmethods: &#123; sumCount(rowObj) &#123; console.log(rowObj); let sum = 0; for (let i = 0; i &lt; rowObj.children.length; i++) &#123; sum += rowObj.children[i].count; &#125; return sum; &#125;,&#125;, Customizing Header RowIf you want more control over what the header row looks like, you can use slots the same way you customize rows. For example if you want to add a button in the header row or something, this would be the way to do it. When mode is ‘span’In this case, the header row spans across all columns 1234567891011121314&lt;vue-good-table :columns=&quot;columns&quot; :rows=&quot;rows&quot; :group-options=&quot;&#123; enabled: true, headerPosition: &apos;top&apos; &#125;&quot;&gt; &lt;template slot=&quot;table-header-row&quot; slot-scope=&quot;props&quot;&gt; &lt;span class=&quot;my-fancy-class&quot;&gt; &#123;&#123; props.row.label &#125;&#125; &lt;/span&gt; &lt;/template&gt; &lt;/vue-good-table&gt; When mode is not ‘span’In this case header row expects a value for each column 1234567891011121314151617&lt;vue-good-table :columns=&quot;columns&quot; :rows=&quot;rows&quot; :group-options=&quot;&#123; enabled: true, headerPosition: &apos;top&apos; &#125;&quot;&gt; &lt;template slot=&quot;table-header-row&quot; slot-scope=&quot;props&quot;&gt; &lt;span v-if=&quot;props.column.field == &apos;action&apos;&quot;&gt; &lt;button class=&quot;fancy-btn&quot;&gt;Action&lt;/button&gt; &lt;/span&gt; &lt;span v-else&gt; &#123;&#123;props.formattedRow[props.column.field]&#125;&#125; &lt;/span&gt; &lt;/template&gt; &lt;/vue-good-table&gt; ::: tip The original row object can be accessed via props.row The column object can be accessed via props.column You can access the formatted row data (for example - formatted date) via props.formattedRow::: Collapsable RowsTo allow the row to collapse and expand you can use the groupOption “collapsable”. You can either pass in a boolean or a number.If collapsable is set to true then it will default to making the first column collapsable. Alternatively, you can specify the column index number. 12345678910&lt;vue-good-table ref=\"myCustomTable\" :columns=\"columns\" :rows=\"rows\" :groupOptions=\"&#123; enabled: true, collapsable: true // or column index &#125;\"&gt;&lt;/vue-good-table&gt; To expand/collapse all you can use the method called expandAll or collapseAll. 12this.$refs.myCustomTable.expandAll();this.$refs.myCustomTable.collapseAll();","tags":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/tags/Vue-good-table/"}],"categories":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/categories/Vue-good-table/"}]},{"title":"Checkbox Table","date":"2020-03-09T10:04:47.000Z","path":"wiki/vue-good-table/checkbox-table/","text":"Checkbox TableOne of the most common customizations in datatables is selectable rows. Creating a checkbox table with vue-good-table is easier than ever. Configurationtype: Object Object containing select options 123456789101112&lt;vue-good-table @on-selected-rows-change=\"selectionChanged\" :columns=\"columns\" :rows=\"rows\" :selectOptions=\"&#123; enabled: true, selectOnCheckboxOnly: true, // only select when checkbox is clicked instead of the row selectionInfoClass: 'custom-class', selectionText: 'rows selected', clearSelectionText: 'clear', disableSelectInfo: true, // disable the select info panel on top &#125;\"&gt; Although, the on-selected-rows-change event should be enough for you to keep track of selected rows. If at any time you need to know what rows are selected, you can get it via ref. 1this.$refs['my-table'].selectedRows; Example1234567&lt;vue-good-table @on-selected-rows-change=&quot;selectionChanged&quot; :columns=&quot;columns&quot; :rows=&quot;rows&quot; :select-options=&quot;&#123; enabled: true &#125;&quot; :search-options=&quot;&#123; enabled: true &#125;&quot;&gt;&lt;/vue-good-table&gt; Selected row action slotOnce you select a row, an info bar shows up. This bar allows for a customizable slot for your action buttons. Example12345678910111213&lt;vue-good-table @on-selected-rows-change=\"selectionChanged\" :columns=\"columns\" :rows=\"rows\" :select-options=\"&#123; enabled: true, &#125;\" :search-options=\"&#123; enabled: true &#125;\"&gt; &lt;div slot=\"selected-row-actions\"&gt; &lt;button&gt;Action 1&lt;/button&gt; &lt;/div&gt;&lt;/vue-good-table&gt;&lt;!-- click on a row below to show the action button --&gt; ::: tip NoteYou can style the selection info bar by supplying a css class to selectionInfoClass property.:::","tags":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/tags/Vue-good-table/"}],"categories":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/categories/Vue-good-table/"}]},{"title":"Customizations","date":"2020-03-08T10:04:47.000Z","path":"wiki/vue-good-table/advanced/","text":"CustomizationsCustom Row TemplateSometimes you might want to customize exactly how rows are displayed in a table. Vue-good-table also supports dynamic td templates where you dictate how to display the cells. Example: 123456789101112&lt;vue-good-table :columns=\"columns\" :rows=\"rows\"&gt; &lt;template slot=\"table-row\" slot-scope=\"props\"&gt; &lt;span v-if=\"props.column.field == 'age'\"&gt; &lt;span style=\"font-weight: bold; color: blue;\"&gt;&#123;&#123;props.row.age&#125;&#125;&lt;/span&gt; &lt;/span&gt; &lt;span v-else&gt; &#123;&#123;props.formattedRow[props.column.field]&#125;&#125; &lt;/span&gt; &lt;/template&gt;&lt;/vue-good-table&gt; Result ::: tip NOTE The original row object can be accessed via props.row The currently displayed table row index can be accessed via props.index . The original row index can be accessed via props.row.originalIndex. You can then access the original row object by using rows[props.row.originalIndex]. The column object can be accessed via props.column You can access the formatted row data (for example - formatted date) via props.formattedRow::: Adding custom columnsSometimes you might want to add columns to the table that are not part of your row data. Maybe before or after the other columns. 123456789101112131415&lt;vue-good-table :columns=\"columns\" :rows=\"rows\"&gt; &lt;template slot=\"table-row\" slot-scope=\"props\"&gt; &lt;span v-if=\"props.column.field == 'before'\"&gt; before &lt;/span&gt; &lt;span v-else-if=\"props.column.field == 'after'\"&gt; after &lt;/span&gt; &lt;span v-else&gt; &#123;&#123;props.formattedRow[props.column.field]&#125;&#125; &lt;/span&gt; &lt;/template&gt;&lt;/vue-good-table&gt; keep in mind that you’ll need to add the custom columns to your column definition. 12345678&#123; label: 'Before', field: 'before'&#125;,&#123; label: 'After', field: 'after'&#125;, Result Custom column headersSometimes you might want to customize column headers. You can do that in the following way 123456789101112&lt;vue-good-table :columns=\"columns\" :rows=\"rows\"&gt; &lt;template slot=\"table-column\" slot-scope=\"props\"&gt; &lt;span v-if=\"props.column.label =='Name'\"&gt; &lt;i class=\"fa fa-address-book\"&gt;&lt;/i&gt; &#123;&#123;props.column.label&#125;&#125; &lt;/span&gt; &lt;span v-else&gt; &#123;&#123;props.column.label&#125;&#125; &lt;/span&gt; &lt;/template&gt;&lt;/vue-good-table&gt; Custom paginationSometimes you might want to customize the pagination. You can do that in the following way: 123456789101112&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :pagination-options=\"&#123;enabled: true&#125;\"&gt; &lt;template slot=\"pagination-bottom\" slot-scope=\"props\"&gt; &lt;custom-pagination :total=\"props.total\" :pageChanged=\"props.pageChanged\" :perPageChanged=\"props.perPageChanged\"&gt; &lt;/custom-pagination&gt; &lt;/template&gt;&lt;/vue-good-table&gt; 123456789101112131415161718// within your &lt;custom-pagination&gt; componentprops: &#123; pageChanged: &#123; type: Function, &#125;, perPageChanged: &#123; type: Function, &#125;,&#125;// and...methods: &#123; customPageChange(customCurrentPage) &#123; this.pageChanged(&#123;currentPage: customCurrentPage&#125;); &#125;, customPerPageChange(customPerPage) &#123; this.perPageChanged(&#123;currentPerPage: customPerPage&#125;); &#125;&#125; ::: warningYou will have to implement your own pagination system: The total number of rows can be accessed via props.total The function to call when the current page has changed can be accessed via props.pageChanged. The function to call when the per page value has changed can be accessed via props.perPageChanged .:::","tags":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/tags/Vue-good-table/"}],"categories":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/categories/Vue-good-table/"}]},{"title":"Column Filter Options","date":"2020-03-07T10:04:47.000Z","path":"wiki/vue-good-table/column-filter-options/","text":"Column Filter OptionsfilterOptionstype Object A collection of filter specific properties within a column object. 12345678910111213141516columns: [ &#123; label: 'name', field: 'user_name', filterOptions: &#123; enabled: true, // enable filter for this column placeholder: 'Filter This Thing', // placeholder for filter input filterValue: 'Jane', // initial populated value for this filter filterDropdownItems: [], // dropdown (with selected values) instead of text input filterMultiselectDropdownItems: [], // dropdown (with multiple selected values) instead of text input filterFn: this.columnFilterFn, //custom filter function that trigger: 'enter', //only trigger on enter not on keyup &#125;, &#125;, // ...] enabledtype: BooleanSwitch to enable column filter. placeholdertype: StringPlaceholder to use on the column filter input. filterValuetype: StringIf you want filter to be pre-populated, use this property triggertype: String (default: &#39;&#39;)Allows specifying trigger for column filter. Default trigger is keyup. use ‘enter’ to filter only when enter key is pressed. filterDropdownItemstype Array of strings or Array of objects allows creating a dropdown for filter as opposed to an input 12345678//arrayfilterDropdownItems: ['Blue', 'Red', 'Yellow']//orfilterDropdownItems: [ &#123; value: 'n', text: 'Inactive' &#125;, &#123; value: 'y', text: 'Active' &#125;, &#123; value: 'c', text: 'Check' &#125; ], filterMultiselectDropdownItemstype Array of strings or Array of objects with labels allows creating a dropdown for filtering multiple items as opposed to an input 12//array of stringsfilterMultiselectDropdownItems: ['Blue', 'Red', 'Yellow'] 123456//array of objectsfilterMultiselectDropdownItems: [ &#123; id: 1, label: 'Blue' &#125;, &#123; id: 2, label: 'Red' &#125;, &#123; id: 3, label: 'Yellow' &#125;] filterFntype Function Custom filter, function of two variables: function(data, filterString), should return true if data matches the filterString, otherwise false 12345filterFn: function(data, filterString) &#123; var x = parseInt(filterString) return data &gt;= x - 5 &amp;&amp; data &lt;= x + 5;&#125;// would create a filter matching numbers within 5 of the provided value","tags":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/tags/Vue-good-table/"}],"categories":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/categories/Vue-good-table/"}]},{"title":"Column Options","date":"2020-03-06T10:04:47.000Z","path":"wiki/vue-good-table/column-options/","text":"Column OptionsEach column objects can contain the following configuration options: labeltype String Text to put on column header. 123456columns: [ &#123; label: 'name' &#125;, // ...] fieldtype String Row object property that this column corresponds to. This can be: String eg: 'name' - simple row property name String eg: 'location.lat'- nested row property name. lets say if the row had a property ‘location’ which was an object containing ‘lat’ and ‘lon’ Function - a function that returns a value to be displayed based on the row object1234567891011columns: [ &#123; label: 'name', field: this.fealdFn, &#125;, // ...]// in methodsfieldFn(rowObj) &#123; return rowObj.name;&#125; typetype String type of column. default: ‘text’. This determines the formatting for the column and filter behavior as well. Possible values: number - right aligned decimal - right aligned, 2 decimal places percentage - expects a decimal like 0.03 and formats it as 3.00% boolean - right aligned date - expects a string representation of date eg ‘20170530’. You should also specify dateInputFormat and dateOutputFormat 12345678910columns: [ &#123; label: 'joined On', field: 'createdAt', type: 'date', dateInputFormat: 'yyyy-MM-dd', // expects 2018-03-16 dateOutputFormat: 'MMM Do yyyy', // outputs Mar 16th 2018 &#125;, // ...] dateInputFormattype String provide the format to parse date string. ::: tipVue-good-table uses date-fns for date parsing. Check out their formats here.::: dateOutputFormattype String provide the format for output date sortabletype Boolean enable/disable sorting on columns. This property is higher priority than global sortable property 12345678columns: [ &#123; label: 'name', field: 'user_name', sortable: false, &#125;, // ...] sortFntype Function custom sort function. If you want to supply your own sort function you can use this property. 123456789101112131415161718192021// in datacolumns: [ &#123; label: 'Name', field: 'name', sortable: true, sortFn: this.sortFn, &#125; //...],// in methodsmethods: &#123; sortFn(x, y, col, rowX, rowY) &#123; // x - row1 value for column // y - row2 value for column // col - column being sorted // rowX - row object for row1 // rowY - row object for row2 return (x &lt; y ? -1 : (x &gt; y ? 1 : 0)); &#125;&#125; formatFntype Function Allows for custom format of values, function(value), should return the formatted value to display. 1234567891011121314// in datacolumns: [ &#123; label: 'Salary', field: 'salary', sortable: true, formatFn: this.formatFn, &#125; //...],// in methodsformatFn: function(value) &#123; return '$' + value;&#125; htmltype Boolean indicates whether this column will require html rendering.::: tipThe preferred way of creating columns that have html is by using slots::: 123456789101112131415// in datacolumns: [ &#123; label: 'Action', field: 'btn', html: true, &#125; //...],rows: [ &#123; btn: '&lt;button&gt;My Action&lt;/button&gt;', // ... &#125;] widthtype Number provide a width value for this column 12345678columns: [ &#123; label: 'name', field: 'user_name', width: '50px', &#125;, // ...] hiddentype Boolean hide a column 12345678columns: [ &#123; label: 'name', field: 'user_name', hidden: true, &#125;, // ...] thClasstype String provide custom class(es) to the table header 12345678columns: [ &#123; label: 'name', field: 'user_name', thClass: 'custom-th-class', &#125;, // ...] tdClasstype String or Function provide custom class(es) to the table cells 12345678columns: [ &#123; label: 'name', field: 'user_name', tdClass: 'text-center', &#125;, // ...] or 1234567891011121314151617columns: [ &#123; label: 'name', field: 'user_name', tdClass: this.tdClassFunc, &#125;, // ...]// and latermethods: &#123; tdClassFunc(row) &#123; if (row.field &gt; 50) &#123; return 'red-class'; &#125; return 'green-class'; &#125;,&#125; globalSearchDisabledtype Boolean (default: false) if true, this column will be ignored by the global search 12345678columns: [ &#123; label: 'name', field: 'user_name', globalSearchDisabled: true, &#125;, // ...]","tags":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/tags/Vue-good-table/"}],"categories":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/categories/Vue-good-table/"}]},{"title":"Pagination Options","date":"2020-03-05T10:04:47.000Z","path":"wiki/vue-good-table/pagination-options/","text":"Pagination OptionsA set of options that are related to table pagination. Each of these are optional and reasonable defaults will be used if you leave off the property. 12345678910111213141516171819&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :pagination-options=\"&#123; enabled: true, mode: 'records', perPage: 5, position: 'top', perPageDropdown: [3, 7, 9], dropdownAllowAll: false, setCurrentPage: 2, nextLabel: 'next', prevLabel: 'prev', rowsPerPageLabel: 'Rows per page', ofLabel: 'of', pageLabel: 'page', // for 'pages' mode allLabel: 'All', &#125;\"&gt;&lt;/vue-good-table&gt; enabledtype: Boolean (default: false) Enable Pagination for table. By default the paginator is created at the bottom of the table. 1234567&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :pagination-options=\"&#123; enabled: true &#125;\"&gt;&lt;/vue-good-table&gt; modetype: String (default: &#39;records&#39;) You can render pagination controls in two modes - ‘records’ and ‘pages’. Below, you’ll find examples of both. ::: tipFor tables that may have many pages, ‘pages’ mode offers the ability to jump to any valid page.::: records mode (default)12345678&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :pagination-options=\"&#123; enabled: true, mode: 'records' &#125;\"&gt;&lt;/vue-good-table&gt; pages mode12345678&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :pagination-options=\"&#123; enabled: true, mode: 'pages' &#125;\"&gt;&lt;/vue-good-table&gt; positiontype: String (default: &#39;bottom&#39;) Add pagination on ‘top’ or ‘bottom’ (top and bottom) of the table (default position is bottom) 12345678&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :pagination-options=\"&#123; enabled: true, position: 'top' &#125;\"&gt;&lt;/vue-good-table&gt; perPagetype: Integer (default: 10) Number of rows to show per page 12345678&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :pagination-options=\"&#123; enabled: true, perPage: 5 &#125;\"&gt;&lt;/vue-good-table&gt; perPageDropdowntype: Array (default: [10,20,30,40,50]) Customize the dropdown options for the amount of items per page 12345678&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :pagination-options=\"&#123; enabled: true, perPageDropdown: [3, 7, 9] &#125;\"&gt;&lt;/vue-good-table&gt; dropdownAllowAlltype: Boolean (default: true) enables/disables ‘All’ in the per page dropdown. 123456789&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :pagination-options=\"&#123; enabled: true, perPageDropdown: [3, 7, 9], dropdownAllowAll: false, &#125;\"&gt;&lt;/vue-good-table&gt; setCurrentPagetype: Number set current page programmatically.::: warningThere’s no validation for number of pages so please be careful using this.::: 12345678&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :pagination-options=\"&#123; enabled: true, setCurrentPage: 2, &#125;\"&gt;&lt;/vue-good-table&gt; pagination label/text optionsyou can change one or more of the texts shown on pagination by overriding the labels in the following way: 12345678910111213&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :pagination-options=\"&#123; enabled: true, nextLabel: 'next', prevLabel: 'prev', rowsPerPageLabel: 'Rows per page', ofLabel: 'of', pageLabel: 'page', // for 'pages' mode allLabel: 'All', &#125;\"&gt;&lt;/vue-good-table&gt; Replace Pagination Componentyou can also replace the pagination component with your own component - Custom Pagination","tags":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/tags/Vue-good-table/"}],"categories":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/categories/Vue-good-table/"}]},{"title":"Sort Options","date":"2020-03-04T11:04:47.000Z","path":"wiki/vue-good-table/sort-options/","text":"Sort OptionsSet of options related to table sorting 12345678&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :sort-options=\"&#123; enabled: true, initialSortBy: &#123;field: 'name', type: 'asc'&#125; &#125;\"&gt;&lt;/vue-good-table&gt; enabledtype: Boolean (default: true) Enable/disable sorting on table as a whole. 1234567&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :sort-options=\"&#123; enabled: true, &#125;\"&gt;&lt;/vue-good-table&gt; initialSortBy::: tip UpdateinitialSortBy now allows for sort by multiple columns::: type: Object or Array Allows specifying a default sort for the table on wakeup 12345678&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :sort-options=\"&#123; enabled: true, initialSortBy: &#123;field: 'name', type: 'asc'&#125; &#125;\"&gt;&lt;/vue-good-table&gt; Multiple Column Sort1234567891011&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :sort-options=\"&#123; enabled: true, initialSortBy: [ &#123;field: 'name', type: 'asc'&#125;, &#123;field: 'age', type: 'desc'&#125; ], &#125;\"&gt;&lt;/vue-good-table&gt; Users can shift-click on multiple columns to sort by multiple columns. The first column in the array gets primary sort.","tags":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/tags/Vue-good-table/"}],"categories":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/categories/Vue-good-table/"}]},{"title":"Search Options","date":"2020-03-04T10:04:47.000Z","path":"wiki/vue-good-table/search-options/","text":"Search OptionsVue-good-table supports two ways of filtering the table. A global search that searches through all records in the table Column filters that filter based on a given column This section talks about how to configure global search options. 123456789101112&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :search-options=\"&#123; enabled: true, trigger: 'enter', skipDiacritics: true, searchFn: mySearchFn, placeholder: 'Search this table', externalQuery: searchQuery &#125;\"&gt;&lt;/vue-good-table&gt; enabledtype: Boolean (default: false) Allows a single search input for the whole table ::: warningEnabling this option disables column filters::: 1234567&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :search-options=\"&#123; enabled: true &#125;\"&gt;&lt;/vue-good-table&gt; triggertype: String (default: &#39;&#39;) Allows you to specify if you want search to trigger on ‘enter’ event of the input. By default table searches on key-up. 12345678&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :search-options=\"&#123; enabled: true, trigger: 'enter' &#125;\"&gt;&lt;/vue-good-table&gt; skipDiacriticstype: boolean (default: false) By default, search does a diacriticless comparison so you can search through accented characters. This however slows down the search to some extent. If your data doesn’t have accented characters, you can skip this check and gain some performance. 12345678&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :search-options=\"&#123; enabled: true, skipDiacritics: true, &#125;\"&gt;&lt;/vue-good-table&gt; searchFntype: Function Allows you to specify your own search function for the global search 12345678&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :search-options=\"&#123; enabled: true, searchFn: myFunc &#125;\"&gt;&lt;/vue-good-table&gt; 123456// in jsmethods: &#123; myFunc(row, col, cellValue, searchTerm)&#123; return cellValue === 'my value'; &#125;,&#125; placeholdertype: String (default: &#39;Search Table&#39;) Text for global search input place holder 12345678&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :search-options=\"&#123; enabled: true, placeholder: 'Search this table', &#125;\"&gt;&lt;/vue-good-table&gt; externalQuerytype: String If you want to use your own input for searching the table, you can use this property 123456789&lt;input type=\"text\" v-model=\"searchTerm\" &gt;&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :search-options=\"&#123; enabled: true, externalQuery: searchTerm &#125;\"&gt;&lt;/vue-good-table&gt; 1234567// and in datadata()&#123; return &#123; searchTerm: '', // rows, columns etc... &#125;;&#125;","tags":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/tags/Vue-good-table/"}],"categories":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/categories/Vue-good-table/"}]},{"title":"Table Events","date":"2020-03-03T10:04:47.000Z","path":"wiki/vue-good-table/table-events/","text":"Table Events@on-row-clickevent emitted on table row click 1234&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" @on-row-click=\"onRowClick\"&gt; 123456789methods: &#123; onRowClick(params) &#123; // params.row - row object // params.pageIndex - index of this row on the current page. // params.selected - if selection is enabled this argument // indicates selected or not // params.event - click event &#125;&#125; @on-row-dblclickevent emitted on table row click 1234&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" @on-row-dblclick=\"onRowDoubleClick\"&gt; 123456789 methods: &#123; onRowDoubleClick(params) &#123; // params.row - row object // params.pageIndex - index of this row on the current page. // params.selected - if selection is enabled this argument // indicates selected or not // params.event - click event &#125;&#125; @on-cell-clickevent emitted on table cell click 1234&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" @on-cell-click=\"onCellClick\"&gt; 12345678methods: &#123; onCellClick(params) &#123; // params.row - row object // params.column - column object // params.rowIndex - index of this row on the current page. // params.event - click event &#125;&#125; @on-row-mouseenterevent emitted on row mouseenter 1234&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" @on-row-mouseenter=\"onRowMouseover\"&gt; 123456methods: &#123; onRowMouseover(params) &#123; // params.row - row object // params.pageIndex - index of this row on the current page. &#125;&#125; @on-row-mouseleaveevent emitted on table row mouseleave 1234&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" @on-row-mouseleave=\"onRowMouseleave\"&gt; 123456methods: &#123; onRowMouseleave(row, pageIndex) &#123; // row - row object // pageIndex - index of this row on the current page. &#125;&#125; @on-searchevent emitted on global search (when global search is enabled) 1234&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" @on-search=\"onSearch\"&gt; 123456methods: &#123; onSearch(params) &#123; // params.searchTerm - term being searched for // params.rowCount - number of rows that match search &#125;&#125; @on-page-changeevent emitted on pagination page change (when pagination is enabled) 1234&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" @on-page-change=\"onPageChange\"&gt; 12345678methods: &#123; onPageChange(params) &#123; // params.currentPage - current page that pagination is at // params.prevPage - previous page // params.currentPerPage - number of items per page // params.total - total number of items in the table &#125;&#125; @on-per-page-changeevent emitted on per page dropdown change (when pagination is enabled) 1234&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" @on-per-page-change=\"onPageChange\"&gt; 1234567methods: &#123; onPageChange(params) &#123; // params.currentPage - current page that pagination is at // params.currentPerPage - number of items per page // params.total - total number of items in the table &#125;&#125; @on-sort-changeevent emitted on sort change.::: tipvue-good-table now supports sorting by multiple columns, so the paramsis an array.::: 1234&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" @on-sort-change=\"onSortChange\"&gt; 123456methods: &#123; onSortChange(params) &#123; // params[0].sortType - ascending or descending // params[0].columnIndex - index of column being sorted &#125;&#125; @on-column-filterevent emitted when column is filtered (only emitted for remote mode) 1234&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" @on-column-filter=\"onColumnFilter\"&gt; 123456methods: &#123; onColumnFilter(params) &#123; // params.columnFilters - filter values for each column in the following format: // &#123;field1: 'filterTerm', field3: 'filterTerm2') &#125;&#125; @on-select-allevent emitted when all is selected (only emitted for checkbox tables) 12345&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :select-options=\"&#123; enabled: true &#125;\" @on-select-all=\"onSelectAll\"&gt; 123456methods: &#123; onSelectAll(params) &#123; // params.selected - whether the select-all checkbox is checked or unchecked // params.selectedRows - all rows that are selected (this page) &#125;&#125; @on-selected-rows-change event emitted whenever selection is changed (on checkbox tables) 12345&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :select-options=\"&#123; enabled: true &#125;\" @on-selected-rows-change=\"selectionChanged\"&gt; 12345methods: &#123; selectionChanged(params) &#123; // params.selectedRows - all rows that are selected (this page) &#125;&#125;","tags":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/tags/Vue-good-table/"}],"categories":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/categories/Vue-good-table/"}]},{"title":"Table Options","date":"2020-03-02T10:04:47.000Z","path":"wiki/vue-good-table/configuration/","text":"Table OptionsThese options relate to the table as a whole columnstype: Array Array containing objects that describe table columns. The column object itself can contain many configurable properties. 12345678[ &#123; label: 'Name', field: 'name', filterable: true, &#125; //...] rowstype: Array Array containing row objects. Each row object contains data that will be displayed in the table row. 12345678[ &#123; id:1, name:\"John\", age:20 &#125;, //...] ::: tipfor grouped rows, you need a nested format. Refer to Grouped Table for examples.::: max-heighttype: StringSet a maximum height for table body 12345&lt;vue-good-table :columns=&quot;columns&quot; :rows=&quot;rows&quot; max-height=&quot;300px&quot;&gt;&lt;/vue-good-table&gt; fixed-headertype: Boolean (default: false)fix header so it stays in view as you scroll the table. 123456&lt;vue-good-table :columns=&quot;columns&quot; :rows=&quot;rows&quot; max-height=&quot;200px&quot; :fixed-header=&quot;true&quot;&gt;&lt;/vue-good-table&gt; ::: tipFixed header should probably be used with max-height::: line-numberstype: Boolean (default: false)Show line number for each row 12345&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :line-numbers=\"true\"&gt;&lt;/vue-good-table&gt; row-style-classtype: String or Function property to assign a class to rows. This can either be a string representing a css class-name or a function. 12345&lt;vue-good-table :columns=&quot;columns&quot; :rows=&quot;rows&quot; :row-style-class=&quot;rowStyleClassFn&quot;&gt;&lt;/vue-good-table&gt; 12345methods: &#123; rowStyleClassFn(row) &#123; return row.age &gt; 18 ? 'green' : 'red'; &#125;,&#125; rtltype: Boolean (default: false) Enable Right-To-Left layout for the table 12345&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" :rtl=\"true\"&gt;&lt;/vue-good-table&gt; Table Actions SlotIf you want to add table specific actions like a print button for example, you can use the Table Actions Slot. If you have global search enabled, the action panel will show up to the right of that. ::: tip NoteYou don’t have to have global search enabled to use this slot.::: 1234567&lt;vue-good-table :columns=\"columns\" :rows=\"rows\"&gt; &lt;div slot=\"table-actions\"&gt; This will show up on the top right of the table. &lt;/div&gt;&lt;/vue-good-table&gt; Table Actions Footer SlotIf you want a space for your buttons between pagination and the table. This is the slot you use. 1234567&lt;vue-good-table :columns=\"columns\" :rows=\"rows\"&gt; &lt;div slot=\"table-actions-bottom\"&gt; This will show up on the bottom of the table. &lt;/div&gt;&lt;/vue-good-table&gt; Empty state slotYou can provide html for empty state slot as well. Example: 1234567&lt;vue-good-table :columns=\"columns\" :rows=\"rows\"&gt; &lt;div slot=\"emptystate\"&gt; This will show up when there are no rows &lt;/div&gt;&lt;/vue-good-table&gt; modetype: String Set mode=remote to allow sorting/filtering etc to be powered by server side instead of client side. for a detailed workflow example check out Server Side Workflow 12345&lt;vue-good-table :columns=\"columns\" :rows=\"rows\" mode=\"remote\"&gt;&lt;/vue-good-table&gt; totalRecordstype: Number::: tiptotalRecords is only useful for remote mode. When server controls pagination the table needs to know how many total rows exist.::: total number of rows that exist given a table/filter. refer to remote workflow for more details","tags":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/tags/Vue-good-table/"}],"categories":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/categories/Vue-good-table/"}]},{"title":"Getting Started","date":"2020-03-01T10:04:47.000Z","path":"wiki/vue-good-table/README/","text":"Getting StartedInstallationInstall with npm: 1npm install --save vue-good-table Import globally in app: 123456import VueGoodTablePlugin from 'vue-good-table';// import the stylesimport 'vue-good-table/dist/vue-good-table.css'Vue.use(VueGoodTablePlugin); or you can import into your component: 12345678// import the stylesimport 'vue-good-table/dist/vue-good-table.css'import &#123; VueGoodTable &#125; from 'vue-good-table';// add to componentcomponents: &#123; VueGoodTable,&#125; Basic Example 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;div&gt; &lt;vue-good-table :columns=&quot;columns&quot; :rows=&quot;rows&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;my-component&apos;, data()&#123; return &#123; columns: [ &#123; label: &apos;Name&apos;, field: &apos;name&apos;, &#125;, &#123; label: &apos;Age&apos;, field: &apos;age&apos;, type: &apos;number&apos;, &#125;, &#123; label: &apos;Created On&apos;, field: &apos;createdAt&apos;, type: &apos;date&apos;, dateInputFormat: &apos;yyyy-MM-dd&apos;, dateOutputFormat: &apos;MMM Do yy&apos;, &#125;, &#123; label: &apos;Percent&apos;, field: &apos;score&apos;, type: &apos;percentage&apos;, &#125;, ], rows: [ &#123; id:1, name:&quot;John&quot;, age: 20, createdAt: &apos;&apos;,score: 0.03343 &#125;, &#123; id:2, name:&quot;Jane&quot;, age: 24, createdAt: &apos;2011-10-31&apos;, score: 0.03343 &#125;, &#123; id:3, name:&quot;Susan&quot;, age: 16, createdAt: &apos;2011-10-30&apos;, score: 0.03343 &#125;, &#123; id:4, name:&quot;Chris&quot;, age: 55, createdAt: &apos;2011-10-11&apos;, score: 0.03343 &#125;, &#123; id:5, name:&quot;Dan&quot;, age: 40, createdAt: &apos;2011-10-21&apos;, score: 0.03343 &#125;, &#123; id:6, name:&quot;John&quot;, age: 20, createdAt: &apos;2011-10-31&apos;, score: 0.03343 &#125;, ], &#125;; &#125;,&#125;;&lt;/script&gt; Usage with Nuxt.jsCreate your own plugin by creating a file called vue-good-table.js inside your Nuxt plugins folder. Shoud look something like this: 1234567import Vue from &apos;vue&apos;import VueGoodTablePlugin from &apos;vue-good-table&apos;;// import the stylesimport &apos;vue-good-table/dist/vue-good-table.css&apos;Vue.use(VueGoodTablePlugin); As you can see, the only difference from the normal installation is that we need to reference Vue using import Vue from &#39;vue&#39;. Next we need to declare the plugin inside your nuxt.config.js like so: 123plugins: [ &#123; src: &apos;~/plugins/vue-good-table&apos;, ssr: false &#125;], This should now work as expected.","tags":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/tags/Vue-good-table/"}],"categories":[{"name":"Vue-good-table","slug":"Vue-good-table","permalink":"https://vue-guide.github.io/categories/Vue-good-table/"}]},{"title":"동적 & 비동기 컴포넌트","date":"2020-02-05T10:04:47.000Z","path":"wiki/vue/components-dynamic-async/","text":"이 페이지는 컴포넌트 기초를 읽었다는 것을 가정합니다. 컴포넌트가 처음이라면 먼저 읽어야 합니다. keep-alive 동적 컴포넌트초기에는, 탭 인터페이스에서 컴포넌트들을 전환하기 위해서 is 특성을 사용했습니다. : 1&lt;component v-bind:is=\"currentTabComponent\"&gt;&lt;/component&gt; 컴포넌트들을 전환할 때 가끔 성능상의 이유로 상태를 유지하거나 재-렌더링을 피하길 원할 수 있습니다. 예를 들면, 탭 인터페이스를 약간 확장 할 때 : {{ tab }} Vue.component('tab-posts', { data: function () { return { posts: [ { id: 1, title: 'Cat Ipsum', content: 'Dont wait for the storm to pass, dance in the rain kick up litter decide to want nothing to do with my owner today demand to be let outside at once, and expect owner to wait for me as i think about it cat cat moo moo lick ears lick paws so make meme, make cute face but lick the other cats. Kitty poochy chase imaginary bugs, but stand in front of the computer screen. Sweet beast cat dog hate mouse eat string barf pillow no baths hate everything stare at guinea pigs. My left donut is missing, as is my right loved it, hated it, loved it, hated it scoot butt on the rug cat not kitten around' }, { id: 2, title: 'Hipster Ipsum', content: 'Bushwick blue bottle scenester helvetica ugh, meh four loko. Put a bird on it lumbersexual franzen shabby chic, street art knausgaard trust fund shaman scenester live-edge mixtape taxidermy viral yuccie succulents. Keytar poke bicycle rights, crucifix street art neutra air plant PBR&B hoodie plaid venmo. Tilde swag art party fanny pack vinyl letterpress venmo jean shorts offal mumblecore. Vice blog gentrify mlkshk tattooed occupy snackwave, hoodie craft beer next level migas 8-bit chartreuse. Trust fund food truck drinking vinegar gochujang.' }, { id: 3, title: 'Cupcake Ipsum', content: 'Icing dessert soufflé lollipop chocolate bar sweet tart cake chupa chups. Soufflé marzipan jelly beans croissant toffee marzipan cupcake icing fruitcake. Muffin cake pudding soufflé wafer jelly bear claw sesame snaps marshmallow. Marzipan soufflé croissant lemon drops gingerbread sugar plum lemon drops apple pie gummies. Sweet roll donut oat cake toffee cake. Liquorice candy macaroon toffee cookie marzipan.' } ], selectedPost: null } }, template: '\\ \\ \\ \\ {{ post.title }}\\ \\ \\ \\ \\ {{ selectedPost.title }}\\ \\ \\ \\ Click on a blog title to the left to view it.\\ \\ \\ \\ ' }) Vue.component('tab-archive', { template: 'Archive component' }) new Vue({ el: '#dynamic-component-demo', data: { currentTab: 'Posts', tabs: ['Posts', 'Archive'] }, computed: { currentTabComponent: function () { return 'tab-' + this.currentTab.toLowerCase() } } }) .dynamic-component-demo-tab-button { padding: 6px 10px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: 1px solid #ccc; cursor: pointer; background: #f0f0f0; margin-bottom: -1px; margin-right: -1px; } .dynamic-component-demo-tab-button:hover { background: #e0e0e0; } .dynamic-component-demo-tab-button.dynamic-component-demo-active { background: #e0e0e0; } .dynamic-component-demo-tab { border: 1px solid #ccc; padding: 10px; } .dynamic-component-demo-posts-tab { display: flex; } .dynamic-component-demo-posts-sidebar { max-width: 40vw; margin: 0 !important; padding: 0 10px 0 0 !important; list-style-type: none; border-right: 1px solid #ccc; } .dynamic-component-demo-posts-sidebar li { white-space: nowrap; text-overflow: ellipsis; overflow: hidden; cursor: pointer; } .dynamic-component-demo-posts-sidebar li:hover { background: #eee; } .dynamic-component-demo-posts-sidebar li.dynamic-component-demo-active { background: lightblue; } .dynamic-component-demo-post-container { padding-left: 10px; } .dynamic-component-demo-post > :first-child { margin-top: 0 !important; padding-top: 0 !important; } 게시물을 선택하고, Archive 탭으로 전환하고, 다시 Posts로 전환할 때, 선택했던 게시물이 더는 보지 않는 것 알아차릴 수 있습니다. 그 이유는 매번 새로운 탭을 선택할 때, Vue는 currentTabComponent의 새로운 인스턴스를 생성하기 때문입니다. 동적 컴포넌트를 재생성하는 것은 보통은 유용한 동작입니다. 하지만 이 경우에는, 탭 컴포넌트 인스턴스가 처음 생성될 때 캐시 되는 것을 선호합니다. 이런 문제를 해결하기 위해서, 동적 컴포넌트를 &lt;keep-alive&gt; 엘리먼트로 둘러쌀 수 있습니다. : 1234&lt;!-- Inactive components will be cached! --&gt;&lt;keep-alive&gt; &lt;component v-bind:is=\"currentTabComponent\"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 아래 결괴를 확인하세요. : {{ tab }} new Vue({ el: '#dynamic-component-keep-alive-demo', data: { currentTab: 'Posts', tabs: ['Posts', 'Archive'] }, computed: { currentTabComponent: function () { return 'tab-' + this.currentTab.toLowerCase() } } }) 이제 Posts 탭은 (게시물이 선택된) 상태를 유지할 수 있고 심지어 렌더링하지 않습니다. 완성된 코드는 this fiddle에서 볼 수 있습니다. ``가 컴포넌트에서 `name` 옵션을 사용하거나 로컬/글로벌 등록을 하여 정의된 모든 것들로 전환되고 있는 컴포넌트들을 요구한다는 것을 유의하세요. 더 자세한 내용은 [API reference](../api/#keep-alive)에서 ` 확인해주세요. Async ComponentsWatch a free video lesson on Vue School In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it's needed. To make that easier, Vue allows you to define your component as a factory function that asynchronously resolves your component definition. Vue will only trigger the factory function when the component needs to be rendered and will cache the result for future re-renders. For example: 12345678Vue.component(\"async-example\", function(resolve, reject) &#123; setTimeout(function() &#123; // Pass the component definition to the resolve callback resolve(&#123; template: \"&lt;div&gt;I am async!&lt;/div&gt;\" &#125;); &#125;, 1000);&#125;); As you can see, the factory function receives a resolve callback, which should be called when you have retrieved your component definition from the server. You can also call reject(reason) to indicate the load has failed. The setTimeout here is for demonstration; how to retrieve the component is up to you. One recommended approach is to use async components together with Webpack’s code-splitting feature: 123456Vue.component(\"async-webpack-example\", function(resolve) &#123; // This special require syntax will instruct Webpack to // automatically split your built code into bundles which // are loaded over Ajax requests. require([\"./my-async-component\"], resolve);&#125;); You can also return a Promise in the factory function, so with Webpack 2 and ES2015 syntax you can do: 12345Vue.component( \"async-webpack-example\", // The `import` function returns a Promise. () =&gt; import(\"./my-async-component\")); When using local registration, you can also directly provide a function that returns a Promise: 123456new Vue(&#123; // ... components: &#123; \"my-component\": () =&gt; import(\"./my-async-component\") &#125;&#125;); If you're a Browserify user that would like to use async components, its creator has unfortunately [made it clear](https://github.com/substack/node-browserify/issues/58#issuecomment-21978224) that async loading \"is not something that Browserify will ever support.\" Officially, at least. The Browserify community has found [some workarounds](https://github.com/vuejs/vuejs.org/issues/620), which may be helpful for existing and complex applications. For all other scenarios, we recommend using Webpack for built-in, first-class async support. ### Handling Loading State New in 2.3.0+ The async component factory can also return an object of the following format: 12345678910111213const AsyncComponent = () =&gt; (&#123; // The component to load (should be a Promise) component: import(\"./MyComponent.vue\"), // A component to use while the async component is loading loading: LoadingComponent, // A component to use if the load fails error: ErrorComponent, // Delay before showing the loading component. Default: 200ms. delay: 200, // The error component will be displayed if a timeout is // provided and exceeded. Default: Infinity. timeout: 3000&#125;); Note that you must use Vue Router 2.4.0+ if you wish to use the above syntax for route components.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"액션","date":"2019-12-07T10:04:47.000Z","path":"wiki/vuex/actions/","text":"액션액션은 변이와 유사합니다. 몇가지 다른 점은, 상태를 변이시키는 대신 액션으로 변이에 대한 커밋을 합니다. 작업에는 임의의 비동기 작업이 포함될 수 있습니다. 간단한 액션을 등록합시다. 123456789101112131415const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) 액션 핸들러는 저장소 인스턴스의 같은 메소드들/프로퍼티 세트를 드러내는 컨텍스트 객체를 받습니다. 그래서 context.commit을 호출하여 변이를 커밋하거나 context.state와 context.getters를 통해 상태와 getters에 접근 할 수 있습니다. 나중에 모듈에서 이 컨텍스트 객체가 저장소 인스턴스 자체가 아닌 이유를 알 수 있습니다. 실제로 (특히 commit를 여러 번 호출해야하는 경우)코드를 단순화하기 위해 ES2015 전달인자 분해를 사용합니다. 12345actions: &#123; increment (&#123; commit &#125;) &#123; commit('increment') &#125;&#125; 디스패치 액션액션은 store.dispatch 메소드로 시작됩니다. 1store.dispatch('increment') 처음 볼 때는 이상해 보일 수 있습니다. 카운트를 증가 시키려면 store.commit(&#39;increment&#39;)를 직접 호출하면 어떻습니까? 음, 상태변이는 동기적 이어야 한다는 것을 기억하십니까? 액션은 그렇지 않습니다. 액션 내에서 비동기 작업을 수행 할 수 있습니다. 1234567actions: &#123; incrementAsync (&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit('increment') &#125;, 1000) &#125;&#125; 액션은 동일한 페이로드 타입과 객체 스타일의 디스패치를 지원합니다. 12345678910// 페이로드와 함께 디스패치store.dispatch('incrementAsync', &#123; amount: 10&#125;)// 객체와 함께 디스패치store.dispatch(&#123; type: 'incrementAsync', amount: 10&#125;) 액션의 좀 더 실용적인 예는 비동기 API 호출 과 여러 개의 변이를 커밋 하는 장바구니 결제입니다. 123456789101112131415161718actions: &#123; checkout (&#123; commit, state &#125;, products) &#123; // 장바구니에 현재있는 항목을 저장하십시오. const savedCartItems = [...state.cart.added] // 결제 요청을 보낸 후 장바구니를 비웁니다. commit(types.CHECKOUT_REQUEST) // 상점 API는 성공 콜백 및 실패 콜백을 받습니다. shop.buyProducts( products, // 요청 성공 핸들러 () =&gt; commit(types.CHECKOUT_SUCCESS), // 요청 실패 핸들러 () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems) ) &#125;&#125; 비동기 작업의 흐름을 수행하고 커밋하여 작업의 사이드이펙트(상태 변이)을 기록합니다. 컴포넌트 내부에서 디스패치 액션 사용하기this.$store.dispatch(&#39;xxx&#39;)를 사용하여 컴포넌트에서 액션을 디스패치하거나 컴포넌트 메소드를 store.dispatch 호출에 매핑하는 mapActions 헬퍼를 사용할 수 있습니다 (루트 store 주입 필요) : 12345678910111213import &#123; mapActions &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapActions([ 'increment' // this.increment()을 this.$store.dispatch('increment')에 매핑 ]), ...mapActions(&#123; add: 'increment' // this.add()을 this.$store.dispatch('increment')에 매핑 &#125;) &#125;&#125; 액션 구성하기액션은 종종 비동기적 입니다. 그러면 액션이 언제 완료되는지 어떻게 알 수 있습니까? 더 중요한 것은, 복잡한 비동기 흐름을 처리하기 위해 어떻게 여러 작업을 함께 구성 할 수 있습니까? 가장 먼저 알아야 할 점은 store.dispatch가 트리거 된 액션 핸들러에 의해 반환된 Promise를 처리 할 수 있으며 Promise를 반환한다는 것입니다. 12345678910actions: &#123; actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') resolve() &#125;, 1000) &#125;) &#125;&#125; 이렇게 할 수 있습니다. 123store.dispatch('actionA').then(() =&gt; &#123; // ...&#125;) 그리고 안에 또 다른 액션을 사용할 수 있습니다. 12345678actions: &#123; // ... actionB (&#123; dispatch, commit &#125;) &#123; return dispatch('actionA').then(() =&gt; &#123; commit('someOtherMutation') &#125;) &#125;&#125; 마지막으로, JavaScript 기능인 async/await를 사용하면 다음과 같은 작업을 구성 할 수 있습니다. 12345678910// getData() 및 getOtherData()가 Promise를 반환한다고 가정합니다.actions: &#123; async actionA (&#123; commit &#125;) &#123; commit('gotData', await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch('actionA') // actionA가 끝나기를 기다립니다. commit('gotOtherData', await getOtherData()) &#125;&#125; store.dispatch가 다른 모듈에서 여러 액션 핸들러를 트리거하는 것이 가능합니다. 이 경우 반환 된 값은 모든 트리거 된 처리기가 완료 되었을 때 처리되는 Promise입니다.","tags":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/tags/Vuex/"}],"categories":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/categories/Vuex/"}]},{"title":"Strict 모드","date":"2019-12-07T10:04:47.000Z","path":"wiki/vuex/strict/","text":"Strict 모드strict 모드를 사용하기 위해, strict: true를 Vuex 저장소를 만들 때 추가하면 됩니다. 1234const store = new Vuex.Store(&#123; // ... strict: true&#125;) 엄격 모드에서는 Vuex 상태가 변이 핸들러 외부에서 변이 될 때 마다 오류가 발생합니다. 이렇게하면 디버깅 도구로 모든 상태 변이를 명시적으로 추적 할 수 있습니다. 개발 vs. 배포배포시 strict 모드를 켜지 마십시오! Strict 모드는 부적절한 변이를 감지하기 위해 상태 트리를 자세히 관찰합니다. 성능 이슈를 피하기 위해 배포 환경에서 이를 해제 하십시오. 플러그인과 마찬가지로 빌드 도구가 다음을 처리하도록 할 수 있습니다. 1234const store = new Vuex.Store(&#123; // ... strict: process.env.NODE_ENV !== 'production'&#125;)","tags":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/tags/Vuex/"}],"categories":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/categories/Vuex/"}]},{"title":"상태","date":"2019-12-07T10:04:47.000Z","path":"wiki/vuex/state/","text":"상태단일 상태 트리Vuex는 단일 상태 트리 를 사용합니다. 즉, 이 단일 객체는 모든 애플리케이션 수준의 상태를 포함하며 “원본 소스” 역할을 합니다. 이는 각 애플리케이션마다 하나의 저장소만 갖게 된다는 것을 의미합니다. 단일 상태 트리를 사용하면 특정 상태를 쉽게 찾을 수 있으므로 디버깅을 위해 현재 앱 상태의 스냅 샷을 쉽게 가져올 수 있습니다. 단일 상태 트리는 모듈성과 충돌하지 않습니다. 나중에 상태와 변이를 하위 모듈로 분할하는 방법에 대해 설명합니다. Vuex 상태를 Vue 컴포넌트에서 가져오기그러면 Vue 컴포넌트에서 저장소 내부의 상태를 어떻게 표시하나요? Vuex 저장소는 반응적이기 때문에 저장소에서 상태를 “검색”하는 가장 간단한 방법은 계산된 속성내에서 일부 저장소 상태를 가져오는 것입니다. 123456789// Counter 컴포넌트를 만듭니다const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return store.state.count &#125; &#125;&#125; store.state.count가 변경되면 계산된 속성이 다시 변경되고 관련 DOM 업데이트가 트리거됩니다. 그러나 이 패턴은 컴포넌트가 전역 저장소 단독 항목에 의존하게합니다. 모듈 시스템을 사용할 때는 저장소 상태를 사용하는 모든 컴포넌트에서 저장소를 가져와야하며 컴포넌트를 테스트 할 때는 가짜데이터가 필요합니다. Vuex는 store 옵션(Vue.use(Vuex)에 의해 가능)으로 루트 컴포넌트의 모든 자식 컴포넌트에 저장소를 “주입”하는 메커니즘을 제공합니다. 123456789101112const app = new Vue(&#123; el: '#app', // \"store\" 옵션을 사용하여 저장소를 제공하십시오. // 그러면 모든 하위 컴포넌트에 저장소 인스턴스가 삽입됩니다. store, components: &#123; Counter &#125;, template: ` &lt;div class=\"app\"&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; `&#125;) 루트 인스턴스에 store 옵션을 제공함으로써 저장소는 루트의 모든 하위 컴포넌트에 주입되고 this.$store로 사용할 수 있습니다. Counter 구현을 수정해야 합니다. 12345678const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;&#125; mapState 헬퍼컴포넌트가 여러 저장소 상태 속성이나 getter를 사용해야하는 경우 계산된 속성을 모두 선언하면 반복적이고 장황해집니다. 이를 처리하기 위해 우리는 계산된 getter 함수를 생성하는 mapState 헬퍼를 사용하여 키 입력을 줄일 수 있습니다. 123456789101112131415161718// 독립 실행 형 빌드에서 헬퍼가 Vuex.mapState로 노출됩니다.import &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: mapState(&#123; // 화살표 함수는 코드를 매우 간결하게 만들어 줍니다! count: state =&gt; state.count, // 문자열 값 'count'를 전달하는 것은 `state =&gt; state.count`와 같습니다. countAlias: 'count', // `this`를 사용하여 로컬 상태에 액세스하려면 일반적인 함수를 사용해야합니다 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;)&#125; 또한 매핑 된 계산된 속성의 이름이 상태 하위 트리 이름과 같을 때 문자열 배열을 mapState에 전달할 수 있습니다. 1234computed: mapState([ // this.count를 store.state.count에 매핑 합니다. 'count']) 객체 전개 연산자 (Object Spread Operator)mapState는 객체를 반환합니다. 다른 로컬 영역의 계산된 속성과 함께 사용하려면 어떻게 해야 하나요? 일반적으로, 최종 객체를 computed에 전달할 수 있도록 여러 객체를 하나로 병합하는 유틸리티를 사용해야합니다. 그러나 (3 단계 ECMAScript 스펙) 객체 전개 연산자 (Object Spread Operator)을 사용하면 문법을 매우 단순화 할 수 있습니다. 1234567computed: &#123; localComputed () &#123; /* ... */ &#125;, // 이것을 객체 전개 연산자(Object Spread Operator)를 사용하여 외부 객체에 추가 하십시오. ...mapState(&#123; // ... &#125;)&#125; 컴포넌트에는 여전히 로컬 상태가 있을 수 있습니다.Vuex를 사용한다고해서 Vuex에 모든 상태를 넣어야하는 것은 아닙니다. Vuex에 더 많은 상태를 넣으면 상태 변이가 더 명확하고 디버그 가능하지만, 때로는 코드를 보다 장황하고 간접적으로 만들 수 있습니다. 상태 조각이 단일 컴포넌트에 엄격하게 속한 경우 로컬 상태로 남겨 둘 수 있습니다. 기회비용을 판단하고 앱의 개발 요구에 맞는 결정을 내려야 합니다.","tags":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/tags/Vuex/"}],"categories":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/categories/Vuex/"}]},{"title":"플러그인","date":"2019-12-07T10:04:47.000Z","path":"wiki/vuex/plugins/","text":"플러그인Vuex 저장소는 각 변이에 대한 훅을 노출하는 plugins 옵션을 허용합니다. Vuex 플러그인은 저장소를 유일한 전달인자로 받는 함수입니다. 1234567const myPlugin = store =&gt; &#123; // 저장소가 초기화 될 때 불립니다. store.subscribe((mutation, state) =&gt; &#123; // 매 변이시마다 불립니다. // 변이는 &#123; type, payload &#125; 포맷으로 제공됩니다. &#125;)&#125; 그리고 다음과 같이 사용할 수 있습니다. 1234const store = new Vuex.Store(&#123; // ... plugins: [myPlugin]&#125;) 플러그인 내부에서 변이 커밋하기플러그인은 상태를 직접 변이할 수 없습니다. 컴포넌트와 마찬가지로 변이를 커밋하여 변경을 트리거 할 수 있습니다. 변이을 커밋함으로써 플러그인을 사용하여 데이터 소스를 저장소에 동기화 할 수 있습니다. 예를 들어, websocket 데이터 소스를 저장소에 동기화하려면 (이는 사실 인위적인 예제입니다. 실제로 createPlugin 함수는 더 복잡한 작업을 위해 몇 가지 추가 옵션을 필요로 할 수 있습니다) 123456789101112export default function createWebSocketPlugin (socket) &#123; return store =&gt; &#123; socket.on('data', data =&gt; &#123; store.commit('receiveData', data) &#125;) store.subscribe(mutation =&gt; &#123; if (mutation.type === 'UPDATE_DATA') &#123; socket.emit('update', mutation.payload) &#125; &#125;) &#125;&#125; 1234567const plugin = createWebSocketPlugin(socket)const store = new Vuex.Store(&#123; state, mutations, plugins: [plugin]&#125;) 상태 스냅샷 가져오기때로는 플러그인이 상태의 “스냅샷”을 얻고자 할 수 있으며, 또한 변이 이후 상태와 변이 이전 상태를 비교할 수 있습니다. 이를 달성하기 위해서는 상태 객체에 대한 깊은 복사를 수행해야합니다 : 1234567891011const myPluginWithSnapshot = store =&gt; &#123; let prevState = _.cloneDeep(store.state) store.subscribe((mutation, state) =&gt; &#123; let nextState = _.cloneDeep(state) // prevState와 nextState를 비교하십시오. // 다음 변이를 위한 상태 저장 prevState = nextState &#125;)&#125; 상태 스냅 샷을 사용하는 플러그인은 개발 중에 만 사용해야합니다. webpack 또는 Browserify를 사용하는 경우 빌드 도구가 이를 처리 할 수 있습니다. 123456const store = new Vuex.Store(&#123; // ... plugins: process.env.NODE_ENV !== 'production' ? [myPluginWithSnapshot] : []&#125;) 플러그인은 기본적으로 사용됩니다. 배포를 위해서는 webpack의 DefinePlugin 또는 envify가 필요합니다. Browserify가 process.env.NODE_ENV !== &#39;production&#39;의 값을 최종 빌드를 위해 false로 변환합니다. 내장 로거 플러그인 vue-devtools를 사용하고 있으면 필요 없을 수 있습니다. Vuex에는 일반적인 디버깅을 위한 로거 플러그인이 함께 제공됩니다. 12345import createLogger from 'vuex/dist/logger'const store = new Vuex.Store(&#123; plugins: [createLogger()]&#125;) createLogger 함수는 몇 가지 옵션을 가질 수 있습니다. 123456789101112131415161718const logger = createLogger(&#123; collapsed: false, // 로그를 가지는 변이 자동 확장 filter (mutation, stateBefore, stateAfter) &#123; // returns true if a mutation should be logged // `mutation` is a &#123; type, payload &#125; return mutation.type !== \"aBlacklistedMutation\" &#125;, transformer (state) &#123; // 로깅하기전 상태를 변이 하십시오. // 예를 들어 특정 하위 트리만 반환합니다. return state.subTree &#125;, mutationTransformer (mutation) &#123; // 변이는 &#123; type, payload &#125;의 포맷으로 기록됩니다. // 원하는 포맷으로 변경할 수 있습니다. return mutation.type &#125;&#125;) 로거 파일은&lt;script&gt;태그를 통해 직접 포함될 수 있으며 createVuexLogger 함수를 전역적으로 노출합니다. 로거 플러그인은 상태 스냅샷을 사용하므로 개발용으로만 사용하십시오.","tags":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/tags/Vuex/"}],"categories":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/categories/Vuex/"}]},{"title":"폼 핸들링","date":"2019-12-07T10:04:47.000Z","path":"wiki/vuex/forms/","text":"폼 핸들링strict 모드로 Vuex를 사용하는 경우 Vuex에 포함된 부분에 v-model을 사용하는 것은 약간 까다로울 수 있습니다. 1&lt;input v-model=\"obj.message\"&gt; obj가 저장소에서 객체를 반환하는 계산된 속성이라면, 여기에있는 v-model은 사용자가 입력 할 때 obj.message를 직접 변경하려고 합니다. strict 모드에서는 Vuex 변이 처리기 내부에서 변이가 수행되지 않으므로 오류가 발생합니다. 그것을 다루는 “Vuex 방식”은 &lt;input&gt;의 값을 바인딩하고 input 또는 change 이벤트에 대한 액션을 호출하는 것 입니다. 1&lt;input :value=\"message\" @input=\"updateMessage\"&gt; 1234567891011// ...computed: &#123; ...mapState(&#123; message: state =&gt; state.obj.message &#125;)&#125;,methods: &#123; updateMessage (e) &#123; this.$store.commit('updateMessage', e.target.value) &#125;&#125; 변이에 대한 핸들러 입니다. 123456// ...mutations: &#123; updateMessage (state, message) &#123; state.obj.message = message &#125;&#125; 양방향 계산된 속성틀림없이, 위의 내용은 v-model + 지역 상태보다 좀더 장황 해졌고, v-model의 유용한 기능 중 일부를 잃어 버렸습니다. 다른 방법은 setter를 사용하여 양방향 계산된 속성을 사용하는 것입니다. 1&lt;input v-model=\"message\"&gt; 1234567891011// ...computed: &#123; message: &#123; get () &#123; return this.$store.state.obj.message &#125;, set (value) &#123; this.$store.commit('updateMessage', value) &#125; &#125;&#125;","tags":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/tags/Vuex/"}],"categories":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/categories/Vuex/"}]},{"title":"Getters","date":"2019-12-07T10:04:47.000Z","path":"wiki/vuex/getters/","text":"Getters때로는 저장소 상태를 기반하는 상태를 계산해야 할 수도 있습니다.(예: 아이템 리스트를 필터링하고 계산) 12345computed: &#123; doneTodosCount () &#123; return this.$store.state.todos.filter(todo =&gt; todo.done).length &#125;&#125; 둘 이상의 컴포넌트가 이를 사용 해야하는 경우 함수를 복제하거나 공유된 헬퍼를 추출하여 여러 위치에서 가져와야합니다. 둘 다 이상적이지 않습니다. Vuex를 사용하면 저장소에서 “getters”를 정의 할 수 있습니다(저장소의 계산된 속성으로 생각됩니다). Getters는 첫 번째 전달인자로 상태를 받습니다. 12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) getters는 store.getters 객체에 노출 됩니다. 1store.getters.doneTodos // -&gt; [&#123; id: 1, text: '...', done: true &#125;] Getters는 두 번째 전달인자로 다른 getter도 받게됩니다. 123456getters: &#123; // ... doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125;&#125; 1store.getters.doneTodosCount // -&gt; 1 이제 모든 컴포넌트에서 쉽게 사용할 수 있습니다. 12345computed: &#123; doneTodosCount () &#123; return this.$store.getters.doneTodosCount &#125;&#125; mapGetters 헬퍼mapGetters 헬퍼는 저장소 getter를 로컬 계산된 속성에 매핑합니다. 12345678910111213import &#123; mapGetters &#125; from 'vuex'export default &#123; // ... computed: &#123; // getter를 객체 전개 연산자(Object Spread Operator)로 계산하여 추가합니다. ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) &#125;&#125; getter를 다른 이름으로 매핑하려면 객체를 사용합니다. 1234...mapGetters(&#123; // this.doneCount를 store.getters.doneTodosCount에 매핑하십시오. doneCount: 'doneTodosCount'&#125;)","tags":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/tags/Vuex/"}],"categories":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/categories/Vuex/"}]},{"title":"API 레퍼런스","date":"2019-12-07T10:04:47.000Z","path":"wiki/vuex/api/","text":"API 레퍼런스Vuex.Store123import Vuex from 'vuex'const store = new Vuex.Store(&#123; ...options &#125;) Vuex.Store 생성자 옵션 state 자료형: Object Vuex 저장소의 루트 상태 객체 입니다. 상세 mutations 자료형: { [type: string]: Function } 저장소에 변이를 등록하십시오. 핸들러 함수는 항상 첫 번째 전달인자로 state를 받습니다 (모듈에 정의 된 경우 모듈 로컬 상태가됩니다). 두 번째 payload 전달인자가 있으면 처리합니다. 상세 actions 자료형: { [type: string]: Function } 저장소에 액션을 등록하십시오. 핸들러 함수는 다음 속성을 노출하는 context 객체를받습니다. 1234567&#123; state, // store.state와 같습니다. 또는 모듈에 있는 경우 로컬 상태 rootState, // store.state와 같습니다. 모듈 안에만 존재합니다 commit, // store.commit와 같습니다. dispatch, // store.dispatch와 같습니다. getters // store.getters와 같습니다.&#125; 상세 getters 자료형: { [key: string]: Function } 저장소에 getter를 등록하십시오. getter 함수는 다음 전달인자를 받습니다. 123state, // 모듈에 정의 된 경우 모듈 로컬 상태가됩니다.getters, // store.getters와 같습니다.rootState // store.state와 같습니다. 등록된 getter는 store.getters에 노출됩니다. 상세 modules 자료형: Object 저장소에 병합될 하위 모듈을 포함하는 객체 입니다. 12345678910&#123; key: &#123; state, mutations, actions?, getters?, modules? &#125;, ...&#125; 각 모듈은 루트 옵션과 비슷한 state 와 mutations 를 포함 할 수 있습니다. 모듈의 상태는 모듈의 키를 사용하여 저장소의 루트 상태에 연결됩니다. 모듈의 변이와 getter는 모듈의 로컬 상태를 루트 상태 대신 첫 번째 전달인자로 받으며 모듈 액션의 context.state도 로컬 상태를 가리 킵니다. 상세 plugins 자료형: Array&lt;Function&gt; 저장소에 적용 할 플러그인 함수의 배열입니다. 플러그인은 저장소를 유일한 전달인자로 받아들이고 아웃바운드 데이터 지속성, 로깅 또는 디버깅을 위한 변이를 감시하거나 (인바운드 데이터 (예: 웹 소켓 또는 관찰 가능 항목)의 디스패치 변이) 감시할 수 있습니다. 상세 strict 자료형: Boolean 기본값: false Vuex 저장소를 strict 모드로 변경합니다. strict 모드에서 변이 핸들러 외부의 Vuex 상태에 대한 임의의 변이는 오류를 발생시킵니다. 상세 Vuex.Store 인스턴스 속성 state 자료형: Object 루트 상태. 읽기 전용 getters 자료형: Object 등록된 getters 입니다. 읽기 전용. Vuex.Store 인스턴스 메소드 commit(type: string, payload?: any) | commit(mutation: Object) 변이를 커밋합니다. 상세 dispatch(type: string, payload?: any) | dispatch(action: Object) 액션을 디스패치 합니다. 모든 트리거된 액션 핸들러를 처리하는 Promise를 반환합니다. 상세 replaceState(state: Object) 저장소의 루트 상태를 바꿉니다. 상태에 대한 상호작용/시점 변경 목적으로 만 사용하십시오. watch(getter: Function, cb: Function, options?: Object) getter 함수의 반환 값을 반응적으로 지켜보고 값이 변경되면 콜백을 호출합니다. getter는 저장소의 상태를 유일한 인수로받습니다. Vue의 vm.$watch 메소드와 같은 옵션을 취하는 옵션 객체를 받아들입니다. 감시를 중단하려면 반환된 핸들 함수를 호출하십시오. subscribe(handler: Function) 저장소 변이를 구독합니다. handler는 모든 변이 이후 호출되고 변이 디스크립터와 변이 상태를 전달인자로 받습니다. 1234store.subscribe((mutation, state) =&gt; &#123; console.log(mutation.type) console.log(mutation.payload)&#125;) 플러그인에서 가장 일반적으로 사용됩니다. 상세 registerModule(path: string | Array&lt;string&gt;, module: Module, options?: Object) 동적 모듈을 등록합니다. 상세 options은 이전 속성을 보호하는 preserveState: true를 가질 수 있습니다. 이것은 서버사이드 렌더링에서 유용합니다. unregisterModule(path: string | Array&lt;string&gt;) 동적 모듈을 해제 합니다. 상세 hotUpdate(newOptions: Object) 새 액션과 변이를 핫 스왑 합니다. 상세 컴포넌트 바인딩 헬퍼 mapState(namespace?: string, map: Array&lt;string&gt; | Object): Object Vuex 저장소의 하위 트리를 반환하는 컴포넌트 계산 옵션을 만듭니다. 상세 처음 argument는 string 타입의 namespace가 될 수 있습니다. 상세 mapGetters(namespace?: string, map: Array&lt;string&gt; | Object): Object getter의 평가된 값을 반환하는 컴포넌트 계산 옵션을 만듭니다. 상세 처음 argument는 string 타입의 namespace가 될 수 있습니다. 상세 mapActions(namespace?: string, map: Array&lt;string&gt; | Object): Object 액션을 전달하는 컴포넌트 메소드 옵션을 만듭니다. 상세 처음 argument는 string 타입의 namespace가 될 수 있습니다. 상세 mapMutations(namespace?: string, map: Array&lt;string&gt; | Object): Object 변이를 커밋하는 컴포넌트 메소드 옵션을 만듭니다. 상세 처음 argument는 string 타입의 namespace가 될 수 있습니다. 상세 createNamespacedHelpers(namespace: string): Object namespace가 적용된 컴포넌트 바인딩 helper를 만듭니다. 주어진 namespace가 적용된 mapState, mapGetters, mapActions mapMutations들을 가지고 있는 오브젝트를 반환합니다. 상세","tags":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/tags/Vuex/"}],"categories":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/categories/Vuex/"}]},{"title":"테스팅","date":"2019-12-07T10:04:47.000Z","path":"wiki/vuex/testing/","text":"테스팅Vuex에서 단위 테스트를 하고자 하는 주요 부분은 변이와 액션입니다. 변이 테스팅변이는 테스트하기 매우 간단합니다. 왜냐하면 변이는 전달인자에 완전히 의존하는 함수이기 때문입니다. 한 가지 트릭은 ES2015 모듈을 사용하고 store.js 파일에 변이를 넣는다면 기본 내보내기와 함께 변이를 명명된 내보내기로 내보낼 수 있다는 것입니다. 123456789const state = &#123; ... &#125;// 변이를 이름을 가지는 내보내기를 이용하여 내보냅니다.export const mutations = &#123; ... &#125;export default new Vuex.Store(&#123; state, mutations&#125;) Mocha + Chai를 사용하여 변이를 테스팅 하는 예(원하는 프레임워크/assertion 라이브러리를 사용할 수 있습니다.) 1234// mutations.jsexport const mutations = &#123; increment: state =&gt; state.count++&#125; 1234567891011121314151617// mutations.spec.jsimport &#123; expect &#125; from 'chai'import &#123; mutations &#125; from './store'// 변이 가져오기const &#123; increment &#125; = mutationsdescribe('mutations', () =&gt; &#123; it('INCREMENT', () =&gt; &#123; // mock 상태 const state = &#123; count: 0 &#125; // 변이 적용 increment(state) // 결과 확인 expect(state.count).to.equal(1) &#125;)&#125;) 액션 테스팅액션은 외부 API를 호출 할 수 있기 때문에 좀 더 까다로울 수 있습니다. 액션을 테스트 할 때 우리는 일반적으로 조작을 어느 정도 해야합니다. 예를 들어 API 호출을 서비스로 추상화하고 테스트 내에서 해당 서비스를 조작 할 수 있습니다. 의존성을 쉽게 모방하기 위해 webpack과 inject-loader를 사용하여 테스트 파일을 묶을 수 있습니다. 비동기 액션 테스트 예제: 123456789// actions.jsimport shop from '../api/shop'export const getAllProducts = (&#123; commit &#125;) =&gt; &#123; commit('REQUEST_PRODUCTS') shop.getProducts(products =&gt; &#123; commit('RECEIVE_PRODUCTS', products) &#125;)&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// actions.spec.js// 인라인 로더에는 require 구문을 사용하십시오.// inject-loader를 사용하면 조작된 의존성을// 주입 할 수있는 모듈 팩토리가 반환됩니다.import &#123; expect &#125; from 'chai'const actionsInjector = require('inject-loader!./actions')// 조작된 모의 응답과 함께 모듈 생성const actions = actionsInjector(&#123; '../api/shop': &#123; getProducts (cb) &#123; setTimeout(() =&gt; &#123; cb([ /* 모의 응답 */ ]) &#125;, 100) &#125; &#125;&#125;)// 예상되는 변이와 함께 테스팅 액션을 도와주는 헬퍼const testAction = (action, payload, state, expectedMutations, done) =&gt; &#123; let count = 0 // 모의 커밋 const commit = (type, payload) =&gt; &#123; const mutation = expectedMutations[count] try &#123; expect(type).to.equal(mutation.type) if (payload) &#123; expect(payload).to.deep.equal(mutation.payload) &#125; &#125; catch (error) &#123; done(error) &#125; count++ if (count &gt;= expectedMutations.length) &#123; done() &#125; &#125; // 모의 저장소와 전달인자로 액션을 부릅니다. action(&#123; commit, state &#125;, payload) // 디스패치된 변이가 없는지 확인 if (expectedMutations.length === 0) &#123; expect(count).to.equal(0) done() &#125;&#125;describe('actions', () =&gt; &#123; it('getAllProducts', done =&gt; &#123; testAction(actions.getAllProducts, null, &#123;&#125;, [ &#123; type: 'REQUEST_PRODUCTS' &#125;, &#123; type: 'RECEIVE_PRODUCTS', payload: &#123; /* 모의 응답 */ &#125; &#125; ], done) &#125;)&#125;) Getters 테스팅Getter에 복잡한 연산이 있는 경우 테스트하는 것이 좋습니다. Getter는 변이와 같은 이유로 테스트하는 것이 매우 간단합니다. getter 테스팅 예제: 12345678// getters.jsexport const getters = &#123; filteredProducts (state, &#123; filterCategory &#125;) &#123; return state.products.filter(product =&gt; &#123; return product.category === filterCategory &#125;) &#125;&#125; 123456789101112131415161718192021222324252627// getters.spec.jsimport &#123; expect &#125; from 'chai'import &#123; getters &#125; from './getters'describe('getters', () =&gt; &#123; it('filteredProducts', () =&gt; &#123; // mock state const state = &#123; products: [ &#123; id: 1, title: 'Apple', category: 'fruit' &#125;, &#123; id: 2, title: 'Orange', category: 'fruit' &#125;, &#123; id: 3, title: 'Carrot', category: 'vegetable' &#125; ] &#125; // 모의 getter const filterCategory = 'fruit' // getter로 부터 결과를 받습니다 const result = getters.filteredProducts(state, &#123; filterCategory &#125;) // 결과 테스트 expect(result).to.deep.equal([ &#123; id: 1, title: 'Apple', category: 'fruit' &#125;, &#123; id: 2, title: 'Orange', category: 'fruit' &#125; ]) &#125;)&#125;) 테스트 실행변이와 액션이 제대로 작성되면 적절한 모의 조작을 한 후 브라우저 API에 직접적인 의존성이 없어야합니다. 따라서 webpack을 사용하여 테스트를 번들로 묶어 Node를 이용해 직접 실행할 수 있습니다. 또는, mocha-loader 나 Karma + karma-webpack을 사용하여 실제 브라우저에서 테스트를 실행할 수 있습니다. Node를 이용한 실행다음과 같이 webpack 설정을 하십시오 (.babelrc도 함께 필요 합니다.) 1234567891011121314151617// webpack.config.jsmodule.exports = &#123; entry: './test.js', output: &#123; path: __dirname, filename: 'test-bundle.js' &#125;, module: &#123; loaders: [ &#123; test: /\\.js$/, loader: 'babel-loader', exclude: /node_modules/ &#125; ] &#125;&#125; 이제, 12webpackmocha test-bundle.js 브라우저에서 테스팅 mocha-loader를 설치하세요. webpack 설정에서 entry를 &#39;mocha!babel!./test.js&#39;로 변경하세요. 설정을 이용하여 webpack-dev-server를 실행하세요. localhost:8080/webpack-dev-server/test-bundle로 가세요. 브라우저와 Karma + karma-webpack을 이용한 테스팅vue-loader 문서를 확인하세요.","tags":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/tags/Vuex/"}],"categories":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/categories/Vuex/"}]},{"title":"애플리케이션 구조","date":"2019-12-07T10:04:47.000Z","path":"wiki/vuex/structure/","text":"애플리케이션 구조실제로 Vuex는 코드 구조를 제한하지는 않습니다. 이보다 아래에 있는 상위 수준 원칙을 강요합니다. 애플리케이션 레벨의 상태는 중앙 집중된 저장소 입니다. 상태를 변경시키는 유일한 방법은 동기 트랜잭션인 변이 를 커밋하는 것입니다. 비동기식 로직은 캡슐화되어야하며 액션 으로 구성 됩니다. 이 규칙을 따른다면 프로젝트를 구조화하는 것은 사용자에게 달려 있습니다. 저장소 파일이 너무 커지면 액션, 돌연변이 및 getter를 개별 파일로 분할하기만 하면됩니다. 중요한 앱의 경우 모듈을 활용해야 할 가능성이 높습니다. 다음은 프로젝트 구조의 예입니다. 1234567891011121314├── index.html├── main.js├── api│ └── ... # API 요청을 위한 추상화를 포함합니다.├── components│ ├── App.vue│ └── ...└── store ├── index.js # 모듈을 조합하고 저장소를 내보내는 곳 입니다. ├── actions.js # 루트 액션 ├── mutations.js # 루트 변이 └── modules ├── cart.js # cart 모듈 └── products.js # products 모듈 참고 사항으로, 장바구니 예를 확인하십시오.","tags":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/tags/Vuex/"}],"categories":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/categories/Vuex/"}]},{"title":"핫 리로딩","date":"2019-12-01T10:04:47.000Z","path":"wiki/vuex/hot-reload/","text":"핫 리로딩Vuex는 webpack의 핫 모듈 변경 API를 사용하여 개발 중에 핫 리로드 변이, 모듈, 액션 및 getter를 지원합니다. browserify-hmr 플러그인으로 Browserify에서 사용할 수도 있습니다. 변이와 모듈의 경우, store.hotUpdate() API 메소드를 사용할 필요가 있습니다. 12345678910111213141516171819202122232425262728293031323334// store.jsimport Vue from 'vue'import Vuex from 'vuex'import mutations from './mutations'import moduleA from './modules/a'Vue.use(Vuex)const state = &#123; ... &#125;const store = new Vuex.Store(&#123; state, mutations, modules: &#123; a: moduleA &#125;&#125;)if (module.hot) &#123; // 액션과 변이를 핫 모듈로 받아 들인다. module.hot.accept(['./mutations', './modules/a'], () =&gt; &#123; // 업데이트 된 모듈은 babel 6 모듈 출력으로 인해 // .default를 여기에 추가해야합니다. const newMutations = require('./mutations').default const newModuleA = require('./modules/a').default // 새로운 액션과 변이로 바꿉니다. store.hotUpdate(&#123; mutations: newMutations, modules: &#123; a: newModuleA &#125; &#125;) &#125;)&#125; counter-hot 예제로 핫 리로드를 확인하십시오.","tags":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/tags/Vuex/"}],"categories":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/categories/Vuex/"}]},{"title":"설치","date":"2019-12-01T10:04:47.000Z","path":"wiki/vuex/installation/","text":"설치직접 다운로드 / CDNhttps://unpkg.com/vuex Unpkg.com은 NPM 기반 CDN 링크를 제공합니다. 위의 링크는 항상 NPM의 최신 릴리스를 가리킵니다. https://unpkg.com/vuex@2.0.0과 같은 URL을 통해 특정 버전/태그를 사용할 수도 있습니다. Vue 뒤에 vuex를 추가하면 자동으로 설치됩니다: 12&lt;script src=\"/path/to/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"/path/to/vuex.js\"&gt;&lt;/script&gt; NPM1npm install vuex --save Yarn1yarn add vuex 모듈 시스템과 함께 사용하면 Vue.use()를 통해 Vuex를 명시적으로 추가해야 합니다. 1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) 전역 스크립트 태그를 사용할 때는 이 작업을 할 필요가 없습니다. 개발용 빌드최신 dev 빌드를 사용하고 싶은 경우 직접 GitHub에서 클론하고 vuex를 직접 빌드 해야합니다. 1234git clone https://github.com/vuejs/vuex.git node_modules/vuexcd node_modules/vuexnpm installnpm run build","tags":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/tags/Vuex/"}],"categories":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/categories/Vuex/"}]},{"title":"Vuex가 무엇인가요?","date":"2019-12-01T10:04:47.000Z","path":"wiki/vuex/intro/","text":"Vuex가 무엇인가요?Vuex는 Vue.js 애플리케이션에 대한 상태 관리 패턴 + 라이브러리 입니다. 애플리케이션의 모든 컴포넌트에 대한 중앙 집중식 저장소 역할을 하며 예측 가능한 방식으로 상태를 변경할 수 있습니다. 또한 Vue의 공식 devtools 확장 프로그램과 통합되어 설정 시간이 필요 없는 디버깅 및 상태 스냅 샷 내보내기/가져오기와 같은 고급 기능을 제공합니다. “상태 관리 패턴”이란 무엇인가요?간단한 Vue 카운터 앱부터 시작 해보겠습니다. 123456789101112131415161718new Vue(&#123; // 상태 data () &#123; return &#123; count: 0 &#125; &#125;, // 뷰 template: ` &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; `, // 액션 methods: &#123; increment () &#123; this.count++ &#125; &#125;&#125;) 다음과 같은 기능을 가진 앱입니다. 상태 는 앱을 작동하는 원본 소스 입니다. 뷰 는 상태의 선언적 매핑입니다. 액션 은 뷰 에서 사용자 입력에 대해 반응적으로 상태를 바꾸는 방법입니다. 이것은 “단방향 데이터 흐름” 개념의 매우 단순한 도표입니다. 그러나 공통의 상태를 공유하는 여러 컴포넌트 가 있는 경우 단순함이 빠르게 저하됩니다. 여러 뷰는 같은 상태에 의존합니다. 서로 다른 뷰의 작업은 동일한 상태를 반영해야 할 수 있습니다. 첫번째 문제의 경우, 지나치게 중첩된 컴포넌트를 통과하는 prop는 장황할 수 있으며 형제 컴포넌트에서는 작동하지 않습니다. 두번째 문제의 경우 직접 부모/자식 인스턴스를 참조하거나 이벤트를 통해 상태의 여러 복사본을 변경 및 동기화 하려는 등의 해결 방법을 사용해야 합니다. 이러한 패턴은 모두 부서지기 쉽고 유지보수가 불가능한 코드로 빠르게 변경됩니다. 그렇다면 컴포넌트에서 공유된 상태를 추출하고 이를 전역 싱글톤으로 관리해야 합니다. 이를 통해 우리의 컴포넌트 트리는 커다란 “뷰”가 되며 모든 컴포넌트는 트리에 상관없이 상태에 액세스하거나 동작을 트리거 할 수 있습니다! 또한 상태 관리 및 특정 규칙 적용과 관련된 개념을 정의하고 분리함으로써 코드의 구조와 유지 관리 기능을 향상시킵니다. 이는 Flux, Redux, The Elm Architecture에서 영감을 받은 Vuex의 기본 아이디어 입니다. 다른 패턴과 달리 Vuex는 Vue.js가 효율적인 업데이트를 위해 세분화된 반응 시스템을 활용하도록 특별히 고안된 라이브러리입니다. 언제 사용해야 하나요?Vuex는 공유된 상태 관리를 처리하는 데 유용하지만, 개념에 대한 이해와 시작하는 비용도 함께 듭니다. 그것은 단기간과 장기간 생산성 간의 기회비용이 있습니다. 대규모 SPA를 구축하지 않고 Vuex로 바로 뛰어 들었다면, 시간이 오래 걸리고 힘든일일 것입니다. 이것은 일반 적인 일입니다. 앱이 단순하다면 Vuex없이는 괜찮을 것입니다. 간단한 글로벌 이벤트 버스만 있으면됩니다. 그러나 중대형 규모의 SPA를 구축하는 경우 Vue컴포넌트 외부의 상태를 보다 잘 처리할 수 있는 방법을 생각하게 될 가능성이 있으며 Vuex는 자연스럽게 선택할 수 있는 단계가 될 것입니다. Redux의 저자인 Dan Abramov의 좋은 인용이 있습니다. Flux 라이브러리는 안경과 같습니다. 필요할 때 알아볼 수 있습니다.","tags":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/tags/Vuex/"}],"categories":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/categories/Vuex/"}]},{"title":"모듈","date":"2019-12-01T10:04:47.000Z","path":"wiki/vuex/modules/","text":"모듈단일 상태 트리를 사용하기 때문에 애플리케이션의 모든 상태가 하나의 큰 객체 안에 포함됩니다. 그러나 규모가 커짐에 따라 저장소는 매우 비대해질 수 있습니다. 이를 위해 Vuex는 저장소를 모듈 로 나눌 수 있습니다. 각 모듈은 자체 상태, 변이, 액션, 게터 및 심지어 중첩된 모듈을 포함 할 수 있습니다. 12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA'의 상태store.state.b // -&gt; moduleB'의 상태 지역 상태 모듈모듈의 변이와 getter 내부에서 첫 번째 전달인자는 모듈의 지역 상태 가됩니다. 123456789101112131415const moduleA = &#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; // state는 지역 모듈 상태 입니다 state.count++ &#125; &#125;, getters: &#123; doubleCount (state) &#123; return state.count * 2 &#125; &#125;&#125; 유사하게 모듈 내부에서 context.state는 지역 상태를 노출시킬 것이고 루트 상태는 context.rootState로 노출 될 것입니다. 12345678910const moduleA = &#123; // ... actions: &#123; incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123; if ((state.count + rootState.count) % 2 === 1) &#123; commit('increment') &#125; &#125; &#125;&#125; 또한, 모듈 getters 내부, 루트 상태는 그들의 세 번째 전달인자로 노출됩니다. 12345678const moduleA = &#123; // ... getters: &#123; sumWithRootCount (state, getters, rootState) &#123; return state.count + rootState.count &#125; &#125;&#125; 네임스페이스모듈 내의 액션, 변이 및 getter는 여전히 전역 네임 스페이스 아래에 등록됩니다. 여러 모듈이 동일한 변이/액션 유형에 반응 할 수 있습니다. 이름 앞에 접두사 또는 접미사를 붙이면 이름 충돌을 피하기 위해 모듈 자신의 네임스페이스를 직접 지정할 수 있습니다. 그리고 알 수 없는 환경에서 사용될 재사용 가능한 Vuex 모듈을 작성하는 경우라면 반드시 사용해야 합니다. 예를 들어,todos 모듈을 만들고 싶은 경우 1234567// types.js// getter, 액션, 변이의 이름을 상수로 정의하고// 모듈 이름 `todos` 접두어를 붙입니다export const DONE_COUNT = 'todos/DONE_COUNT'export const FETCH_ALL = 'todos/FETCH_ALL'export const TOGGLE_DONE = 'todos/TOGGLE_DONE' 12345678910111213141516171819202122232425// modules/todos.jsimport * as types from '../types'// 접두어로 된 이름을 사용하여 getter, 액션 및 변이 정의const todosModule = &#123; state: &#123; todos: [] &#125;, getters: &#123; [types.DONE_COUNT] (state) &#123; // ... &#125; &#125;, actions: &#123; [types.FETCH_ALL] (context, payload) &#123; // ... &#125; &#125;, mutations: &#123; [types.TOGGLE_DONE] (state, payload) &#123; // ... &#125; &#125;&#125; 동적 모듈 등록store.registerModule 메소드로 저장소가 생성 된 후에 모듈을 등록 할 수 있습니다. 123store.registerModule('myModule', &#123; // ...&#125;) 모듈의 상태는store.state.myModule으로 노출 됩니다. 동적 모듈 등록을 사용하면 다른 Vue 플러그인도 애플리케이션의 저장소에 모듈을 연결하여 상태 관리에 Vuex를 활용할 수 있습니다. 예를 들어 vuex-router-sync 라이브러리는 동적으로 연결된 모듈에서 애플리케이션의 라우트 상태를 관리하여 vue-router와 vuex를 통합합니다. store.unregisterModule(moduleName)을 사용하여 동적으로 등록 된 모듈을 제거할 수도 있습니다. 이 방법으로는 정적 모듈(저장소 생성시 선언 됨)을 제거 할 수 없습니다.","tags":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/tags/Vuex/"}],"categories":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/categories/Vuex/"}]},{"title":"변이","date":"2019-12-01T10:04:47.000Z","path":"wiki/vuex/mutations/","text":"변이Vuex 저장소에서 실제로 상태를 변경하는 유일한 방법은 변이하는 것입니다. Vuex 변이는 이벤트와 매우 유사합니다. 각 변이에는 타입 문자열 핸들러 가 있습니다. 핸들러 함수는 실제 상태 수정을 하는 곳이며, 첫 번째 전달인자로 상태를받습니다. 1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; // 상태 변이 state.count++ &#125; &#125;&#125;) 변이 핸들러를 직접 호출 할 수는 없습니다. 이 옵션은 이벤트 등록과 비슷합니다. “타입이 increment인 변이가 발생하면이 핸들러를 호출합니다.” 변이 핸들러를 호출하려면 해당 타입과 함께 store.commit 을 호출해야합니다. 1store.commit('increment') 페이로드를 가진 커밋변이에 대해 payload 라고하는 store.commit에 추가 전달인자를 사용 할 수 있습니다. 123456// ...mutations: &#123; increment (state, n) &#123; state.count += n &#125;&#125; 1store.commit('increment', 10) 대부분의 경우 페이로드는 여러 필드를 포함할 수 있는 객체여야하며 기록 된 변이는 더 이해하기 쉽습니다. 123456// ...mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125; 123store.commit('increment', &#123; amount: 10&#125;) 객체 스타일 커밋변이를 커밋하는 또 다른 방법은 type 속성을 가진 객체를 직접 사용하는 것입니다. 1234store.commit(&#123; type: 'increment', amount: 10&#125;) 객체 스타일 커밋을 사용할 때 전체 객체는 변이 핸들러에 페이로드로 전달되므로 핸들러는 동일하게 유지됩니다. 12345mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125; Vue의 반응성 규칙을 따르는 변이Vuex 저장소의 상태는 Vue에 의해 반응하므로, 상태를 변경하면 상태를 관찰하는 Vue 컴포넌트가 자동으로 업데이트됩니다. 이것은 또한 Vuex 변이가 일반 Vue로 작업 할 때 동일한 반응성에 대한 경고를 받을 수 있음을 의미합니다. 원하는 모든 필드에 앞서 저장소를 초기화하는 것이 좋습니다. 객체에 새 속성을 추가할 때 다음 중 하나를 수행해야합니다. Vue.set(obj, &#39;newProp&#39;, 123)을 사용하거나, 객체를 새로운 것으로 교체하십시오. 예를 들어, 3 단계 객체 확산 문법을 사용하면 다음과 같이 작성할 수 있습니다. 1state.obj = &#123; ...state.obj, newProp: 123 &#125; 변이 타입에 상수 사용다양한 Flux 구현에서 변이 유형에 상수를 사용하는 것은 일반인 패턴입니다. 이를 통해 코드는 linter와 같은 툴링을 활용할 수 있으며 모든 상수를 단일 파일에 저장하면 공동 작업자가 전체 애플리케이션에서 어떤 변이가 가능한지 한눈에 파악할 수 있습니다. 12// mutation-types.jsexport const SOME_MUTATION = 'SOME_MUTATION' 1234567891011121314// store.jsimport Vuex from 'vuex'import &#123; SOME_MUTATION &#125; from './mutation-types'const store = new Vuex.Store(&#123; state: &#123; ... &#125;, mutations: &#123; // ES2015에서 계산 된 프로퍼티 이름 기능을 사용하여 // 상수를 함수 이름으로 사용할 수 있습니다 [SOME_MUTATION] (state) &#123; // 변이 상태 &#125; &#125;&#125;) 상수를 사용할지 여부는 대부분 환경 설정입니다. 개발자가 많은 대규모 프로젝트에서 유용할 수 있지만, 이는 완전히 선택 사항입니다. 변이는 무조건 동기적이어야 합니다.기억 해야할 한 가지 중요한 규칙은 변이 핸들러 함수는 동기적 이어야 한다는 것입니다. 왜 그럴까요? 다음 예제를 확인해보십시오. 1234567mutations: &#123; someMutation (state) &#123; api.callAsyncMethod(() =&gt; &#123; state.count++ &#125;) &#125;&#125; 이제 우리가 앱을 디버깅하고 devtool의 돌연변이 로그를 보고 있다고 상상해보십시오. 기록 된 모든 변이에 대해 devtool은 상태의 “이전” 및 “이후” 스냅 샷을 캡처 해야 합니다. 그러나 위의 예제 변이 내의 비동기 콜백은 불가능합니다. 변이가 커밋 되었을 때 콜백은 아직 호출되지 않으며, 콜백이 실제로 호출 될 시기를 devtool이 알 수 있는 방법이 없습니다. 콜백에서 수행 된 모든 상태 변이는 본질적으로 추적 할 수 없습니다! 컴포넌트 안에서 변이 커밋하기this.$store.commit(&#39;xxx&#39;)를 사용하여 컴포넌트에서 변이를 수행하거나 컴포넌트 메소드를 store.commit 호출에 매핑하는 mapMutations 헬퍼를 사용할 수 있습니다 (루트 store 주입 필요) 12345678910111213import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations([ 'increment' // this.increment()를 this.$store.commit('increment')에 매핑합니다. ]), ...mapMutations(&#123; add: 'increment' // this.add()를 this.$store.commit('increment')에 매핑합니다. &#125;) &#125;&#125; 액션에서 사용비동기성이 상태의 변이와 결합하면 프로그램을 파악하기가 매우 어려워 질 수 있습니다. 예를 들어 상태를 변경하는 두 가지 비동기 콜백 메소드를 호출할 때 호출되는 시점과 먼저 호출 된 콜백을 어떻게 알 수 있습니까? 이것이 우리가 두 개념을 분리하려는 이유입니다. Vuex에서 변이는 동기적으로 트랜잭션합니다. 12store.commit('increment')// \"increment\" 변이가 일으킬 수 있는 모든 상태 변화는 이 순간에 이루어져야합니다. 비동기 작업을 처리하기 위한 액션를 소개합시다.","tags":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/tags/Vuex/"}],"categories":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/categories/Vuex/"}]},{"title":"시작하기","date":"2019-12-01T10:04:47.000Z","path":"wiki/vuex/getting-started/","text":"시작하기모든 Vuex 애플리케이션의 중심에는 store 가 있습니다. “저장소”는 기본적으로 애플리케이션 상태 를 보유하고있는 컨테이너입니다. Vuex 저장소가 일반 전역 개체와 두 가지 다른 점이 있습니다. Vuex store는 반응형 입니다. Vue 컴포넌트는 상태를 검색할 때 저장소의 상태가 변경되면 효율적으로 대응하고 업데이트합니다. 저장소의 상태를 직접 변경할 수 없습니다. 저장소의 상태를 변경하는 유일한 방법은 명시적인 커밋을 이용한 변이 입니다. 이렇게하면 모든 상태에 대한 추적이 가능한 기록이 남을 수 있으며 툴을 사용하여 앱을 더 잘 이해할 수 있습니다. 가장 단순한 저장소 참고: 모든 예제는 ES2015 문법을 사용합니다. 사용하고 있지 않은 경우 꼭 사용해야 합니다! Vuex를 설치한 후 저장소를 만들어 봅시다. 매우 간단합니다. 초기 상태 객체와 일부 변이를 제공하십시오. 123456789101112// 모듈 시스템을 사용하는 경우 Vue.use(Vuex)를 먼저 호출해야합니다.const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;) 이제 state 객체에 store.state로 접근하여 store.commit 메소드로 상태 변경을 트리거 할 수 있습니다. 123store.commit('increment')console.log(store.state.count) // -&gt; 1 다시 말해, store.state.count를 직접 변경하는 대신 변이를 수행하는 이유는 명시적으로 추적을 하기 때문입니다. 이 간단한 규칙에 따라 의도를보다 명확하게 표현할 수 있으므로 코드를 읽을 때 상태 변화를 더 잘 지켜볼 수 있습니다. 또한 모든 변이를 기록하고 상태 스냅샷을 저장하거나 시간 흐름에 따라 디버깅을 할 수 있는 도구를 제공합니다. 컴포넌트 안에서 저장소 상태를 사용하는 것은 단순히 계산된 속성 내에서 상태를 반환하는 것입니다. 변경을 트리거하는 것은 컴포넌트 메소드에서 변경을 커밋하는 것을 의미합니다. 다음은 가장 기본적인 Vuex 카운터 앱의 예입니다. 이제, 우리는 각 핵심 개념에 대해 더 자세히 설명 할 것입니다. State부터 시작해 보겠습니다.","tags":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/tags/Vuex/"}],"categories":[{"name":"Vuex","slug":"Vuex","permalink":"https://vue-guide.github.io/categories/Vuex/"}]},{"title":"팀 구성원 만나기","date":"2019-08-03T10:04:47.000Z","path":"wiki/vue/team/","text":"{{ profile.name }} Core focus {{ repo.name || repo }} Ecosystem {{ repo.name || repo }} Work Distance About {{ textDistance }} away {{ textDistance }} away in {{ profile.city }} City {{ profile.city }} Languages Links {{ minimizeLink(link) }} Github Twitter CodePen LinkedIn Active Core Team Members find near me Failed to get your location. The development of Vue and its ecosystem is guided by an international team, some of whom have chosen to be featured below. The core team has been sorted by their distance from you. Core Team Emeriti Here we honor some no-longer-active core team members who have made valuable contributions in the past. Community Partners find near me Failed to get your location. Some members of the Vue community have so enriched it, that they deserve special mention. We've developed a more intimate relationship with these key partners, often coordinating with them on upcoming features and news. The community partners have been sorted by their distance from you. (function () { var cityCoordsFor = { 'Annecy, France': [45.899247, 6.129384], 'Alicante, Spain' : [38.346543, -0.483838], 'Amsterdam, Netherlands': [4.895168, 52.370216], 'Atlanta, GA, USA': [33.749051, -84.387858], 'Bangalore, India': [12.971599, 77.594563], 'Beijing, China': [39.904200, 116.407396], 'Bordeaux, France': [44.837789, -0.579180], 'Bucharest, Romania': [44.426767, 26.102538], 'Chengdu, China': [30.572815, 104.066801], 'Chongqing, China': [29.431586, 106.912251], 'Denver, CO, USA': [39.739236, -104.990251], 'Dublin, Ireland': [53.349918, -6.260174], 'Dubna, Russia': [56.732020, 37.166897], 'East Lansing, MI, USA': [42.736979, -84.483865], 'Fort Worth, TX, USA': [32.755331, -97.325735], 'Hangzhou, China': [30.274084, 120.155070], 'Jersey City, NJ, USA': [40.728157, -74.558716], 'Kingston, Jamaica': [18.017874, -76.809904], 'Krasnodar, Russia': [45.039267, 38.987221], 'Lansing, MI, USA': [42.732535, -84.555535], 'London, UK': [51.507351, -0.127758], 'Lyon, France': [45.764043, 4.835659], 'Mannheim, Germany': [49.487459, 8.466039], 'Moscow, Russia': [55.755826, 37.617300], 'Munich, Germany': [48.137154, 11.576124], 'Orlando, FL, USA': [28.538335, -81.379236], 'Paris, France': [48.856614, 2.352222], 'Poznań, Poland': [52.4006553, 16.761583], 'Seoul, South Korea': [37.566535, 126.977969], 'Shanghai, China': [31.230390, 121.473702], 'Singapore': [1.352083, 103.819839], 'Sydney, Australia': [-33.868820, 151.209290], 'Taquaritinga, Brazil': [-21.430094, -48.515285], 'Tehran, Iran': [35.689197, 51.388974], 'Thessaloniki, Greece': [40.640063, 22.944419], 'Tokyo, Japan': [35.689487, 139.691706], 'Toronto, Canada': [43.653226, -79.383184], 'Wrocław, Poland': [51.107885, 17.038538], 'Boston, MA, USA': [42.360081, -71.058884], 'Kyiv, Ukraine': [50.450100, 30.523399], 'Washington, DC, USA': [38.8935755,-77.0846156,12], 'Kraków, Poland': [50.064650, 19.936579], 'Oslo, Norway': [59.911491, 10.757933] } var languageNameFor = { en: 'English', nl: 'Nederlands', zh: '中文', vi: 'Tiếng Việt', pl: 'Polski', pt: 'Português', ru: 'Русский', jp: '日本語', fr: 'Français', de: 'Deutsch', el: 'Ελληνικά', es: 'Español', hi: 'हिंदी', fa: 'فارسی', ko: '한국어', ro: 'Română', uk: 'Українська', no: 'Norwegian' } var team = [{ name: 'Evan You', title: 'Benevolent Dictator For Life', city: 'Jersey City, NJ, USA', languages: ['zh', 'en'], github: 'yyx990803', twitter: 'youyuxi', work: { role: 'Creator', org: 'Vue.js' }, reposOfficial: [ 'vuejs/*', 'vuejs-templates/*' ], links: [ 'https://www.patreon.com/evanyou' ] }] team = team.concat(shuffle([ { name: 'Chris Fritz', title: 'Good Word Putter-Togetherer', city: 'Lansing, MI, USA', languages: ['en', 'de'], github: 'chrisvfritz', twitter: 'chrisvfritz', work: { role: 'Educator & Consultant' }, reposOfficial: [ 'vuejs.org', 'vue-migration-helper' ], reposPersonal: [ 'vue-2.0-simple-routing-example', 'vue-ssr-demo-simple' ], links: [ 'https://www.patreon.com/chrisvuefritz' ] }, { name: 'Eduardo', title: 'Real-Time Rerouter', city: 'Paris, France', languages: ['es', 'fr', 'en'], github: 'posva', twitter: 'posva', work: { role: 'Freelance Developer & Consultant', }, reposOfficial: [ 'vuefire', 'vue-router' ], reposPersonal: [ 'vuex-mock-store', 'vue-promised', 'vue-motion' ], links: [ 'https://www.patreon.com/posva' ] }, { name: 'Sodatea', city: 'Hangzhou, China', languages: ['zh', 'en'], github: 'sodatea', twitter: 'haoqunjiang', reposOfficial: [ 'vue-cli', 'vue-loader' ] }, { name: 'Pine Wu', languages: ['zh', 'en', 'jp'], github: 'octref', twitter: 'octref', work: { role: 'Engineer on VSCode', org: 'Microsoft' }, reposOfficial: [ 'vetur' ] }, { name: 'Jinjiang', title: 'Mobile Extrapolator', city: 'Hangzhou, China', languages: ['zh', 'en'], github: 'jinjiang', twitter: 'zhaojinjiang', work: { org: 'Alibaba', orgUrl: 'https://www.alibaba.com/' }, reposOfficial: [ 'cn.vuejs.org' ], reposPersonal: [ 'apache/incubator-weex' ] }, { name: 'Katashin', title: 'One of a Type State Manager', city: 'Singapore', languages: ['jp', 'en'], work: { role: 'Software Engineer', org: 'ClassDo', orgUrl: 'https://classdo.com' }, github: 'ktsn', twitter: 'ktsn', reposOfficial: [ 'vuex', 'vue-class-component' ], reposPersonal: [ 'vue-designer' ] }, { name: 'Kazupon', title: 'Validated Internationalizing Missionary', city: 'Tokyo, Japan', languages: ['jp', 'en'], github: 'kazupon', twitter: 'kazu_pon', work: { role: 'Engineer', org: 'PLAID, Inc.', orgUrl: 'https://plaid.co.jp' }, reposOfficial: [ 'vuejs.org', 'jp.vuejs.org' ], reposPersonal: [ 'vue-i18n', 'vue-cli-plugin-i18n', 'vue-i18n-loader', 'eslint-plugin-vue-i18n', 'vue-i18n-extensions', 'vue-cli-plugin-p11n' ], links: [ 'https://www.patreon.com/kazupon' ] }, { name: 'Rahul Kadyan', title: 'Ecosystem Glue Chemist', city: 'Bangalore, India', languages: ['hi', 'en'], work: { role: 'Software Engineer', org: 'Myntra', orgUrl: 'https://www.myntra.com/' }, github: 'znck', twitter: 'znck0', reposOfficial: [ 'rollup-plugin-vue', 'vue-issue-helper' ], reposPersonal: [ 'keynote', 'bootstrap-for-vue', 'vue-interop' ], links: [ 'https://znck.me', 'https://www.codementor.io/znck' ] }, { name: 'Linusborg', title: 'Hive-Mind Community Wrangler (Probably a Bot)', city: 'Mannheim, Germany', languages: ['de', 'en'], github: 'LinusBorg', twitter: 'Linus_Borg', reposOfficial: [ 'vuejs/*' ], reposPersonal: [ 'portal-vue' ], links: [ 'https://forum.vuejs.org/' ] }, { name: 'Guillaume Chau', title: 'Client-Server Astronaut', city: 'Lyon, France', languages: ['fr', 'en'], github: 'Akryum', twitter: 'Akryum', work: { role: 'Frontend Developer', org: 'Livestorm', orgUrl: 'https://livestorm.co/' }, reposOfficial: [ 'vue-devtools', 'vue-cli', 'vue-curated' ], reposPersonal: [ 'vue-apollo', 'vue-meteor', 'vue-virtual-scroller', 'v-tooltip' ], links: [ 'http://patreon.com/akryum' ] }, { name: 'Edd Yerburgh', title: 'Testatron Alpha 9000', city: 'London, UK', languages: ['en'], github: 'eddyerburgh', twitter: 'EddYerburgh', work: { role: 'Full Stack Developer' }, reposOfficial: [ 'vue-test-utils' ], reposPersonal: [ 'avoriaz' ], links: [ 'https://www.eddyerburgh.me' ] }, { name: 'Sarah Drasner', city: 'Denver, CO, USA', languages: ['en'], work: { role: 'Head of Developer Experience', org: 'Netlify', orgUrl: 'https://www.netlify.com/' }, github: 'sdras', twitter: 'sarah_edo', codepen: 'sdras', reposOfficial: [ 'vuejs.org' ], reposPersonal: [ 'intro-to-vue', 'vue-vscode-snippets', 'vue-vscode-extensionpack', 'sample-vue-shop' ], links: [ 'https://sarah.dev/' ] }, { name: 'Damian Dulisz', title: 'Dark Mage of Plugins, News, and Confs', city: 'Wrocław, Poland', languages: ['pl', 'en'], github: 'shentao', twitter: 'DamianDulisz', work: { role: 'Consultant' }, reposOfficial: [ 'news.vuejs.org' ], reposPersonal: [ 'shentao/vue-multiselect', 'shentao/vue-global-events' ] }, { name: 'Michał Sajnóg', city: 'Poznań, Poland', languages: ['pl', 'en'], github: 'michalsnik', twitter: 'michalsnik', work: { role: 'Senior Frontend Developer / Team Leader', org: 'Netguru', orgUrl: 'https://netguru.co/' }, reposOfficial: [ 'eslint-plugin-vue', 'vue-devtools' ], reposPersonal: [ 'vue-computed-helpers', 'vue-content-placeholders' ] }, { name: 'GU Yiling', city: 'Shanghai, China', languages: ['zh', 'en'], work: { role: 'Senior web developer', org: 'Baidu, inc.', orgUrl: 'https://www.baidu.com/' }, github: 'Justineo', twitter: '_justineo', reposOfficial: [ 'vue', 'cn.vuejs.org' ], reposPersonal: [ 'Justineo/vue-awesome', 'ecomfe/vue-echarts', 'ecomfe/veui' ] }, { name: 'ULIVZ', city: 'Hangzhou, China', languages: ['zh', 'en'], work: { role: 'Senior Frontend Developer', org: 'AntFinancial', orgUrl: 'https://www.antfin.com' }, github: 'ulivz', twitter: '_ulivz', reposOfficial: [ 'vuepress' ] }, { name: 'Darek Gusto Wędrychowski', title: 'Google Search Virtuoso', city: 'Kraków, Poland', languages: ['pl', 'en'], github: 'gustojs', twitter: 'gustojs' }, { name: 'Phan An', title: 'Backend Designer & Process Poet', city: 'Munich, Germany', languages: ['vi', 'en'], github: 'phanan', twitter: 'notphanan', work: { role: 'Engineering Team Lead', org: 'InterNations', orgUrl: 'https://www.internations.org/' }, reposOfficial: [ 'vuejs.org' ], reposPersonal: [ 'vuequery', 'vue-google-signin-button' ], links: [ 'https://vi.vuejs.org', 'https://phanan.net/' ] }, { name: 'Natalia Tepluhina', title: 'Fox Tech Guru', city: 'Kyiv, Ukraine', languages: ['uk', 'ru', 'en'], reposOfficial: [ 'vuejs.org', 'vue-cli' ], work: { role: 'Senior Frontend Engineer', org: 'GitLab', orgUrl: 'https://gitlab.com/' }, github: 'NataliaTepluhina', twitter: 'N_Tepluhina', } ])) var emeriti = shuffle([ { name: 'Blake Newman', title: 'Performance Specializer & Code Deleter', city: 'London, UK', languages: ['en'], work: { role: 'Software Engineer', org: 'Attest', orgUrl: 'https://www.askattest.com/' }, github: 'blake-newman', twitter: 'blakenewman' }, { name: 'kingwl', title: 'New Bee', city: 'Beijing, China', languages: ['zh'], work: { role: 'Software Development Engineer', org: 'Chaitin', orgUrl: 'https://chaitin.cn/' }, github: 'kingwl', reposOfficial: [ 'vue' ] }, { name: 'Alan Song', title: 'Regent of Routing', city: 'Hangzhou, China', languages: ['zh', 'en'], work: { role: 'Cofounder', org: 'Futurenda', orgUrl: 'https://www.futurenda.com/' }, github: 'fnlctrl', reposOfficial: [ 'vue-router' ] }, { name: 'defcc', title: 'Details Deity & Bug Surgeon', city: 'Chongqing, China', languages: ['zh', 'en'], github: 'defcc', work: { org: 'zbj.com', orgUrl: 'http://www.zbj.com/' } }, { name: 'gebilaoxiong', title: 'Issue Annihilator', city: 'Chongqing, China', languages: ['zh', 'en'], github: 'gebilaoxiong', work: { org: 'zbj.com', orgUrl: 'http://www.zbj.com/' } }, { name: 'Denis Karabaza', title: 'Director of Directives (Emoji-Human Hybrid)', city: 'Dubna, Russia', languages: ['ru', 'en'], github: 'simplesmiler', twitter: 'simplesmiler', work: { role: 'Software Engineer', org: 'Neolant', orgUrl: 'http://neolant.ru/' } }, ]) var partners = [ { name: 'Pratik Patel', title: 'Organizer of VueConf US', city: 'Atlanta, GA, USA', languages: ['en'], work: { role: 'Organizer', org: 'VueConf US' }, twitter: 'prpatel', links: [ 'https://us.vuejs.org/' ] }, { name: 'Vincent Mayers', title: 'Organizer of VueConf US', city: 'Atlanta, GA, USA', languages: ['en'], work: { role: 'Organizer', org: 'VueConf US' }, twitter: 'vincentmayers', links: [ 'https://us.vuejs.org/' ] }, { name: 'Luke Thomas', title: 'Creator of Vue.js Amsterdam', city: 'Amsterdam, Netherlands', languages: ['nl', 'en', 'de'], work: { role: 'Creator', org: 'Vue.js Amsterdam' }, twitter: 'lukevscostas', linkedin: 'luke-kenneth-thomas-578b3916a', links: [ 'https://vuejs.amsterdam' ] }, { name: 'Jos Gerards', title: 'Organizer and Host of Vue.js Amsterdam & Frontend Love', city: 'Amsterdam, Netherlands', languages: ['nl', 'en', 'de'], work: { role: 'Event Manager', org: 'Vue.js Amsterdam' }, twitter: 'josgerards88', linkedin: 'josgerards', links: [ 'https://vuejs.amsterdam' ] }, { name: 'James McGlasson', title: 'Head of Marketing Communications', city: 'Amsterdam, Netherlands', languages: ['en', 'nl', 'de'], work: { role: 'Head Of Marketing Communications', org: 'Vue.js Amsterdam' }, twitter: 'jamesvuejs', linkedin: 'jdog', links: [ 'https://vuejs.amsterdam' ] }, { name: 'Jen Looper', title: 'Queen Fox', city: 'Boston, MA, USA', languages: ['en', 'fr'], work: { role: 'CEO', org: 'Vue Vixens' }, github: 'jlooper', twitter: 'jenlooper', links: [ 'https://vuevixens.org/', 'https://nativescript-vue.org/' ] }, { name: 'Alex Jover', title: 'Vue Components Squeezer', city: 'Alicante, Spain', languages: ['es', 'en'], work: { role: 'Web, PWA and Performance Consultant', org: 'Freelance' }, github: 'alexjoverm', twitter: 'alexjoverm', reposPersonal: [ 'v-runtime-template', 'v-lazy-image', 'vue-testing-series' ], links: [ 'https://alexjover.com' ] }, { name: 'Sebastien Chopin', title: '#1 Nuxt Brother', city: 'Bordeaux, France', languages: ['fr', 'en'], github: 'Atinux', twitter: 'Atinux', work: { org: 'NuxtJS', orgUrl: 'https://nuxtjs.org' }, reposPersonal: [ 'nuxt/*', 'nuxt-community/*', 'nuxt/vue-meta' ] }, { name: 'Alexandre Chopin', title: '#1 Nuxt Brother', city: 'Bordeaux, France', languages: ['fr', 'en'], github: 'alexchopin', twitter: 'iamnuxt', work: { org: 'NuxtJS', orgUrl: 'https://nuxtjs.org' }, reposPersonal: [ 'nuxt/*', 'nuxt-community/*', 'vue-flexboxgrid' ] }, { name: 'Khary Sharpe', title: 'Viral Newscaster', city: 'Kingston, Jamaica', languages: ['en'], github: 'kharysharpe', twitter: 'kharysharpe', links: [ 'https://twitter.com/VueJsNews', 'http://www.kharysharpe.com/' ] }, { name: 'Pooya Parsa', title: 'Nuxtification Modularizer', city: 'Tehran, Iran', languages: ['fa', 'en'], github: 'pi0', twitter: '_pi0_', work: { role: 'Technical Advisor', org: 'Fandogh (AUT University)', orgUrl: 'https://fandogh.org' }, reposPersonal: [ 'nuxt/*', 'nuxt-community/*', 'bootstrap-vue/*' ] }, { name: 'Xin Du', title: 'Nuxpert', city: 'Dublin, Ireland', languages: ['zh', 'en'], github: 'clarkdo', twitter: 'ClarkDu_', reposPersonal: [ 'nuxt/*', 'nuxt-community/*' ] }, { name: 'Yi Yang', city: 'Shanghai, China', title: 'Interface Elementologist', languages: ['zh', 'en'], github: 'Leopoldthecoder', work: { org: 'ele.me', orgUrl: 'https://www.ele.me', }, reposPersonal: [ 'elemefe/element', 'elemefe/mint-ui' ] }, { name: 'Bruno Lesieur', title: 'French Community Director', city: 'Annecy, France', languages: ['fr', 'en'], github: 'Haeresis', twitter: 'ZetesEthique', work: { role: 'Cofounder', org: 'Orchard ID', orgUrl: 'https://www.orchard-id.com/' }, reposPersonal: [ 'vuejs-fr/*', 'Haeresis/node-atlas-hello-vue' ], links: [ 'https://node-atlas.js.org/', 'https://blog.lesieur.name/' ] }, { name: 'ChangJoo Park', title: 'Vuenthusiastic Korean Community Organizer', city: 'Seoul, South Korea', languages: ['ko', 'en'], github: 'changjoo-park', twitter: 'pcjpcj2', reposPersonal: [ 'vuejs-kr/kr.vuejs.org', 'ChangJoo-Park/vue-component-generator' ], links: [ 'https://vuejs-kr.github.io', 'https://twitter.com/pcjpcj2' ] }, { name: 'Erick Petrucelli', title: 'Perfectionist Chief Translator for Portuguese', city: 'Taquaritinga, Brazil', languages: ['pt', 'en'], github: 'ErickPetru', twitter: 'erickpetru', work: { role: 'Teacher', org: 'Fatec Taquaritinga', orgUrl: 'http://www.fatectq.edu.br/' }, reposPersonal: [ 'vuejs-br/br.vuejs.org', 'ErickPetru/vue-feathers-chat' ] }, { name: 'Razvan Stoenescu', title: 'Deep Space Quasar Creator', city: 'Bucharest, Romania', languages: ['ro', 'en'], github: 'rstoenescu', twitter: 'quasarframework', work: { role: 'Developer', org: 'Quasar Framework', orgUrl: 'http://quasar-framework.org/' }, reposPersonal: [ 'quasarframework/quasar', 'quasarframework/quasar-cli', 'quasarframework/quasar-play' ] }, { name: 'Jilson Thomas', title: 'Vue Promoter and VueJobs Guy', city: 'Toronto, Canada', languages: ['en'], github: 'JillzTom', twitter: 'jilsonthomas', work: { role: 'Senior Frontend Developer', org: 'Nominator', orgUrl: 'https://nominator.com/' }, links: [ 'https://vuejobs.com' ] }, { name: 'Israel Ortuño', title: 'VueJobs Buccaneer', city: 'Alicante, Spain', languages: ['es', 'en'], github: 'IsraelOrtuno', twitter: 'IsraelOrtuno', work: { role: 'Full Stack Web Developer', org: 'Freelance' }, links: [ 'https://vuejobs.com' ] }, { name: 'John Leider', title: 'Vuetiful Framework Sculptor', city: 'Fort Worth, TX, USA', languages: ['en'], github: 'vuetifyjs', twitter: 'vuetifyjs', work: { role: 'CEO', org: 'Vuetify LLC', orgUrl: 'https://vuetifyjs.com' }, reposPersonal: [ 'vuetifyjs/vuetify' ] }, { name: 'Grigoriy Beziuk', title: 'Translation Gang Leader', city: 'Moscow, Russia', languages: ['ru', 'de', 'en'], github: 'gbezyuk', work: { role: 'Full Stack Web Developer', org: 'Self Employed', orgUrl: 'http://gbezyuk.ru' }, reposPersonal: [ 'translation-gang/ru.vuejs.org' ] }, { name: 'Alexander Sokolov', title: 'Russian Translation Sharp Eye', city: 'Krasnodar, Russia', languages: ['ru', 'en'], github: 'Alex-Sokolov', reposPersonal: [ 'translation-gang/ru.vuejs.org' ] }, { name: 'Anthony Gore', title: '', city: 'Sydney, Australia', languages: ['en'], github: 'anthonygore', twitter: 'anthonygore', work: { role: 'Author', org: 'Vue.js Developers', orgUrl: 'https://vuejsdevelopers.com/' }, links: [ 'https://vuejsdevelopers.com' ] }, { name: 'Ben Hong', title: '', city: 'Washington, DC, USA', languages: ['en', 'zh'], work: { role: 'Senior Frontend Engineer', org: 'GitLab (Meltano)', }, reposOfficial: [ 'vuejs/events' ], github: 'bencodezen', twitter: 'bencodezen', links: [ 'https://bencodezen.io/' ] }, { name: 'EGOIST', title: 'Build Tool Simplificator', city: 'Chengdu, China', languages: ['zh', 'en'], github: 'egoist', twitter: '_egoistlily', reposPersonal: [ 'poi', 'ream', 'vue-play' ] }, { name: 'Alex Kyriakidis', title: 'Vueducator Extraordinaire', city: 'Thessaloniki, Greece', languages: ['el', 'en'], github: 'hootlex', twitter: 'hootlex', work: { role: 'Consultant / Author' }, reposPersonal: [ 'vuejs-paginator', 'vuedo/vuedo', 'the-majesty-of-vuejs-2' ], links: [ 'https://vuejsfeed.com/', 'https://vueschool.io/' ] }, { name: 'Rolf Haug', title: 'Educator & Consultant', city: 'Oslo, Norway', languages: ['en', 'no'], github: 'rahaug', twitter: 'rahaug', work: { role: 'Educator & Co-founder', org: 'Vue School', orgUrl: 'https://vueschool.io/' }, links: [ 'https://vueschool.io/', 'https://rah.no' ] }, { name: 'Andrew Tomaka', title: 'The Server Server', city: 'East Lansing, MI, USA', languages: ['en'], github: 'atomaka', twitter: 'atomaka', reposOfficial: [ 'vuejs/*' ], work: { org: 'Michigan State University', orgUrl: 'https://msu.edu/' }, links: [ 'https://atomaka.com/' ] }, { name: 'Blake Newman', title: 'Performance Specializer & Code Deleter', city: 'London, UK', languages: ['en'], work: { role: 'Software Engineer', org: 'Attest', orgUrl: 'https://www.askattest.com/' }, github: 'blake-newman', twitter: 'blakenewman', links: [ 'https://vuejs.london' ] }, { name: 'Filip Rakowski', title: 'eCommerce & PWA mastah', city: 'Wrocław, Poland', languages: ['pl', 'en'], github: 'filrak', twitter: 'filrakowski', work: { role: 'Co-founder of Vue Storefront', org: 'Divante', orgUrl: 'https://divante.co/' }, reposPersonal: [ 'DivanteLtd/vue-storefront', 'DivanteLtd/storefront-ui' ], links: [ 'https://vuestorefront.io', 'https://storefrontui.io' ] }, { name: 'Gregg Pollack', title: '', city: 'Orlando, FL, USA', languages: ['en'], github: 'gregg', twitter: 'greggpollack', work: { role: 'Vue Instructor', org: 'Vue Mastery', orgUrl: 'https://www.vuemastery.com/' }, links: [ 'https://www.vuemastery.com', 'https://news.vuejs.org/' ] }, { name: 'Adam Jahr', title: '', city: 'Orlando, FL, USA', languages: ['en'], github: 'atomjar', twitter: 'adamjahr', work: { role: 'Vue Instructor', org: 'Vue Mastery', orgUrl: 'https://www.vuemastery.com/' }, links: [ 'https://www.vuemastery.com', 'https://news.vuejs.org/' ] } ] Vue.component('vuer-profile', { template: '#vuer-profile-template', props: { profile: Object, titleVisible: Boolean }, computed: { workHtml: function () { var work = this.profile.work var html = '' if (work.orgUrl) { html += '' if (work.org) { html += work.org } else { this.minimizeLink(work.orgUrl) } html += '' } else if (work.org) { html += work.org } if (work.role) { if (html.length > 0) { html = work.role + ' @ ' + html } else { html = work.role } } return html }, textDistance: function () { var distanceInKm = this.profile.distanceInKm || 0 if (this.$root.useMiles) { return roundDistance(kmToMi(distanceInKm)) + ' miles' } else { return roundDistance(distanceInKm) + ' km' } }, languageListHtml: function () { var vm = this var nav = window.navigator if (!vm.profile.languages) return '' var preferredLanguageCode = nav.languages // The preferred language set in the browser ? nav.languages[0] : ( // The system language in IE nav.userLanguage || // The language in the current page nav.language ) return ( '' + vm.profile.languages.map(function (languageCode, index) { var language = languageNameFor[languageCode] if ( languageCode !== 'en' && preferredLanguageCode && languageCode === preferredLanguageCode.slice(0, 2) ) { return ( '' + language + '' ) } return language }).join('') + '' ) }, hasSocialLinks: function () { return this.profile.github || this.profile.twitter || this.profile.codepen || this.profile.linkedin } }, methods: { minimizeLink: function (link) { return link .replace(/^https?:\\/\\/(www\\.)?/, '') .replace(/\\/$/, '') .replace(/^mailto:/, '') }, /** * Generate a GitHub URL using a repo and a handle. */ githubUrl: function (handle, repo) { if (repo && repo.url) { return repo.url } if (repo && repo.indexOf('/') !== -1) { // If the repo name has a slash, it must be an organization repo. // In such a case, we discard the (personal) handle. return ( 'https://github.com/' + repo.replace(/\\/\\*$/, '') ) } return 'https://github.com/' + handle + '/' + (repo || '') } } }) new Vue({ el: '#team-members', data: { team: team, teamEmeriti: emeriti, partners: shuffle(partners), geolocationSupported: false, isSorting: false, errorGettingLocation: false, userPosition: null, useMiles: false, konami: { position: 0, code: [38, 38, 40, 40, 37, 39, 37, 39, 66, 65] } }, computed: { sortedTeam: function () { return this.sortVuersByDistance(this.team) }, sortedPartners: function () { return this.sortVuersByDistance(this.partners) }, titleVisible: function () { return this.konami.code.length === this.konami.position } }, created: function () { var nav = window.navigator if ('geolocation' in nav) { this.geolocationSupported = true var imperialLanguageCodes = [ 'en-US', 'en-MY', 'en-MM', 'en-BU', 'en-LR', 'my', 'bu' ] if (imperialLanguageCodes.indexOf(nav.language) !== -1) { this.useMiles = true } } document.addEventListener('keydown', this.konamiKeydown) }, beforeDestroy: function () { document.removeEventListener('keydown', this.konamiKeydown) }, methods: { getUserPosition: function () { var vm = this var nav = window.navigator vm.isSorting = true nav.geolocation.getCurrentPosition( function (position) { vm.userPosition = position vm.isSorting = false }, function (error) { vm.isSorting = false vm.errorGettingLocation = true }, { enableHighAccuracy: true } ) }, sortVuersByDistance: function (vuers) { var vm = this if (!vm.userPosition) return vuers var vuersWithDistances = vuers.map(function (vuer) { var cityCoords = cityCoordsFor[vuer.city] if (cityCoords) { return Object.assign({}, vuer, { distanceInKm: getDistanceFromLatLonInKm( vm.userPosition.coords.latitude, vm.userPosition.coords.longitude, cityCoords[0], cityCoords[1] ) }) } return Object.assign({}, vuer, { distanceInKm: null }) }) vuersWithDistances.sort(function (a, b) { if (a.distanceInKm && b.distanceInKm) return a.distanceInKm - b.distanceInKm if (a.distanceInKm && !b.distanceInKm) return -1 if (!a.distanceInKm && b.distanceInKm) return 1 if (a.name < b.name) return -1 if (a.name > b.name) return 1 }) return vuersWithDistances }, konamiKeydown: function (event) { if (this.titleVisible) { return } if (event.keyCode !== this.konami.code[this.konami.position++]) { this.konami.position = 0 } } } }) /** * Shuffles array in place. * @param {Array} a items The array containing the items. */ function shuffle (a) { a = a.concat([]) if (window.location.hostname === 'localhost') { return a } var j, x, i for (i = a.length; i; i--) { j = Math.floor(Math.random() * i) x = a[i - 1] a[i - 1] = a[j] a[j] = x } return a } /** * Calculates great-circle distances between the two points – that is, the shortest distance over the earth’s surface – using the Haversine formula. * @param {Number} lat1 The latitude of the 1st location. * @param {Number} lon1 The longitute of the 1st location. * @param {Number} lat2 The latitude of the 2nd location. * @param {Number} lon2 The longitute of the 2nd location. */ function getDistanceFromLatLonInKm(lat1,lon1,lat2,lon2) { var R = 6371 // Radius of the earth in km var dLat = deg2rad(lat2-lat1) // deg2rad below var dLon = deg2rad(lon2-lon1) var a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLon/2) * Math.sin(dLon/2) var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)) var d = R * c // Distance in km return d } function deg2rad(deg) { return deg * (Math.PI/180) } function kmToMi (km) { return km * 0.62137 } function roundDistance (num) { return Number(Math.ceil(num).toPrecision(2)) } })()","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"Vue.js 커뮤니티에 참여하세요!","date":"2019-08-03T10:04:47.000Z","path":"wiki/vue/join/","text":"Vue의 커뮤니티는 엄청나게 빠르게 성장하고 있습니다. 이 글을 읽는다면 가입 할 준비가 된 것입니다. 정말로 환영합니다! 이제 커뮤니티가 여러분에게 할 수 있는 일과 여러분이 커뮤니티에 할 수 있는 일 모두 다룰 것 입니다. 즐길 수 있는 리소스들행동강령Our Code of Conduct is a guide to make it easier to enrich all of us and the technical communities in which we participate. 지원 받기 Forum: Vue와 생태계에한관한 질문하고 답변을 얻는 가장 좋은 곳 입니다. Chat: 개발자들과 대화할 수 있는 장소입니다. Meetups: Want to find local Vue.js enthusiasts like yourself? Interested in becoming a community leader? We have the help and support you need right here! Github: 보고 할 버그가 있거나 요청할 기능이 있다면 GitHub 이슈가 필요합니다. 또한 풀 리퀘스트 요청을 환영합니다! 생태계 둘러보기 The Awesome Vue Page: 다른 사람들이 멋진 리소스를 공유했는지 확인하십시오. The “Show and Tell” Subforum: 다른 사람들이 빌드 한 것과 Vue 생태계가 성장하고 있는지 확인하기 위한 또 다른 좋은 장소입니다. 할 수 있는 일들코드 컨트리뷰션어떤 프로젝트와 마찬가지로 기여할 수있는 규칙이 있습니다. 최대한 빨리 당신을 도울 수 있도록 또는 풀리퀘스트를 가능한 빨리 수락 할 수 있도록 컨트리뷰션 가이드 꼭 읽어보세요. 그 다음에는 Vue의 핵심 저장소에 기꺼이 기여할 준비가됩니다. vue: 코어 라이브러리 vuex: Flux에서 영감을 받은 상태 관리 vue-router: SPA를 위한 라우팅 시스템 …뿐만 아니라 많은 작은 공식적인 동반하는 라이브러리들이 있습니다. 당신의 경험을 공유 (그리고 빌드) 하세요포럼 및 채팅을 이용해 질문에 답변하고 리소스를 공유하는 것 외에도 알고있는 것을 공유하고 확장 할 수있는 몇 가지 다른 분명한 방법이 있습니다. 교육을 위한 자료를 만들어 주세요 종종 배우는 가장 좋은 방법은 가르치는 것입니다. Vue에서 흥미로운 점이 있다면 블로그 게시물을 작성하거나 워크샵을 주최하거나 소셜 미디어에서 공유하는 요지를 게시하여 전문성을 강화하십시오. 관심 있는 저장소를 지켜보세요 그러면 해당 저장소에 활동이 있을 때마다 알림이 전송되어 진행중인 토론 및 향후 기능에 대한 내부 지식을 얻을 수 있습니다. 전문 지식을 구축하는 환상적인 방법으로 궁극적으로 문제를 해결하고 요청을 처리 할 수 있습니다. 문서 번역Vue는 이미 전 세계로 퍼져 나갔고 코어 팀조차 적어도 6개 이상의 시간대에 퍼져 있습니다. 포럼에는 7 개 언어가 포함되어 있으며 많은 문서가 적극적으로 번역을 유지하고 있습니다. 우리는 Vue의 국제적인 범위에 대해 매우 자랑스러워 하고 있고 또한 더 성장할 수 있습니다. 지금 당장 당신이 선호하는 언어로 이 문장을 읽고 싶은 경우 우리를 도와 주시겠습니까? 그렇다면 이 문서 또는 기타 공식적으로 유지 관리되는 문서에 대한 저장소를 포크하여 자유롭게 번역을 시작하십시오. 진행 상황을 확인한 후 문제를 열거 나 주 저장소에서 요청을 가져 오면 더 많은 기부자에게 도움을 요청할 것입니다. Become a Community LeaderThere’s a lot you can do to help Vue grow in your community: Present at your local meetup. Whether it’s giving a talk or running a workshop, you can bring a lot of value to your community by helping both new and experienced Vue developers continue to grow. Start your own meetup. If there’s not already a Vue meetup in your area, you can start your own! Use the resources at events.vuejs.org to help you succeed! Help meetup organizers. There can never be too much help when it comes to running an event, so offer a hand to help out local organizers to help make every event a success. If you have any questions on how you can get more involved with your local Vue community, reach out at @Vuejs_Events!","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"Vuex 0.6.x에서 1.0로 마이그레이션","date":"2019-07-03T10:04:47.000Z","path":"wiki/vue/migration-vuex/","text":"Vuex 2.0이 출시되었지만이 가이드에서는 1.0으로의 마이그레이션만 다룹니다. 오타 아닌가요? 또한 Vuex 1.0과 2.0이 동시에 출시 된 것처럼 보입니다. 어떻게 된거죠? Vue 2.0과 호환되는 것은 무엇입니까? Vuex 1.0 및 2.0: Vue 1.0 and 2.0 둘다 완전히 지원합니다. 가까운 미래까지는 유지 됩니다. 하지만 이들은 약간 다른 타겟 사용자를 가지고 있습니다. Vuex 2.0은 새로운 프로젝트를 시작하거나 클라이언트측 상태 관리의 최신에 있기를 원하는 사람들을 위해 API의 근본적인 재 설계 및 단순화를 하였습니다. 이 마이그레이션 가이드에서는 다루지 않습니다 자세한 내용은 Vuex 2.0 문서를 참조하십시오. Vuex 1.0 은 대부분 하위 버전과 호환되므로 업그레이드하는 데 필요한 변경 사항은 거의 없습니다. 기존 코드베이스가 큰 사람들이나 Vue 2.0으로의 가장 매끄러운 업그레이드 경로를 원하는 사람들에게 권장됩니다. 이 가이드는 해당 프로세스를 용이하게하기 위해 작성된 것이지만 마이그레이션 참고 사항만 포함합니다. 전체 사용법 안내는 Vuex 1.0 문서를 참조하십시오. store.watch 와 문자열 속성 패스 교체됨store.watch 는 이제 함수만 허용됩니다. 예를 들어 아래 처럼 바꾸어야 합니다. 1store.watch('user.notifications', callback) 아래처럼 사용하세요 12345678store.watch( // 변경이 완료되었습니다... function (state) &#123; return state.user.notifications &#125;, // 아래 콜백을 실행하세요 callback) 이렇게 하면 반응성 속성을 보다 완벽하게 제어 할 수 있습니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 문자열로 store.watch가 첫번째 전달인자로 사용되는 예를 찾아보십시오. Store의 Event Emitter 제거store 인스턴스는 더이상 event emitter 인터페이스 (on, off, emit)를 노출하지 않습니다. 이전에 store를 전역 이벤트 버스로 사용했다면 마이그레이션 지침 이 섹션을 보세요을 참조하십시오. 이 인터페이스를 사용하여 store 자체에서 emit 된 이벤트(예 store.on(&#39;mutation&#39;, callback))를 보지않고 store.subscribe라는 새로운 메소드가 도입되었습니다. 플러그인 내부의 일반적인 사용법은 다음과 같습니다. 12345var myPlugin = store =&gt; &#123; store.subscribe(function (mutation, state) &#123; // 무언가 하세요... &#125;)&#125; the plugins docs에서 더 자세한 내용을 보세요. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 store.on, store.off 및 store.emit의 예를 찾아보십시오. 미들웨어 변경미들웨어는 플러그인에 의해 변경되었습니다. 플러그인은 store를 유일한 전달인자로 받는 함수이며 store에서 mutation 이벤트를 받을 수 있습니다. 12345const myPlugins = store =&gt; &#123; store.subscribe('mutation', (mutation, state) =&gt; &#123; // 무언가 하세요... &#125;)&#125; the plugins docs에서 더 자세한 내용을 보세요. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 상점에서 middlewares 옵션의 예를 찾으십시오.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"Vue Router 0.7.x으로 부터 마이그레이션","date":"2019-07-02T10:04:47.000Z","path":"wiki/vue/migration-vue-router/","text":"Vue 2는 Vue 2와 호환되므로 Vue를 업데이트하는 경우 Vue Router도 함께 업데이트해야합니다. 이것이 주요 문서에서 마이그레이션 경로에 대한 세부 정보를 포함시킨 이유입니다. 새 Vue Router 사용에 대한 전체 안내서는 Vue Router 문서를 참조하십시오. 라우터 초기화router.start 변경Vue Router로 앱을 초기화하는 특별한 API는 더 이상 존재하지 않습니다. 그 대신에 다음을 의미합니다: 123router.start(&#123; template: '&lt;router-view&gt;&lt;/router-view&gt;'&#125;, '#app') Vue 인스턴스에 라우터 속성 만 전달하면됩니다. 12345new Vue(&#123; el: '#app', router: router, template: '&lt;router-view&gt;&lt;/router-view&gt;'&#125;) 또는 Vue의 런타임 전용 빌드를 사용하는 경우 12345new Vue(&#123; el: '#app', router: router, render: h =&gt; h('router-view')&#125;) 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 호출되는 router.start의 예를 찾으십시오. 라우터 정의router.map 변경이제 라우트는 라우터 인스턴스화시 routes 옵션에 배열로 정의됩니다. 따라서 예를 들어 이러한 라우트는 다음과 같습니다. 12345678router.map(&#123; '/foo': &#123; component: Foo &#125;, '/bar': &#123; component: Bar &#125;&#125;) 대신 다음과 같이 정의됩니다. 123456var router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125; ]&#125;) 객체를 반복 할 때 브라우저간에 같은 키 순서를 사용하는 것이 보장되지 않기 때문에 배열 구문을 사용하면보다 예측 가능한 경로 일치가 가능합니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 router.map가 호출되는 의 예를 찾으십시오. router.on 제거됨앱을 시작할 때 프로그래밍으로 경로를 생성해야하는 경우 라우터 정의를 동적으로 경로 배열에 푸시함으로써 수행 할 수 있습니다. 예 : 123456789101112131415161718192021// 기본 라우트var routes = [ // ...]// 동적으로 생성한 라우트marketingPages.forEach(function (page) &#123; routes.push(&#123; path: '/marketing/' + page.slug component: &#123; extends: MarketingComponent data: function () &#123; return &#123; page: page &#125; &#125; &#125; &#125;)&#125;)var router = new Router(&#123; routes: routes&#125;) 라우터가 인스턴스화 된 후에 새 경로를 추가해야하는 경우 추가하려는 경로가 포함 된 새 라우터로 라우터의 일치자(matcher)를 바꿀 수 있습니다. 123456router.match = createMatcher( [&#123; path: '/my/new/path', component: MyComponent &#125;].concat(router.options.routes)) 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 router.on가 호출되는지 확인하십시오. router.beforeEach changedrouter.beforeEach는 이제 비동기적으로 작동하며 세번째 전달인자로 next 함수를 받습니다. 1234567router.beforeEach(function (transition) &#123; if (transition.to.path === '/forbidden') &#123; transition.abort() &#125; else &#123; transition.next() &#125;&#125;) 1234567router.beforeEach(function (to, from, next) &#123; if (to.path === '/forbidden') &#123; next(false) &#125; else &#123; next() &#125;&#125;) subRoutes 이름 변경Vue 및 다른 라우팅 라이브러리와의 일관성을 위해 자식으로 이름이 변경 되었습니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 subRoutes 옵션의 예를 찾으십시오. router.redirect 변경경로 정의에 대한 옵션입니다. 예를 들어 다음과 같이 업데이트 할 것입니다. 123router.redirect(&#123; '/tos': '/terms-of-service'&#125;) routes 설정에서 아래와 같은 정의로 바꿉니다: 1234&#123; path: '/tos', redirect: '/terms-of-service'&#125; 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 router.redirect가 호출되는지 확인하십시오. router.alias 변경별칭을 지정하려는 경로 정의 옵션입니다. 예를 들어 다음과 같이 업데이트 할 것입니다. 123router.alias(&#123; '/manage': '/admin'&#125;) routes 설정에서 아래와 같은 정의로 바꿉니다: 12345&#123; path: '/admin', component: AdminPanel, alias: '/manage'&#125; 여러 개의 별칭이 필요한 경우 배열 구문을 사용할 수도 있습니다. 1alias: ['/manage', '/administer', '/administrate'] 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 router.alias가 호출되는지 확인하십시오. 임의 라우트 속성 변경미래의 기능과의 충돌을 피하기 위해 임의의 라우트 속성이 새 메타 속성 아래에서 범위가 지정되어야합니다. 예를 들어, 다음과 같이 정의했다면 : 1234'/admin': &#123; component: AdminPanel, requiresAuth: true&#125; 이제 다음과 같이 업데이트 할 것입니다. 1234567&#123; path: '/admin', component: AdminPanel, meta: &#123; requiresAuth: true &#125;&#125; 그런 다음 경로에서 이 속성에 나중에 액세스하면 mata 예제를 계속 진행합니다. 123if (route.meta.requiresAuth) &#123; // ...&#125; 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 메타에서 범위가 지정되지 않은 임의의 경로 속성의 예를 찾으십시오. 쿼리의 배열 구문 제거됨쿼리 전달인자로 배열을 전달할 때 QueryString 문법은 더 이상 /foo?users[]=Tom&amp;users[]=Jerry가 아닌 새로운 문법 /foo?users=Tom&amp;users=Jerry 입니다.내부적으로,$route.query.users는 여전히 배열이 되지만, 이 경로에 직접 접근 할 때 /foo?users=Tom 쿼리에 단 하나의 전달인자가 있다면, 라우터는 users가 배열임을 기대합니다.이 때문에 계산된 속성을 추가하여 $route.query.users의 모든 참조를 이 속성으로 대체하는 것을 고려해야합니다. 12345678910export default &#123; // ... computed: &#123; // users는 항상 배열입니다 users () &#123; const users = this.$route.query.users return Array.isArray(users) ? users : [users] &#125; &#125;&#125; 라우트 매칭라우트 매칭은 이제 path-to-regexp를 사용해 이전보다 훨씬 유연합니다. 하나 이상의 이름을 가지는 인자 변경구문이 약간 변경되었으므로, 예를 들어/category/*tags 는 /category/:tags+ 로 업데이트 되어야 합니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 더 이상 사용되지 않는 경로 구문의 예를 찾으십시오. 링크v-link 변경v-link 디렉티브는 새로운&lt;router-link&gt; 컴포넌트로 대체되었습니다.이 일은 이제 Vue 2의 컴포넌트의 책임입니다. 1&lt;a v-link=\"'/about'\"&gt;About&lt;/a&gt; 다음과 같이 업데이트해야합니다. 1&lt;router-link to=\"/about\"&gt;About&lt;/router-link&gt; target=&quot;_blank&quot; 는 &lt;router-link&gt; 에서 지원되지 않으므로 새 탭에서 링크를 열어야 할 경우 대신&lt;a&gt;를 사용해야합니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 v-link 디렉티브의 예를 찾으십시오. v-link-active 변경v-link-active 디렉티브는 &lt;router-link&gt; 컴포넌트의tag 속성으로 대체되었습니다. 예를 들어 다음과 같이 업데이트 할 것입니다. 123&lt;li v-link-active&gt; &lt;a v-link=\"'/about'\"&gt;About&lt;/a&gt;&lt;/li&gt; 이는 아래와 같이 변경 되었습니다. 123&lt;router-link tag=\"li\" to=\"/about\"&gt; &lt;a&gt;About&lt;/a&gt;&lt;/router-link&gt; &lt;a&gt;는 실제 링크가 될 것이고 올바른 href를 얻을 것이다. 그러나 활성 클래스는 바깥 쪽&lt;li&gt;에 적용될 것이다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 v-link-active 디렉티브의 예를 찾으십시오. 프로그래밍 방식의 네비게이션router.go 변경HTML5 History API와의 일관성을 위해 router.go는 뒤로 / 앞으로 탐색에만 사용되며 router.push는 특정 페이지로 이동하는 데 사용됩니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 router.go를 사용하고 있고 router.push가 대신 사용되야 하는 예를 찾으십시오. 라우터 옵션 : 모드hashbang: false 제거됨Hashbang은 더 이상 Google이 URL을 크롤링하는 데 필요하지 않으므로 더 이상 해시 전략의 기본 (또는 옵션)이 아닙니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 hashbang: false 옵션을 사용하는 예를 찾으십시오. history: true 변경모든 라우팅 모드 옵션은 단일 모드 옵션으로 압축되었습니다. 123var router = new VueRouter(&#123; history: 'true'&#125;) 위를 아래 코드로 변경합니다. 123var router = new VueRouter(&#123; mode: 'history'&#125;) 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 history: true 옵션이 사용되는 예를 찾으십시오. abstract: true 변경모든 라우팅 모드 옵션은 단일 mode 옵션으로 압축되었습니다. 123var router = new VueRouter(&#123; abstract: 'true'&#125;) 위를 아래 코드로 변경합니다. 123var router = new VueRouter(&#123; mode: 'abstract'&#125;) 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 abstract: true 옵션이 사용되는 예를 찾으십시오. Route 옵션: 기타saveScrollPosition 변경이것은 함수를 받아들이는 scrollBehavior 옵션으로 대체되었으므로 라우트마다 스크롤 동작을 완벽하게 사용자 정의 할 수 있습니다 . 이것은 많은 새로운 가능성을 열어 놓았지만 단순히 다음과 같은 예전의 행동을 그대로 재현할 수 있습니다. 1saveScrollPosition: true 위를 아래 코드로 변경합니다. 123scrollBehavior: function (to, from, savedPosition) &#123; return savedPosition || &#123; x: 0, y: 0 &#125;&#125; 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 saveScrollPosition: true 옵션이 사용되는 예를 찾으십시오. root 이름 변경HTML&lt;base&gt; 엘리먼트와의 일관성을 위해 base로 이름이 변경되었습니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 root 옵션이 사용되는 예를 찾으십시오. transitionOnLoad 제거됨Vue의 트랜지션 시스템에 명시적인 appear 트랜지션 제어가 추가되었으므로이 옵션은 더 이상 필요하지 않습니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 transitionOnLoad: true 옵션이 사용되는 예를 찾으십시오. suppressTransitionError 제거됨훅 단순화로 인해 제거되었습니다. 정말로 트랜지션 오류를 억제해야한다면 try…catch를 사용할 수 있습니다. 대신. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 suppressTransitionError: true 옵션이 사용되는 예를 찾으십시오. 라우트 훅activate 변경대신 컴포넌트에서 beforeRouteEnter를 사용하십시오. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 beforeRouteEnter 훅이 사용되는 예를 찾으십시오. canActivate 변경라우터에서 beforeEnter을 대신 사용하십시오. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 canActivate 훅이 사용되는 예를 찾으십시오. deactivate 제거됨컴포넌트의 beforeDestroy 또는 destroyed 훅을 대신 사용하십시오. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 deactivate 훅이 사용되는 예를 찾으십시오. canDeactivate 대체됨컴포넌트의 beforeRouteLeave을 대신 사용하십시오. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 canDeactivate 훅이 사용되는 예를 찾으십시오. canReuse: false 제거됨새로운 Vue Router에는 더 이상 유스 케이스가 없습니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 canReuse: false 옵션이 사용되는 예를 찾으십시오. data 변경이제 $route 속성은 반응적입니다. 따라서 감시자를 사용하여 다음과 같이 경로 변경에 반응할 수 있습니다 : 12345678watch: &#123; '$route': 'fetchData'&#125;,methods: &#123; fetchData: function () &#123; // ... &#125;&#125; 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 data 훅이 사용되는 예를 찾으십시오. $loadingRouteData 제거됨자신의 속성 (예 : isLoading)을 정의한 다음 경로의 감시자에서 로드 상태를 업데이트합니다. 예를 들어, axios로 데이터를 가져 오는 경우 : 12345678910111213141516171819202122232425262728data: function () &#123; return &#123; posts: [], isLoading: false, fetchError: null &#125;&#125;,watch: &#123; '$route': function () &#123; var self = this self.isLoading = true self.fetchData().then(function () &#123; self.isLoading = false &#125;) &#125;&#125;,methods: &#123; fetchData: function () &#123; var self = this return axios.get('/api/posts') .then(function (response) &#123; self.posts = response.data.posts &#125;) .catch(function (error) &#123; self.fetchError = error &#125;) &#125;&#125; 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 $loadingRouteData 메타 속성이 사용되는 예를 찾으십시오.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"Vue 1.x에서 마이그레이션","date":"2019-07-01T10:04:47.000Z","path":"wiki/vue/migration/","text":"FAQ 우와… - 이 페이지는 매우 깁니다! 그 말은 2.0이 완전히 다르다는 것을 의미합니까? 기초를 다시 배워야 할 것이며, 마이그레이션은 실제로 불가능한 것입니까? 질문해 주어서 기쁩니다. 대답은 ‘아니오’ 입니다. API의 약 90%가 동일하고 핵심 개념이 변경되지 않았습니다. 매우 자세한 설명을 제공하고 많은 예제를 포함하기 때문에 문서의 길이가 깁니다. 안심하십시오. 이 것은 위에서 아래로 읽어야하는 것이 아닙니다! 마이그레이션을 하려면 어디서부터 시작해야 하나요? 현재 프로젝트에서 마이그레이션 도우미를 실행하여 시작하십시오. 우리는 조심스럽게 크기를 줄이고 시니어 Vue 개발자가 간단한 커맨드라인 인터페이스로 압축했습니다. 쓸모없는 기능을 인식 할 때마다 알려주고 제안을 제공하며 자세한 정보에 대한 링크를 제공합니다. 그런 다음 사이드 바에서 이 페이지의 목차를 훑어 보십시오. 영향이 있겠지만 마이그레이션 도우미가 파악하지 못한 항목이 있으면 확인 하십시오. 테스트가 있으면 실행하고 실패한 것을 확인하십시오. 테스트가 없는 경우 브라우저에서 앱을 열고 확인할 때 경고 또는 오류가 발생하지 않도록 주의하십시오. 이제, 앱이 완전히 마이그레이션 되어야합니다. 그래도 아직 허전하다면 이 페이지의 나머지 부분을 읽거나 처음부터 새롭고 향상된 가이드를 읽어보십시오. 이미 핵심 개념을 잘 알고 있으므로 많은 부분을 대강 훑어보는 것이 가능합니다. Vue 1.x 버전을 2버전으로 마이그레이션 하는데 얼마나 걸릴까요? 그것은 몇 가지 사항에 달려 있습니다. 앱 크기 (중소 규모 앱의 경우 하루 미만) 몇 번이나 산만해지고 멋진 새로운 기능으로 시작하십시오. 😉, 우리도 2.0으로 빌드하는 동안 동일하게 발생했습니다! 사용중인 오래된 기능. 대부분은 찾기 및 교체로 업그레이드 할 수 있지만 나머지는 몇 분이 걸릴 수 있습니다. 현재 베스트 프랙티스를 따르지 않는다면 Vue 2.0가 당신에게 강요하려고 할 것입니다. 이것은 장기적으로는 좋은 일이지만 중요한(비록 기한을 넘길 수 있지만) 리펙터링를 의미 할 수도 있습니다. Vue 2로 업그레이드 하면, Vuex와 Vue-Router도 업그레이드 해야합니까? Vue-Router2만 Vue 2와 호환되므로 Vue-Router의 마이그레이션 방법을 따라야합니다. 다행히도 대부분의 응용 프로그램에는 라우터 코드가 많지 않으므로 1시간 이상 걸리지는 않습니다. Vuex는 버전 0.8도 Vue 2와 호환되므로 업그레이드하지 않아도됩니다. 즉시 업그레이드 하기를 원하는 유일한 이유는 모듈 및 감소 된 상용구와 같은 Vuex 2의 새로운 기능을 이용하는 것입니다. 템플릿파편화된 인스턴스 제거됨모든 컴포넌트에는 정확히 하나의 루트 요소가 있어야합니다. 파편화된 인스턴스는 더 이상 허용되지 않습니다. 다음과 같은 템플릿이있는 경우, 12&lt;p&gt;foo&lt;/p&gt;&lt;p&gt;bar&lt;/p&gt; 다음과 같이 전체 내용을 새 엘리먼트로 간단하게 래핑하는 것이 좋습니다. 1234&lt;div&gt; &lt;p&gt;foo&lt;/p&gt; &lt;p&gt;bar&lt;/p&gt;&lt;/div&gt; 업그레이드 방법 업그레이드 후 엔드 투 엔드 테스트 스위트 또는 앱을 실행하고 템플릿의 여러 루트 엘리먼트에 대한 콘솔 경고를 찾습니다. 라이프사이클 훅beforeCompile 제거됨created 훅을 대신 사용하세요. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 이 훅의 모든 예를 찾으십시오. compiled 대체mounted 훅을 대신 사용하세요 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 이 훅의 모든 예를 찾으십시오. attached 제거됨다른 훅에서 사용자 정의 DOM 체크를 사용하십시오. 예를 들어 다음을 대체합니다. 123attached: function () &#123; doSomething()&#125; 이렇게 사용하셔야 합니다. 12345mounted: function () &#123; this.$nextTick(function () &#123; doSomething() &#125;)&#125; 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 이 훅의 모든 예를 찾으십시오. detached 제거됨다른 훅에서 사용자 정의 DOM 체크를 사용하십시오. 예를 들어 다음을 대체합니다. 123detached: function () &#123; doSomething()&#125; You could use: 12345destroyed: function () &#123; this.$nextTick(function () &#123; doSomething() &#125;)&#125; 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 이 훅의 모든 예를 찾으십시오. init 이름 변경대신에 새로운 beforeCreate 훅을 사용하십시오. 이것은 본질적으로 동일합니다. 다른 라이프사이클 메소드와의 일관성을 위해 이름이 변경되었습니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 이 훅의 모든 예를 찾으십시오. ready 대체새로운 mounted 훅을 대신 사용하십시오. mounted를 사용하면 문서 안에 있을 것이라는 보장이 없다는 것을 주의해야 합니다. 이를 위해서 Vue.nextTick/vm. $ nextTick도 포함시키십시오. 예: 12345mounted: function () &#123; this.$nextTick(function () &#123; // $el은 문서 안에 있음을 가정하는 코드. &#125;)&#125; 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 이 훅의 모든 예를 찾으십시오. v-forv-for 배열의 전달인자 순서 변경index를 포함 할 때, 배열의 인수 순서는 (index, value) 이었습니다. forEach 나 map 과 같은 JavaScript의 네이티브 배열 메소드와의 일관성을 유지하기 위해서 (value, index) 가 되었습니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 더 이상 사용되지 않는 전달인자를 찾으십시오. position 또는 num과 같이 인덱스 인수의 이름을 비정상적으로 지정하면 도우미가 플래그를 지정하지 않습니다. v-for 객체 전달인자 순서 변경key를 포함 할 때, 객체의 절단일자 순서는 (key, value) 였습니다. lodash와 같은 공통 객체 iterator와 보다 일관성을 유지하는 것으로 이제 (value, key)를 사용합니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 더 이상 사용되지 않는 전달인자를 찾으십시오. 키 인수의 이름을 name 또는 property 와 같이 지정하면 도우미가 플래그를 지정하지 않습니다. $index and $key 제거됨암묵적으로 할당 된 $index 와 $key 변수는 v-for 에서 명시적으로 정의하기 위해 제거되었습니다. 이렇게하면 Vue에 익숙하지 않은 개발자도 코드를 더 쉽게 읽을 수 있으며 중첩 루프를 처리 할 때 훨씬 명확한 동작을 얻을 수 있습니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 제거 된 변수를 찾으십시오. track-by 대체track-by는 다른 속성과 마찬가지로 key 로 대체되었습니다. v-bind: 또는 : 접두사가 없으면 리터럴 문자열로 취급됩니다. 대부분의 경우, 키 대신 완전 표현식을 기대하는 동적 바인딩을 사용하고자 할 것입니다. 예를 들어, 대신 : 1&lt;div v-for=\"item in items\" track-by=\"id\"&gt; 이제 이렇게 쓸 수 있습니다. 1&lt;div v-for=\"item in items\" v-bind:key=\"item.id\"&gt; 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 track-by의 예를 찾으십시오. v-for 범위 값 변경이전에 v-for=&quot;number in 10&quot;의 number는 0부터 9까지였습니다. 이제는 1부터 10까지 입니다. 업그레이드 방법 코드베이스에서 정규 표현식 /\\w+ in \\d+/을 검색하십시오. v-for에 나타날 때마다 영향을받을 수 있는지 확인하십시오. Propscoerce Prop Option 제거됨props을 coerce 하고 싶다면 대신에 지역적으로 계산된 값을 설정하십시오. 예를 들어, 12345678910props: &#123; username: &#123; type: String, coerce: function (value) &#123; return value .toLowerCase() .replace(/\\s+/, '-') &#125; &#125;&#125; 아래처럼 작성해야 합니다. 12345678910props: &#123; username: String,&#125;,computed: &#123; normalizedUsername: function () &#123; return this.username .toLowerCase() .replace(/\\s+/, '-') &#125;&#125; 이렇게 사용하는 것에 대한 장점입니다. 당신은 여전히 prop의 원래 값에 접근 할 수 있습니다. coerce한 값에 prop에서 전달 된 값과 구별되는 이름을 부여하여 더 명확해 집니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미 를 실행하여 coerce 옵션의 예를 찾으십시오. twoWay Prop 옵션 제거됨props는 항상 단방향입니다. 상위 범위에서 사이드이펙트를 생성하려면 컴포넌트가 암묵적 바인딩에 의존하지 않고 이벤트를 명시적으로 내보내야합니다. 자세한 내용은 다음을 참조하십시오. 사용자 정의 컴포넌트 이벤트 사용자 정의 입력 컴포넌트 (컴포넌트 이벤트를 사용하세요) 전역 상태 관리 업그레이드 방법 코드베이스에서 마이그레이션 도우미 를 실행하여 twoWay 옵션의 예를 찾으십시오. v-bind 와 함께 사용하던 .once 와 .sync 수정자 제거됨props는 항상 단방향입니다. 상위 범위에서 사이드이펙트를 생성하려면 컴포넌트가 암묵적 바인딩에 의존하지 않고 이벤트를 명시적으로 내보내야합니다. 자세한 내용은 다음을 참조하십시오. 사용자 정의 컴포넌트 이벤트 사용자 정의 입력 컴포넌트 (컴포넌트 이벤트를 사용하세요) 전역 상태 관리 업그레이드 방법 코드베이스에서 마이그레이션 도우미 를 실행하여 .once 및 .sync 수정자에 대한 예를 찾아봅니다. Prop 변이 사용안함props 변이의 대부분의 사용 방법은 다음 옵션 중 하나로 대체 할 수 있습니다. props를 지역적 변경 시키는 것은 이제 안티 패턴입니다. prop을 선언하고 컴포넌트에 this.myProp = &#39;someOtherValue&#39;를 설정하십시오. 새로운 렌더링 메커니즘으로 인해 부모 컴포넌트가 다시 렌더링 될 때마다 하위 컴포넌트의 로컬 변경 사항을 덮어 씁니다. prop 변이의 대부분의 사용 사례는 다음 중 하나로 대체 할 수 있습니다. 기본값을 설정하는 데 사용되는 prop가 있는 데이터 속성 계산된 속성 업그레이드 방법 업그레이드 후 엔드 투 엔드 테스트 스위트 또는 앱을 실행하고 소품 변이에 대한 console warnings를 찾으십시오. 루트 인스턴스의 props 대체루트 Vue 인스턴스 (즉,new Vue ({...}) 로 생성 된 인스턴스)에서는 props 대신 propsData를 사용해야합니다. 업그레이드 방법 보유하고있는 엔드 투 엔드 테스트 스위트를 실행하십시오. 실패한 테스트 는 루트 인스턴스로 전달 된 prop가 더 이상 작동하지 않는다는 사실을 알려줍니다. 계산된 속성cache: false 사용안함계산된 속성의 캐싱 무효화는 향후 주요 버전의 Vue에서 제거 될 예정입니다. 캐시 되지 않은 계산된 속성을 같은 결과를 갖는 메소드로 대체하십시오. 예제: 123456789template: '&lt;p&gt;message: &#123;&#123; timeMessage &#125;&#125;&lt;/p&gt;',computed: &#123; timeMessage: &#123; cache: false, get: function () &#123; return Date.now() + this.message &#125; &#125;&#125; 또는 컴포넌트 메소드를 사용합니다 123456template: '&lt;p&gt;message: &#123;&#123; getTimeMessage() &#125;&#125;&lt;/p&gt;',methods: &#123; getTimeMessage: function () &#123; return Date.now() + this.message &#125;&#125; Upgrade Path Run the migration helper on your codebase to find examples of the cache: false option. 내장 디렉티브v-bind의 참/거짓 변경v-bind와 함께 사용되면, 유일한 거짓 값은 null,undefined,false 입니다. 이것은 0을 의미하고 빈 문자열은 참으로로 렌더링됩니다. 예를 들어 v-binddraggable=&quot;&#39;&#39;&quot;는 draggable=&quot;true&quot;로 렌더링 할 것입니다. 열거된 속성의 경우 위의 위조 된 값 외에도&#39;false&#39; 문자열은 attr=&quot;false&quot; 로 렌더링됩니다. 다른 지시어 (예: `v-if` 및`v-show`)의 경우 JavaScript의 일반적인 참 거짓이 여전히 적용됩니다. 업그레이드 방법 보유하고 있는 엔드 투 엔드 테스트 스위트를 실행하십시오. 실패한 테스트는 이 변경의 영향을 받을 수 있는 앱의 모든 부분을 알려줍니다. v-on의 컴포넌트에 있는 네이티브 이벤트 리스닝 변경컴포넌트에서 사용될 때,v-on은 그 컴포넌트에 의해 $emit된 사용자 지정 이벤트를 받습니다. 루트 요소에서 네이티브 DOM 이벤트를 받으려면 .native 한정자를 사용할 수 있습니다. 예: 1&lt;my-component v-on:click.native=\"doSomething\"&gt;&lt;/my-component&gt; 업그레이드 방법 보유하고 있는 엔드 투 엔드 테스트 스위트를 실행하십시오. 실패한 테스트는이 변경의 영향을 받을 수 있는 앱의 모든 부분을 알려줍니다. v-model를 위한 debounce 매개 변수 제거됨디바운싱은 Ajax 요청 및 기타 무거운 작업을 실행하는 빈도를 제한하는 데 사용됩니다. v-model에 대한 Vue의 debounce 매개 변수은 매우 단순한 경우에 이것을 쉽게 만들었지만, 무거운 작업 자체보다는 상태 갱신 에 실제로 사용했습니다. 미묘한 차이점이 있지만 애플리케이션이 커짐에 따라 한계가 있습니다. 이러한 제한 사항은 예를 들어 다음과 같은 검색 표시기를 설계할 때 분명 해집니다. {{ searchIndicator }} new Vue({ el: '#debounce-search-demo', data: { searchQuery: '', searchQueryIsDirty: false, isCalculating: false }, computed: { searchIndicator: function () { if (this.isCalculating) { return '⟳ Fetching new results' } else if (this.searchQueryIsDirty) { return '... Typing' } else { return '✓ Done' } } }, watch: { searchQuery: function () { this.searchQueryIsDirty = true this.expensiveOperation() } }, methods: { expensiveOperation: _.debounce(function () { this.isCalculating = true setTimeout(function () { this.isCalculating = false this.searchQueryIsDirty = false }.bind(this), 1000) }, 500) } }) debounce 속성을 사용하면 입력의 실시간 상태에 액세스할 수 없으므로 “입력” 상태를 감지 할 수 없습니다. 그러나 Vue에서 디바운스 기능을 분리하면 제한하려는 작업만 디버깅할 수 있으므로 개발할 수있는 기능의 한계가 사라집니다. 12345678910&lt;!--lodash 또는 다른 유틸리티 라이브러리의 debounce 기능을 사용하여우리가 사용하는 특정 debounce 가장 좋은 사례인 것을 알 수 있습니다.이 템플릿 에서뿐만 아니라 어디에서나 사용할 수 있습니다.--&gt;&lt;script src=\"https://cdn.jsdelivr.net/lodash/4.13.1/lodash.js\"&gt;&lt;/script&gt;&lt;div id=\"debounce-search-demo\"&gt; &lt;input v-model=\"searchQuery\" placeholder=\"Type something\"&gt; &lt;strong&gt;&#123;&#123; searchIndicator &#125;&#125;&lt;/strong&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435new Vue(&#123; el: '#debounce-search-demo', data: &#123; searchQuery: '', searchQueryIsDirty: false, isCalculating: false &#125;, computed: &#123; searchIndicator: function () &#123; if (this.isCalculating) &#123; return '⟳ Fetching new results' &#125; else if (this.searchQueryIsDirty) &#123; return '... Typing' &#125; else &#123; return '✓ Done' &#125; &#125; &#125;, watch: &#123; searchQuery: function () &#123; this.searchQueryIsDirty = true this.expensiveOperation() &#125; &#125;, methods: &#123; // debounce가 실제로 작동하는 곳 입니다. expensiveOperation: _.debounce(function () &#123; this.isCalculating = true setTimeout(function () &#123; this.isCalculating = false this.searchQueryIsDirty = false &#125;.bind(this), 1000) &#125;, 500) &#125;&#125;) 이 접근법의 또 다른 장점은 디바운싱 (debouncing)이 올바른 래퍼 함수가 아닌 경우입니다. 예를 들어 추천 검색어 용 API를 사용하는 경우 사용자가 일정 기간 동안 입력을 중지 할 때까지 제안을 기다리는 것이 이상적인 방법이 아닙니다. 대신 throttling 함수가 필요합니다. 이제 lodash와 같은 유틸리티 라이브러리를 사용하는 경우 throttle 함수로 리팩토링하면 몇 초 밖에 걸리지 않습니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여the debounce attribute. v-model에 대한 lazy 또는number 매개 변수 대체lazy와number 매개 변수는 이제 수정자입니다. 12&lt;input v-model=\"name\" lazy&gt;&lt;input v-model=\"age\" type=\"number\" number&gt; 이렇게 사용해야 합니다. 12&lt;input v-model.lazy=\"name\"&gt;&lt;input v-model.number=\"age\" type=\"number\"&gt; 업그레이드 방법 코드베이스에서 마이그레이션 도우미 를 실행하여 이러한 매개 변수 속성의 예를 찾으십시오. v-model의 value 속성 제거됨v-model은 더 이상 인라인 value 속성의 초기 값을 신경 쓰지 않습니다. 예측 가능성을 위해, 대신 Vue 인스턴스 데이터를 항상 원본 소스로 취급합니다. 즉, 이 엘리먼트를 의미합니다. 1&lt;input v-model=\"text\" value=\"foo\"&gt; 이 데이터를 바탕으로 123data: &#123; text: 'bar'&#125; “foo “대신 “bar” 값으로 렌더링됩니다. 기존 내용이 있는 &lt;textarea&gt;도 마찬가지입니다. 123&lt;textarea v-model=\"text\"&gt; hello world&lt;/textarea&gt; text의 초기 값이 “hello world”인지 확인해야합니다. 업그레이드 방법 업그레이드 후 엔드 투 엔드 테스트 스위트 또는 앱을 실행하고 v-model을 사용하여 인라인 값 속성에 대한 console warnings를 찾습니다. v-for를 사용하는 v-model이 반복 된 기본 값 제거됨이와 같은 사례는 더 이상 작동하지 않습니다. 1&lt;input v-for=\"str in strings\" v-model=\"str\"&gt; 왜냐하면 &lt;input&gt; 이 컴파일할 수 있는 것과 동등한 JavaScript이기 때문입니다. 123strings.map(function (str) &#123; return createElement('input', ...)&#125;) 보시다시피, v-model의 양방향 바인딩은 여기서 의미가 없습니다. iterator 함수에서 str을 다른 값으로 설정하면 함수 범위에 있는 지역 변수이기 때문에 아무 일도 하지 않습니다. 대신,v-model이 객체의 필드를 업데이트 할 수 있도록 objects 배열을 사용해야합니다. 1&lt;input v-for=\"obj in objects\" v-model=\"obj.str\"&gt; 업그레이드 방법 Run your test suite, if you have one. The failed tests should alert to you to any parts of your app that may be affected by this change. 객체 문법과 !important를 가지는 v-bind:style 제거됨더 이상 작동하지 않습니다. 1&lt;p v-bind:style=\"&#123; color: myColor + ' !important' &#125;\"&gt;hello&lt;/p&gt; 정말로 !important를 오버라이드 할 필요가 있다면, 다음과 같이 문자열 구문을 사용해야합니다. 1&lt;p v-bind:style=\"'color: ' + myColor + ' !important'\"&gt;hello&lt;/p&gt; 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여style bindings with !important in objects. v-el 와 v-ref 대체단순화를 위해,v-el 과 v-ref는 ref 속성으로 병합되었습니다. 이 속성은 $refs를 통해 컴포넌트 인스턴스에서 접근 가능합니다. 이는 v-el:my-element가 ref=&quot;myElement&quot;가되고 v-ref:my-component가 ref=&quot;myComponent&quot;가된다는 것을 의미합니다. 일반 요소에서 사용될 때,ref는 DOM 요소가 될 것이고, 컴포넌트에서 사용될 때,ref는 컴포넌트 인스턴스가 될 것입니다. v-ref는 더 이상 디렉티브가 아니며 특별한 속성이기 때문에 동적으로 정의 될 수도 있습니다. 이것은 v-for와 함께 사용할 때 특히 유용합니다. 1&lt;p v-for=\"item in items\" v-bind:ref=\"'item' + item.id\"&gt;&lt;/p&gt; 이전에 v-el/v-ref 와 v-for를 조합하면 각 항목에 고유한 이름을 부여 할 방법이 없었기 때문에 엘리먼트/컴포넌트 배열을 생성합니다. 각 항목에 같은 ref를 주면 여전히 이 동작을 할 수 있습니다. 1&lt;p v-for=\"item in items\" ref=\"items\"&gt;&lt;/p&gt; 1.x와는 달리 이 $refs는 렌더링 프로세스 자체에서 등록/갱신 되기 때문에 반응형이지 않습니다. 이를 반응형으로 만드려면 모든 변경에 대해 중복 렌더링이 필요합니다. 반면에 $refs는 주로 JavaScript에서의 프로그래밍 방식 접근을 위해 고안되었습니다. 인스턴스 자체에 속하지 않는 상태를 가리키는 것이므로 템플릿에서 의존하지 않는 것이 좋습니다. 이는 Vue의 데이터 기반 뷰 모델을 위반하게됩니다. 업그레이드 방법 v-el과 v-ref를 찾기 위해 코드베이스에서 마이그레이션 도우미를 실행하기. v-show의 v-else 제거됨v-else는 더 이상v-show와 함께 작동하지 않습니다. 대신에v-if를 부정식으로 사용하십시오. 대신에, 12&lt;p v-if=\"foo\"&gt;Foo&lt;/p&gt;&lt;p v-else v-show=\"bar\"&gt;Not foo, but bar&lt;/p&gt; You can use: 12&lt;p v-if=\"foo\"&gt;Foo&lt;/p&gt;&lt;p v-if=\"!foo &amp;&amp; bar\"&gt;Not foo, but bar&lt;/p&gt; 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여the v-else with v-show. 사용자 지정 디렉티브 단순화지시어는 책임 범위를 크게 줄였습니다. 이제는 하위 수준의 직접 DOM 조작을 적용하는 경우만 사용됩니다. 대부분의 경우 컴포넌트를 주 코드 재사용 추상화로 사용하는 것이 좋습니다. 가장 주목할만한 차이점은 다음과 같습니다. 디렉티브에 더 이상 인스턴스가 없습니다. 이것은 디렉티브 훅 안에 this가 없다는 것을 의미합니다. 대신 필요한 모든 것을 전달인자로 받습니다. 실제로 훅을 가로채는 상태를 유지해야한다면 el 에서 그렇게 할 수 있습니다. acceptStatement, deep, priority 등의 옵션은 모두 제거되었습니다. twoWay 지시어를 대체하려면 이 예제를 참조하십시오. 현재의 훅 중 일부는 다른 동작을 하며 몇 가지 새로운 후크가 있습니다. 다행스럽게도 새로운 디렉티브가 훨씬 간단하기 때문에 보다 쉽게 마스터 할 수 있습니다. 자세한 내용은 새로운 사용자 지정 디렉티브 가이드를 읽어보십시오. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 정의 된 디렉티브의 예를 찾으십시오. 도우미는 모든 엘리먼트에 플래그를 지정합니다. 대부분의 경우 엘리먼트로 리팩토링하려는 경우가 많기 때문입니다. 디렉티브 .literal 수정자 제거됨.literal 수정자는 제거되었습니다. 문자열 리터럴을 값으로 제공하는 것만으로 쉽게 달성 할 수 있습니다. 예를 들어 다음을 변경 할 수 있습니다. 1&lt;p v-my-directive.literal=\"foo bar baz\"&gt;&lt;/p&gt; 이 것은 1&lt;p v-my-directive=\"'foo bar baz'\"&gt;&lt;/p&gt; 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 `.literal` 수정자의 예를 찾으십시오. 트랜지션 효과transition 속성 대체Vue의 트랜지션 시스템은 상당히 크게 변경되어 이제 transition 속성보다는 &lt;transition&gt; 과 &lt;transition-group&gt; 래퍼 요소를 사용합니다. 자세한 내용은 새 트랜지션 안내를 읽는 것이 좋습니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 transition 속성의 예를 찾으십시오.. Vue.transition의 재사용 가능한 트랜지션 대체새로운 트랜지션 시스템을 사용하면 재사용 가능한 트랜지션을 위해 컴포넌트를 사용할 수 있습니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여Vue.transition의 예를 찾으십시오. 트랜지션 stagger 속성 제거됨리스트 트랜지션을 엇갈리게 할 필요가있는 경우, 요소의 data-index (또는 유사한 속성)를 설정하고 액세스하여 타이밍을 제어 할 수 있습니다. 예제를 보십시오. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여the transition 속성의 예를 찾으십시오. 업데이트 하는 동안, 트랜지션이 매우 요동칠 수 있습니다. 이벤트events 옵션 제거됨events 옵션이 삭제되었습니다. 이제 이벤트 핸들러는 created 훅에 등록해야 합니다. 자세한 예제는 [$dispatch 와 $broadcast 마이그레이션 가이드](# dispatch-and-broadcast-replaced)를 확인하십시오. Vue.directive(&#39;on&#39;).keyCodes 대체keyCodes를 구성하는 새롭고 더 간결한 방법은 Vue.config.keyCodes를 사용하는 것 입니다. 예 : 12// enable v-on:keyup.f1Vue.config.keyCodes.f1 = 112 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 이전keyCode 구성 문법의 예를 찾으십시오. $dispatch 와 $broadcast 대체$dispatch와 $broadcast는 Vuex와 같이 보다 명확한 컴포넌트간 통신과 보다 유지 보수가 가능한 상태 관리 솔루션을 위해 제거되었습니다. 문제는 컴포넌트의 트리 구조에 의존하는 이벤트 흐름이 트리가 커질 때 추론하기 어려울 수 있으며 매우 취약하다는 것입니다. 그것은 단순히 잘 확장되지 않으며 우리는 나중에 고통을 주고 싶지 않습니다. $dispatch 와 $broadcast 도 형제 컴포넌트 간의 커뮤니케이션을 해결하지 못합니다. 이 방법의 가장 보편적 인 사용법 중 하나는 부모와 그 직접 자식 사이의 커뮤니케이션입니다. 이 경우, 실제로 v-on을 가진 자식으로부터 $emit을 감지.할 수 있습니다. 이렇게하면 이벤트의 편리성을 유지할 수 있습니다. 그러나 멀리 떨어진 자손 / 조상간에 의사 소통을 할 때 $emit 이 도움이되지 않습니다. 대신 가장 간단한 방안은 중앙 집중화 된 이벤트 허브를 사용하는 것입니다. 컴포넌트 트리에 상관없이 컴포넌트간에 통신 할 수있는 추가 이점이 있습니다 - 형제 사이에서도 가능합니다! Vue 인스턴스는 이벤트 이미 인터페이스를 구현하기 때문에 이 목적으로 빈 Vue 인스턴스를 실제로 사용할 수 있습니다. 예를 들어 다음과 같이 Todo 앱을 구성했다고 가정 해 보겠습니다. 1234Todos├─ NewTodoInput└─ Todo └─ DeleteTodoButton 이 단일 이벤트 허브를 사용하여 컴포넌트 간의 통신을 관리 할 수 있습니다. 123// 이 이벤트 허브는// 컴포넌트 사이에서 통신 할 수 있습니다.var eventHub = new Vue() 그런 다음 우리의 컴포넌트에서 $emit, $on, $off를 사용하여 이벤트를 내보내고, 이벤트를 수신하고, 이벤트 리스너를 각각 정리할 수 있습니다. 12345678// NewTodoInput// ...methods: &#123; addTodo: function () &#123; eventHub.$emit('add-todo', &#123; text: this.newTodoText &#125;) this.newTodoText = '' &#125;&#125; 1234567// DeleteTodoButton// ...methods: &#123; deleteTodo: function (id) &#123; eventHub.$emit('delete-todo', id) &#125;&#125; 123456789101112131415161718192021// Todos// ...created: function () &#123; eventHub.$on('add-todo', this.addTodo) eventHub.$on('delete-todo', this.deleteTodo)&#125;,// 컴포넌트가 파괴되기 전에 이벤트 리스너를 정리하는 것이 좋습니다.beforeDestroy: function () &#123; eventHub.$off('add-todo', this.addTodo) eventHub.$off('delete-todo', this.deleteTodo)&#125;,methods: &#123; addTodo: function (newTodo) &#123; this.todos.push(newTodo) &#125;, deleteTodo: function (todoId) &#123; this.todos = this.todos.filter(function (todo) &#123; return todo.id !== todoId &#125;) &#125;&#125; 이 패턴은 단순한 시나리오에서 $dispatch 와 $broadcast를 대체 할 수 있지만 더 복잡한 경우에는 Vuex와 같은 전용 상태 관리 레이어를 사용하는 것이 좋습니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여$dispatch and $broadcast. 필터외부 텍스트 보간 필터 제거됨이제 필터는 텍스트 보간({{ }})태그 내에서만 사용할 수 있습니다. 과거에 우리는v-model, v-on 등과 같은 디렉티브 내에서 필터를 사용하는 것이 편리함보다 더 복잡하다는 것을 발견했습니다. v-for에 대한 목록 필터링의 경우 논리를 JavaScript로 계산된 속성으로 이동하여 컴포넌트 전체에서 재사용할 수 있습니다. 일반적으로 자바 스크립트에서 무언가를 얻을 수 있을 때마다 필터와 같은 특별한 구문을 사용하지 않아도 되므로 동일한 관심사를 처리할 수 있습니다. Vue의 기본 제공 디렉티브 필터를 대체하는 방법은 다음과 같습니다. debounce 필터 변경아래 코드 대신에 1&lt;input v-on:keyup=\"doStuff | debounce 500\"&gt; 12345methods: &#123; doStuff: function () &#123; // ... &#125;&#125; lodash의 debounce (또는 가능하면 throttle) 고사양의 방법을 직접적으로 제한하는 것. 위와 같이 다음과 같이 할 수 있습니다. 1&lt;input v-on:keyup=\"doStuff\"&gt; 12345methods: &#123; doStuff: _.debounce(function () &#123; // ... &#125;, 500)&#125; 이 전략의 장점에 대해서는 여기에v-model 예제가 있습니다. limitBy 필터 교체아래 코드 대신에 1&lt;p v-for=\"item in items | limitBy 10\"&gt;&#123;&#123; item &#125;&#125;&lt;/p&gt; 계산 된 속성에서 JavaScript의 내장 된 .slice 메서드를 사용하십시오. 1&lt;p v-for=\"item in filteredItems\"&gt;&#123;&#123; item &#125;&#125;&lt;/p&gt; 12345computed: &#123; filteredItems: function () &#123; return this.items.slice(0, 10) &#125;&#125; filterBy 필터 교체아래 코드 대신에 1&lt;p v-for=\"user in users | filterBy searchQuery in 'name'\"&gt;&#123;&#123; user.name &#125;&#125;&lt;/p&gt; JavaScript에 내장된 .filter 메소드를 계산된 속성에서 사용하십시오. 1&lt;p v-for=\"user in filteredUsers\"&gt;&#123;&#123; user.name &#125;&#125;&lt;/p&gt; 12345678computed: &#123; filteredUsers: function () &#123; var self = this return self.users.filter(function (user) &#123; return user.name.indexOf(self.searchQuery) !== -1 &#125;) &#125;&#125; JavaScript의 네이티브 .filter는 계산된 속성 내에서 JavaScript의 모든 기능에 액세스할 수 있으므로 훨씬 더 복잡한 필터링 작업도 관리 할 수 있습니다. 예를 들어 모든 활성 사용자를 찾고 이름과 이메일 모두와 대소 문자를 구분하지 않으려면 다음을 수행하십시오. 12345678var self = thisself.users.filter(function (user) &#123; var searchRegex = new RegExp(self.searchQuery, 'i') return user.isActive &amp;&amp; ( searchRegex.test(user.name) || searchRegex.test(user.email) )&#125;) orderBy 필터 교체아래 코드 대신에 1&lt;p v-for=\"user in users | orderBy 'name'\"&gt;&#123;&#123; user.name &#125;&#125;&lt;/p&gt; 계산된 속성에서 lodash의 orderBy (또는 sortBy)를 사용하십시오. 1&lt;p v-for=\"user in orderedUsers\"&gt;&#123;&#123; user.name &#125;&#125;&lt;/p&gt; 12345computed: &#123; orderedUsers: function () &#123; return _.orderBy(this.users, 'name') &#125;&#125; 여러개의 열을 정렬할 수도 있습니다. 1_.orderBy(this.users, ['name', 'last_login'], ['asc', 'desc']) 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 디렉티브 내에서 사용되는 필터의 예를 찾으십시오. 빠뜨린 경우 console errors도 표시되어야합니다. 필터 전달인자 구문 변경이제 필터 함수의 전달인자 구문이 JavaScript함수 호출과 더 잘 일치합니다. 따라서 공백으로 구분 된 전달인자를 취하는 대신 1&lt;p&gt;&#123;&#123; date | formatDate 'YY-MM-DD' timeZone &#125;&#125;&lt;/p&gt; 전달인자를 괄호로 묶고 쉼표로 구분합니다. 1&lt;p&gt;&#123;&#123; date | formatDate('YY-MM-DD', timeZone) &#125;&#125;&lt;/p&gt; 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 이전 필터 구문의 예를 찾으십시오. 빠뜨린 경우 console errors도 표시되어야합니다. 내장 텍스트 필터 제거됨텍스트 보간 내의 필터는 여전히 허용되지만 모든 필터가 제거 되었습니다. 대신 각 도메인의 문제를 해결하기 위해보다 전문화된 라이브러리를 사용하는 것이 좋습니다 (예 : 날짜 형식을 지정하는 date-fns및 통화를 위한 accounting). Vue에 내장 된 텍스트 필터 각각에 대해 아래에서 어떻게 대체 할 수 있는지 살펴 보겠습니다. 예제 코드는 사용자 지정 헬퍼 함수, 메서드 또는 계산 된 속성에 있을 수 있습니다. json 필터 변경Vue는 문자열, 숫자, 배열 또는 일반 객체 등 사용자가 자동으로 출력 형식을 지정하기 때문에 실제로는 더 이상 디버깅 할 필요가 없습니다. 그래도 JavaScript의 JSON.stringify와 같은 기능을 원한다면 메소드나 계산 된 속성에서 사용할 수 있습니다. capitalize 필터 변경1text[0].toUpperCase() + text.slice(1) uppercase 필터 변경1text.toUpperCase() lowercase 필터 변경1text.toLowerCase() pluralize 필터 변경NPM의 pluralize 패키지는 이 목적을 훌륭하게 처리하지만, 특정 단어를 복수화하거나 ‘0’과 같은 특수 출력을 원하면 사용자 고유의 복수화 함수를 쉽게 정의 할 수 있습니다. 예 : 123456789function pluralizeKnife (count) &#123; if (count === 0) &#123; return 'no knives' &#125; else if (count === 1) &#123; return '1 knife' &#125; else &#123; return count + 'knives' &#125;&#125; currency 필터 변경매우 조악한 구현을 위해 다음과 같이 할 수 있습니다. 1'$' + price.toFixed(2) 하지만 대부분의 경우 여전히 이상한 동작을 보일 것입니다 (예 : 0.035.toFixed(2) 는 0.04 까지 반올림합니다, 그러나 0.045는0.04로 반올림됩니다). 이러한 문제를 해결하기 위해 accounting 라이브러리를 사용하여 보다 안정적으로 통화를 형식화 할 수 있습니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 오래된 텍스트 필터의 예를 찾으십시오. 빠뜨린 경우 console errors도 표시되어야합니다. 양방향 필터 대체일부 사용자는 v-model과 함께 양방향 필터를 사용하여 매우 적은 코드로 흥미로운 입력을 사용하였습니다. 그러나 단순하지만 양방향 필터는 많은 복잡성을 숨길 수 있으며 심지어 상태 업데이트를 지연시켜 빈약한 UX를 만들 수 있습니다. 대신 입력을 래핑하는 컴포넌트는 사용자 지정 입력을 만드는 보다 명확하고 기능이 풍부한 방법으로 권장됩니다. 예를 들어 양방향 통화 필터의 마이그레이션을 살펴 보겠습니다. 대부분 잘 작동하지만 지연된 상태 업데이트로 인해 이상한 동작이 발생할 수 있습니다. 예를 들어,`Result` 탭을 클릭하고 그 입력 중 하나에 `9.999`를 입력하십시오. 입력 값이 사라지면 값은 `$ 10.00`으로 업데이트됩니다. 그러나 계산 된 합계를 보면 `9.999`가 데이터에 저장 되어 있는 것을 볼 수 있습니다. 사용자가 보는 현실의 버전이 동기화되지 않았습니다! Vue 2.0을 사용하여 좀 더 강력한 솔루션으로 트랜지션하려면 먼저이 필터를 새로운 `` 컴포넌트로 둘러 쌉시다. 이렇게하면 포커스가 있는 입력 내용을 선택하는 것 처럼 필터만으로는 캡슐화할 수 없는 동작을 추가할 수 있습니다. 이제 다음 단계는 필터에서 비즈니스 로직을 추출하는 것입니다. 아래에서는 모든 것을 [currencyValidator](https://gist.github.com/chrisvfritz/5f0a639590d6e648933416f90ba7ae4e)객체 외부로 가져옵니다. 이처럼 모듈성이 높아지면 Vue 2로 마이그레이션하는 것이 더 쉬워질 뿐만 아니라 통화 구문 분석 및 서식 지정이 가능합니다. Vue 코드와 분리 된 단위 테스트 애플리케이션의 다른 부분 (예: API 엔드 포인트에 대한 페이로드의 유효성 검사)에서 사용됩니다. 이 유효성 검사기를 추출한 결과 우리는 더욱 편안하게 이 솔루션을 더욱 강력하게 구축했습니다. 주 상태에 대한 단점이 제거되었고 사용자가 잘못 입력 한다는 것은 사실상 불가능합니다. 브라우저의 기본 숫자 입력이 시도하는 것과 유사합니다. 필터는 Vue 1.0에 대해서는 여전히 제한적이므로 Vue 2.0으로의 업그레이드를 마무리 하겠습니다. 다음 사항을 알 수 있습니다. 양방향 필터의 숨겨진 동작 대신 라이프 사이클 훅 및 DOM 이벤트를 사용하여 입력의 모든 측면을 보다 명확하게 설명합니다. 우리는 이제v-model을 사용자 지정 입력에 직접 사용할 수 있습니다. 이는 일반적인 입력과 일관성이 있을뿐만 아니라 Vuex 친화적이라는 것을 의미합니다. 값을 반환해야하는 필터 옵션을 더 이상 사용하지 않으므로 실제로 통화 작업을 비동기 적으로 수행 할 수 있습니다. 즉, 통화로 작업 해야하는 앱이 많이 있다면이 로직을 공유 마이크로 서비스로 쉽게 리팩토링 할 수 있습니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 v-model과 같은 디렉티브에 사용되는 필터의 예를 찾으십시오. 빠뜨린 경우 console errors도 표시되어야합니다. 슬롯중복 슬롯 제거됨같은 템플릿 안에 같은 이름을 가진 &lt;slot&gt;을 더 이상 지원하지 않습니다. 슬롯이 렌더링 될 때 “사용”되고 같은 렌더링 트리의 다른 위치로 렌더링 될 수 없습니다. 여러 장소에서 같은 내용을 렌더링해야하는 경우 해당 내용을 prop로 전달하십시오. 업그레이드 방법 업그레이드 후 엔드 투 엔드 테스트 스위트 또는 앱을 실행하고 중복 슬롯 v-model에 대한 console warnings를 찾습니다. slot 속성 스타일링 제거됨이름이 &lt;slot&gt;인 삽입 된 내용은 더 이상 slot 속성을 유지하지 않습니다. 래퍼 요소를 사용하여 스타일을 지정하거나 고급 사용 사례의 경우 렌더 함수를 사용하여 프로그래밍 방식으로 삽입 된 내용을 수정하십시오. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 명명된 슬롯을 대상으로하는 CSS 선택자를 찾습니다 (예 : [slot=\"my-slot-name\"]). 특수 속성keep-alive 속성 대체keep-alive는 더 이상 특별한 속성이 아니라 &lt;transition&gt;과 비슷한 래퍼 컴포넌트입니다. 예: 123&lt;keep-alive&gt; &lt;component v-bind:is=\"view\"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 이렇게 하면 여러 조건부 하위에서 &lt;keep-alive&gt;를 사용할 수 있습니다. 1234&lt;keep-alive&gt; &lt;todo-list v-if=\"todos.length &gt; 0\"&gt;&lt;/todo-list&gt; &lt;no-todos-gif v-else&gt;&lt;/no-todos-gif&gt;&lt;/keep-alive&gt; ``에 자식이 여러 개 있을 때, 그들은 결국 하나의 자식으로 계산 되어야합니다. 첫 번째 자식이 아닌 다른 자식은 무시됩니다. ``과 함께 사용하는 경우, 내부에 중첩시켜야합니다 : 12345&lt;transition&gt; &lt;keep-alive&gt; &lt;component v-bind:is=\"view\"&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/transition&gt; 업그레이드 방법 keep-alive 속성을 찾으려면 코드베이스에서 마이그레이션 도우미를 실행하십시오. 보간속성을 이용한 보간 제거됨속성을 이용한 보간은 이제 지원하지 않습니다. 1&lt;button class=\"btn btn-&#123;&#123; size &#125;&#125;\"&gt;&lt;/button&gt; 인라인 구문을 사용하도록 변경 해야 합니다. 1&lt;button v-bind:class=\"'btn btn-' + size\"&gt;&lt;/button&gt; 또는 데이터/계산 된 속성: 1&lt;button v-bind:class=\"buttonClasses\"&gt;&lt;/button&gt; 12345computed: &#123; buttonClasses: function () &#123; return 'btn btn-' + size &#125;&#125; 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 속성 내에서 사용되는 보간 예제를 찾으십시오. HTML 보간 제거됨HTML 보간은 ({{{ foo }}}) 삭제되었습니다 v-html 디렉티브을 사용하세요. 업그레이드 방법 HTML 보간법을 찾으려면 코드베이스에서 마이그레이션 도우미를 실행하십시오. 일회용 바인딩 대체일회용 바인딩 ({{* foo }})은 v-once 디렉티브으로 변경되었습니다. 업그레이드 방법 일회성 바인딩을 찾으려면 코드베이스에서 마이그레이션 도우미를 실행하십시오. 반응형vm.$watch 변경vm.$watch를 통해 생성된 감시자는 이제 연결된 컴포넌트가 재 렌더링되기 전에 시작됩니다. 이렇게 하면 컴포넌트가 다시 렌더링되기 전에 상태를 추가로 업데이트하여 불필요한 업데이트를 피할 수 있습니다. 예를 들어, prop이 보이면 컴포넌트 prop를 보고 컴포넌트의 자체 데이터를 업데이트 할 수 있습니다. 이전에 컴포넌트 업데이트 후에 DOM을 사용하여 vm.$watch에 의존 하고 있었다면, 대신 updated 라이프 사이클 훅에서 그렇게 할 수 있습니다. 업그레이드 방법 보유하고있는 엔드 투 엔드 테스트 스위트를 실행하십시오. 실패한 테스트는 감지사가 이전 동작을 사용하고 있다는 사실을 알려줍니다. vm.$set 변경vm.$set 는 이제 Vue.set 별칭입니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 이전 사용법의 예를 찾으십시오. vm.$delete 변경vm.$delete 는 이제 Vue.delete의 별칭입니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미 를 실행하여 이전 사용법의 예를 찾으십시오. Array.prototype.$set 제거됨Vue.set을 사용하십시오. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 배열에서 .$set의 예를 찾으십시오. 누락 된 경우 console errors가 표시됩니다. Array.prototype.$remove 제거됨Array.prototype.splice을 사용하십시오 123456methods: &#123; removeTodo: function (todo) &#123; var index = this.todos.indexOf(todo) this.todos.splice(index, 1) &#125;&#125; 아니면, 더 나은 방법은 색인 제거 방법을 전달하는 것입니다. 12345methods: &#123; removeTodo: function (index) &#123; this.todos.splice(index, 1) &#125;&#125; 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 배열에서 .$remove의 예를 찾으십시오. 누락 된 경우 console errors가 표시됩니다. Vue 인스턴스의 Vue.set 와 Vue.delete 제거됨Vue.set 과 Vue.delete는 Vue 인스턴스에서 더 이상 작동하지 않습니다. 이제 데이터 옵션의 모든 최상위 반응형 특성을 올바르게 선언 해야 합니다. Vue 인스턴스 또는 $data에서 속성을 삭제하려면 null로 설정하면됩니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 Vue.set 또는 Vue.delete를 참조하십시오. 무엇이든 놓치면 console errors가 표시됩니다. vm.$data 변경 제거됨이제는 구성 요소 인스턴스의 루트 $data를 바꿀 수 없습니다. 이렇게하면 반응형 시스템의 일부 엣지 케이스를 방어하고 컴포넌트 상태를 보다 예측 가능하게 만듭니다 (특히 타입 체킹 시스템의 경우). 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 vm.$data를 덮어 쓴 예를 찾으십시오. 빠뜨리면 console errors가 표시됩니다. vm.$get 제거됨반응성 데이터를 직접 검색하면됩니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미 를 실행하여 vm.$get의 예를 찾으십시오. 무엇이든 놓치면 console errors가 표시됩니다. DOM 중심 인스턴스 메소드vm.$appendTo 제거됨기본 DOM API 사용 : 1myElement.appendChild(vm.$el) 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 vm.$appendTo의 예를 찾으십시오. 무엇이든 놓치면 console errors가 표시됩니다. vm.$before 제거됨기본 DOM API 사용 : 1myElement.parentNode.insertBefore(vm.$el, myElement) 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 vm.$before의 예를 찾으십시오. 무엇이든 놓치면 console errors가 표시됩니다. vm.$after 제거됨기본 DOM API 사용 : 1myElement.parentNode.insertBefore(vm.$el, myElement.nextSibling) 또는 myElement가 마지막 자식 인 경우 : 1myElement.parentNode.appendChild(vm.$el) 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 vm.$after의 예를 찾으십시오. 무엇이든 놓치면 console errors가 표시됩니다. vm.$remove 제거됨기본 DOM API 사용 : 1vm.$el.remove() 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 vm.$remove의 예를 찾으십시오. 무엇이든 놓치면 console errors가 표시됩니다. 메타 인스턴스 메소드vm.$eval 제거됨실제로 사용하지 마십시오. 이 기능을 어떻게든 사용하고 문제를 해결하는 방법을 모르는 경우 포럼에 문의하세요. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 vm.$eval의 예를 찾으십시오. 무엇이든 놓치면 console errors가 표시됩니다. vm.$interpolate 제거됨실제로 사용하지 마십시오. 이 기능을 어떻게든 사용하고 문제를 해결하는 방법을 모르는 경우 포럼에 문의하세요. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 vm.$interpolate의 예를 찾으십시오. 무엇이든 놓치면 console errors가 표시됩니다. vm.$log 제거됨최적의 디버깅 환경을 얻으려면 Vue Devtools를 사용하십시오. 업그레이드 방법 코드베이스에서 마이그레이션 도우미 를 실행하여 vm.$log의 예를 찾으십시오. 무엇이든 놓치면 console errors가 표시됩니다. 인스턴스 DOM 옵션들replace: false 제거됨이제 컴포넌트는 바인딩 된 요소를 항상 바꿉니다. replace:false 의 동작을 시뮬레이트하기 위해, 당신은 대체하려는 것과 비슷한 엘리먼트로 루트 컴포넌트를 래핑 할 수 있습니다. 예: 1234new Vue(&#123; el: '#app', template: '&lt;div id=\"app\"&gt; ... &lt;/div&gt;'&#125;) 또는 렌더 함수와 함께: 12345678910new Vue(&#123; el: '#app', render: function (h) &#123; h('div', &#123; attrs: &#123; id: 'app', &#125; &#125;, /* ... */) &#125;&#125;) 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여replace: false의 예를 찾으십시오. 전역 설정Vue.config.debug 제거됨더 이상 필요하지 않습니다. 경고는 기본적으로 스택 트레이서로 제공됩니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여 Vue.config.debug의 예를 찾으십시오. Vue.config.async 제거됨렌더링 성능에 비동기가 필요합니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여Vue.config.async의 예를 찾으십시오. Vue.config.delimiters 대체이것은 컴포넌트 수준 옵션으로 재 작성되었습니다. 이를 통해 타사 컴포넌트를 손상시키지 않으면 서 앱 내에서 다른 구분 기호를 사용할 수 있습니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여Vue.config.delimiters의 예를 찾으십시오. Vue.config.unsafeDelimiters 제거됨HTML 보간은 제거 되고 v-html를 사용합니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여Vue.config.unsafeDelimiters의 예를 찾으십시오. 그런 다음 도우미는 HTML 보간의 인스턴스를 찾아 `v-html`로 대체 할 수 있습니다. 전역 APIVue.extend with el 제거됨el 옵션은 Vue.extend 에서 더 이상 사용할 수 없습니다. 인스턴스 생성 옵션으로 만 유효합니다. 업그레이드 방법 업그레이드 후 엔드 투 엔드 테스트 스위트 또는 앱을 실행하고 Vue.extend를 사용하여 el 옵션에 대한 console errors를 찾습니다. Vue.elementDirective 제거됨대신 컴포넌트를 사용하세요 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여Vue.elementDirective의 예를 찾으십시오. Vue.partial 제거됨컴포넌트 간의 더 명확한 데이터 흐름을 위해 파셜이 제거되었습니다. 성능이 중요한 영역에서 파셜을 사용하지 않는한, 대신 일반 컴포넌트를 사용하는 것이 좋습니다. 동적으로 파셜의 name 바인딩하는 경우 동적 구성 요소를 사용할 수 있습니다. 앱의 성능이 중요한 부분에서 부분적으로 사용하는 경우 함수형 컴포넌트로 업그레이드 해야 합니다. 그것들은 (.vue 파일 대신에) 일반 JS/JSX 파일에 있어야하며 파셜과 마찬가지로 상태가없고 인스턴스도 없습니다. 이것은 렌더링을 매우 빠르게 만듭니다. 파셜에 비해 함수형 컴포넌트의 이점은 JavaScript의 모든 기능에 대한 액세스 권한을 부여하기 때문에 훨씬 더 동적 일 수 있다는 것입니다. 그러나 이에는 따르는 비용이 있습니다. 이전에 렌더링 기능이있는 컴포넌트를 사용한 적이 없다면 배우기까지 조금 더 시간이 걸릴 수 있습니다. 업그레이드 방법 코드베이스에서 마이그레이션 도우미를 실행하여Vue.partial의 예를 찾으십시오.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"반응형에 대해 깊이 알아보기","date":"2019-06-01T10:04:47.000Z","path":"wiki/vue/reactivity/","text":"이제 조금 더 깊게 알아볼 차례입니다. Vue의 가장 두드러진 특징 중 하나는 눈에 잘 띄지 않는 반응형 시스템입니다. 모델은 단순한 JavaScript 객체입니다. 수정하면 화면이 갱신됩니다. 스테이트 관리를 간단하고 직관적으로 만들어주지만, 몇 가지 흔한 함정을 피하려면 어떻게 작동하는지 이해하는 것도 중요합니다. 이 섹션에서는 Vue의 반응형 시스템의 세부사항을 다룹니다. Watch a video explanation on Vue Mastery ## 변경 내용을 추적하는 방법 Vue 인스턴스에 JavaScript 객체를 data 옵션으로 전달하면 Vue는 모든 속성에 Object.defineProperty를 사용하여 getter/setters로 변환합니다. 이는 Vue가 ES5를 사용할 수 없는 IE8 이하를 지원하지 않는 이유입니다. getter / setter 는 사용자에게는 보이지 않으나 속성에 액세스 하거나 수정할 때 Vue가 종속성 추적 및 변경 알림을 수행할 수 있습니다. 한가지 주의 사항은 변환된 데이터 객체가 기록될 때 브라우저가 getter / setter 형식을 다르게 처리하므로 친숙한 인터페이스를 사용하기 위해 vue-devtools를 설치하는 것이 좋습니다. 모든 컴포넌트 인스턴스에는 해당 watcher 인스턴스가 있으며, 이 인스턴스는 컴포넌트가 종속적으로 렌더링되는 동안 “수정”된 모든 속성을 기록합니다. 나중에 종속적인 setter가 트리거 되면 watcher에 알리고 컴포넌트가 다시 렌더링 됩니다. 변경 감지 경고최신 JavaScript의 한계 (그리고 Object.observe의 포기)로 인해 Vue는 속성의 추가 제거를 감지할 수 없습니다. Vue는 인스턴스 초기화 중에 getter / setter 변환 프로세스를 수행하기 때문에 data 객체에 속성이 있어야 Vue가 이를 변환하고 응답할 수 있습니다. 123456789var vm = new Vue(&#123; data: &#123; a: 1 &#125;&#125;)// `vm.a` 은 이제 반응적입니다.vm.b = 2// `vm.b` 은 이제 반응적이지 않습니다. Vue는 이미 만들어진 인스턴스에 새로운 루트 수준의 반응 속성을 동적으로 추가하는 것을 허용하지 않습니다. 그러나 Vue.set(object, key, value) 메소드를 사용하여 중첩 된 객체에 반응성 속성을 추가 할 수 있습니다. 1Vue.set(vm.someObject, 'b', 2) Vm.$set 인스턴스 메소드를 사용할 수도 있습니다. 이 메소드는 전역 Vue.set 에 대한 별칭입니다. 1this.$set(this.someObject, 'b', 2) 때로는 예를 들어 Object.assign() 또는 _.extend()를 사용하여 기존 객체에 많은 속성을 할당 할 수 있습니다. 그러나 객체에 추가 된 새 속성은 변경 내용을 트리거하지 않습니다. 이 경우 원본 객체와 mixin 객체의 속성을 사용하여 새 객체를 만듭니다. 12// `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)` 대신에this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 리스트 렌더링 섹션에 앞서 알아보아야 할 배열 관련 참고사항이 있습니다. 반응형 속성 선언하기Vue는 루트 수준의 반응성 속성을 동적으로 추가 할 수 없으므로 모든 루트 수준의 반응성 데이터 속성을 빈 값으로라도 초기에 선언하여 Vue 인스턴스를 초기화해야합니다. 123456789var vm = new Vue(&#123; data: &#123; // 빈 값으로 메시지를 선언 합니다. message: '' &#125;, template: '&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;'&#125;)// 나중에 `message`를 설정합니다.vm.message = 'Hello!' data 옵션에message를 선언하지 않으면 Vue는 렌더 함수가 존재하지 않는 속성에 접근하려고 한다는 경고를합니다. 이 제한 사항에는 기술적인 이유가 있습니다. 종속성 추적 시스템에서 엣지 케이스 클래스를 제거하고 Vue 인스턴스를 유형 검사 시스템으로 더 멋지게 만듭니다. 그러나 코드 유지 관리 측면에서도 중요한 고려 사항이 있습니다. data 객체는 컴포넌트 상태에 대한 스키마와 같습니다. 모든 반응 속성을 미리 선언하면 나중에 다시 방문하거나 다른 개발자가 읽을 때 구성 요소 코드를 더 쉽게 이해할 수 있습니다. 비동기 갱신 큐눈치채셨는지 모르겠지만, Vue는 DOM 업데이트를 비동기로 합니다. 데이터 변경이 발견 될 때마다 큐를 열고 같은 이벤트 루프에서 발생하는 모든 데이터 변경을 버퍼에 담습니다. 같은 Watcher가 여러 번 발생하면 대기열에서 한 번만 푸시됩니다. 이 버퍼링된 중복의 제거는 불필요한 계산과 DOM 조작을 피하는 데 있어 중요합니다. 그 다음, 이벤트 루프 “tick”에서 Vue는 대기열을 비우고 실제 (이미 중복 제거 된) 작업을 수행합니다. 내부적으로 Vue는 비동기 큐를 위해 네이티브 Promise.then 와 MessageChannel를 시도하고 setTimeout (fn, 0)으로 돌아갑니다. 예를 들어,vm.someData = &#39;new value&#39;를 설정하면, 컴포넌트는 즉시 재 렌더링되지 않습니다. 큐가 플러시 될 때 다음 “tick” 에서 업데이트됩니다. 대개의 경우 이 작업을 신경 쓸 필요는 없지만 업데이트 후 DOM 상태에 의존하는 작업을 수행하려는 경우 까다로울 수 있습니다. Vue.js는 일반적으로 개발자가 “데이터 중심”방식으로 생각하고 DOM을 직접 만지지 않도록 권장하지만 때로는 건드려야 할 수도 있습니다. Vue.js가 데이터 변경 후 DOM 업데이트를 마칠 때까지 기다리려면 데이터가 변경된 직후에 Vue.nextTick (콜백)을 사용할 수 있습니다. 콜백은 DOM이 업데이트 된 후에 호출됩니다. 예: 1&lt;div id=\"example\"&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; 1234567891011var vm = new Vue(&#123; el: '#example', data: &#123; message: '123' &#125;&#125;)vm.message = 'new message' // 데이터 변경vm.$el.textContent === 'new message' // falseVue.nextTick(function () &#123; vm.$el.textContent === 'new message' // true&#125;) 또한 vm.$nextTick() 인스턴스 메소드가 있습니다. 이는 내부 컴포넌트들에 특히 유용합니다. 왜냐하면 전역 Vue가 필요없고 콜백의 this 컨텍스트가 자동으로 현재 Vue 인스턴스에 바인드될 것이기 때문입니다 1234567891011121314151617Vue.component('example', &#123; template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;', data: function () &#123; return &#123; message: '갱신 안됨' &#125; &#125;, methods: &#123; updateMessage: function () &#123; this.message = '갱신됨' console.log(this.$el.textContent) // =&gt; '갱신 안됨' this.$nextTick(function () &#123; console.log(this.$el.textContent) // =&gt; '갱신됨' &#125;) &#125; &#125;&#125;) Since $nextTick() returns a promise, you can achieve the same as the above using the new ES2017 async/await syntax: 12345678methods: &#123; updateMessage: async function () &#123; this.message = 'updated' console.log(this.$el.textContent) // =&gt; 'not updated' await this.$nextTick() console.log(this.$el.textContent) // =&gt; 'updated' &#125;&#125;","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"Security","date":"2019-05-04T10:04:47.000Z","path":"wiki/vue/security/","text":"Reporting VulnerabilitiesWhen a vulnerability is reported, it immediately becomes our top concern, with a full-time contributor dropping everything to work on it. To report a vulnerability, please email vuejs.org@gmail.com. While the discovery of new vulnerabilities is rare, we also recommend always using the latest versions of Vue and its official companion libraries to ensure your application remains as secure as possible. What Vue Does to Protect YouHTML contentWhether using templates or render functions, content is automatically escaped. That means in this template: 1&lt;h1&gt;&#123;&#123; userProvidedString &#125;&#125;&lt;/h1&gt; if userProvidedString contained: 1'&lt;script&gt;alert(\"hi\")&lt;/script&gt;' then it would be escaped to the following HTML: 1&amp;lt;script&amp;gt;alert(&amp;quot;hi&amp;quot;)&amp;lt;/script&amp;gt; thus preventing the script injection. This escaping is done using native browser APIs, like textContent, so a vulnerability can only exist if the browser itself is vulnerable. Attribute bindingsSimilarly, dynamic attribute bindings are also automatically escaped. That means in this template: 123&lt;h1 v-bind:title=\"userProvidedString\"&gt; hello&lt;/h1&gt; if userProvidedString contained: 1'\" onclick=\"alert(\\'hi\\')' then it would be escaped to the following HTML: 1&amp;quot; onclick=&amp;quot;alert('hi') thus preventing the close of the title attribute to inject new, arbitrary HTML. This escaping is done using native browser APIs, like setAtttribute, so a vulnerability can only exist if the browser itself is vulnerable. Potential DangersIn any web application, allowing unsanitized, user-provided content to be executed as HTML, CSS, or JavaScript is potentially dangerous, so should be avoided wherever possible. There are times when some risk be acceptable though. For example, services like CodePen and JSFiddle allow user-provided content to be executed, but it’s in a context where this is expected and sandboxed to some extent inside iframes. In the cases when an important feature inherently requires some level of vulnerability, it’s up to your team to weigh the importance of the feature against the worst-case scenarios the vulnerability enables. Injecting HTMLAs you learned earlier, Vue automatically escapes HTML content, preventing you from accidentally injecting executable HTML into your application. However, in cases where you know the HTML is safe, you can explicitly render HTML content: Using a template: 1&lt;div v-html=\"userProvidedHtml\"&gt;&lt;/div&gt; Using a render function: 12345h('div', &#123; domProps: &#123; innerHTML: this.userProvidedHtml &#125;&#125;) Using a render function with JSX: 1&lt;div domPropsInnerHTML=&#123;this.userProvidedHtml&#125;&gt;&lt;/div&gt; Note that user-provided HTML can never be considered 100% safe unless it's in a sandboxed iframe or in a part of the app where only the user who wrote that HTML can ever be exposed to it. Additionally, allowing users to write their own Vue templates brings similar dangers. ### Injecting URLs In a URL like this: 123&lt;a v-bind:href=\"userProvidedUrl\"&gt; click me&lt;/a&gt; There’s a potential security issue if the URL has not been “sanitized” to prevent JavaScript execution using javascript:. There are libraries such as sanitize-url to help with this, but note: If you're ever doing URL sanitization on the frontend, you already have a security issue. User-provided URLs should always be sanitized by your backend before even being saved to a database. Then the problem is avoided for _every_ client connecting to your API, including native mobile apps. Also note that even with sanitized URLs, Vue cannot help you guarantee that they lead to safe destinations. ### Injecting Styles Looking at this example: 123456&lt;a v-bind:href=\"sanitizedUrl\" v-bind:style=\"userProvidedStyles\"&gt; click me&lt;/a&gt; let’s assume that sanitizedUrl has been sanitized, so that it’s definitely a real URL and not JavaScript. With the userProvidedStyles, malicious users could still provide CSS to “click jack”, e.g. styling the link into a transparent box over the “Log in” button. Then if https://user-controlled-website.com/ is built to resemble the login page of your application, they might have just captured a user’s real login information. You may be able to imagine how allowing user-provided content for a &lt;style&gt; element would create an even greater vulnerability, giving that user full control over how to style the entire page. That’s why prevents rendering of style tags inside templates, such as: 1&lt;style&gt;&#123;&#123; userProvidedStyles &#125;&#125;&lt;/style&gt; To keep your users fully safe from click jacking, we recommend only allowing full control over CSS inside a sandboxed iframe. Alternatively, when providing user control through a style binding, we recommend using its object syntax and only allowing users to provide values for specific properties it’s safe for them to control, like this: 123456789&lt;a v-bind:href=\"sanitizedUrl\" v-bind:style=\"&#123; color: userProvidedColor, background: userProvidedBackground &#125;\"&gt; click me&lt;/a&gt; Injecting JavaScriptWe strongly discourage ever rendering a &lt;script&gt; element with Vue, since templates and render functions should never have side effects. However, this isn’t the only way to include strings that would be evaluated as JavaScript at runtime. Every HTML element has attributes with values accepting strings of JavaScript, such as onclick, onfocus, and onmouseenter. Binding user-provided JavaScript to any of these event attributes is a potential security risk, so should be avoided. Note that user-provided JavaScript can never be considered 100% safe unless it's in a sandboxed iframe or in a part of the app where only the user who wrote that JavaScript can ever be exposed to it. Sometimes we receive vulnerability reports on how it's possible to do cross-site scripting (XSS) in Vue templates. In general, we do not consider such cases to be actual vulnerabilities, because there's no practical way to protect developers from the two scenarios that would allow XSS: The developer is explicitly asking Vue to render user-provided, unsanitized content as Vue templates. This is inherently unsafe and there’s no way for Vue to know the origin. The developer is mounting Vue to an entire HTML page which happens to contain server-rendered and user-provided content. This is fundamentally the same problem as #1, but sometimes devs may do it without realizing. This can lead to possible vulnerabilities where the attacker provides HTML which is safe as plain HTML but unsafe as a Vue template. The best practice is to never mount Vue on nodes that may contain server-rendered and user-provided content. Best PracticesThe general rule is that if you allow unsanitized, user-provided content to be executed (as either HTML, JavaScript, or even CSS), you might be opening yourself up to attacks. This advice actually holds true whether using Vue, another framework, or even no framework. Beyond the recommendations made above for Potential Dangers, we also recommend familiarizing yourself with these resources: HTML5 Security Cheat Sheet OWASP’s Cross Site Scripting (XSS) Prevention Cheat Sheet Then use what you learn to also review the source code of your dependencies for potentially dangerous patterns, if any of them include 3rd-party components or otherwise influence what’s rendered to the DOM. Backend CoordinationHTTP security vulnerabilities, such as cross-site request forgery (CSRF/XSRF) and cross-site script inclusion (XSSI), are primarily addressed on the backend, so aren’t a concern of Vue’s. However, it’s still a good idea to communicate with your backend team to learn how to best interact with their API, e.g. by submitting CSRF tokens with form submissions. Server-Side Rendering (SSR)There are some additional security concerns when using SSR, so make sure to follow the best practices outlined throughout our SSR documentation to avoid vulnerabilities.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"서버사이드 렌더링","date":"2019-05-03T10:04:47.000Z","path":"wiki/vue/ssr/","text":"완전한 서버사이드 렌더링(SSR) 가이드서버사이드 렌더링을 사용하는 Vue 애플리케이션을 만들기 위한 독립적인 가이드를 만들었습니다. 이는 클라이언트 Vue와 서버 측 Node.js 개발 및 웹팩에 익숙한 사람들을 위한 매우 깊이 있는 가이드입니다. ssr.vuejs.org에서 확인하세요. Nuxt.js배포 준비 완료 상태의 서버측 렌더링을 사용하는 애플리케이션을 올바르게 구성하는 것은 어려운 작업입니다. 다행히 이 모든 것을보다 쉽게하기 위한 훌륭한 커뮤니티 프로젝트가 있습니다. Nuxt.js입니다. Nuxt.js는 Vue 생태계 위에 만들어진 상위 수준의 범용 Vue 애플리케이션을 작성하는 데 매우 간소화 된 개발 환경을 제공합니다. 더 나아가 정적 사이트 생성기(단일 파일 Vue 컴포넌트로 작성된 페이지 포함)로 사용할 수도 있습니다. 한번 시도해보세요 Quasar Framework SSR + PWAQuasar Framework will generate an SSR app (with optional PWA handoff) that leverages its best-in-class build system, sensible configuration and developer extensibility to make designing and building your idea a breeze. With over one hundred specific “Material Design 2.0”-compliant components, you can decide which ones to execute on the server, which are available in the browser - and even manage the &lt;meta&gt; tags of your site. Quasar is a node.js and webpack based development environment that supercharges and streamlines rapid development of SPA, PWA, SSR, Electron and Cordova apps - all from one codebase.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"상태 관리","date":"2019-05-02T10:04:47.000Z","path":"wiki/vue/state-management/","text":"공식 Flux-유사 구현대규모 응용 프로그램은 여러 컴포넌트에 분산되어있는 여러 상태와 그 상호 작용으로 인해 복잡해집니다. 이 문제를 해결하기 위해 Vue는 Elm에서 영감을 얻은 상태 관리 라이브러리 인 vuex를 제공합니다. 또한 vue-devtools를 사용한다면 설정에 따로 시간을 보내지 않아도 시간여행 디버깅을 사용할 수 있습니다. Watch a video explanation on Vue Mastery ### React 개발자를 위한 안내 만약 당신이 React로 부터 왔다면, vuex가 그 생태계에서 가장 인기있는 Flux 구현 인 redux와 어떻게 비교되는지 궁금할 것입니다. Redux는 실제로 뷰 레이어(view-layer)에 무관하므로 몇 가지 간단한 바인딩을 해준다면 Vue에서도 Redux를 쉽게 사용할 수 있습니다. Vuex가 Redux와 다른 점이라면 Vue app에 대해서 _알고 있다_는 점입니다. 이를 통해 더 직관적인 API와 향상된 개발경험을 Vue에 통합할 수 있습니다. 간단한 상태 관리 시작하기Vue 응용 프로그램에서 가장 근본이 되는 것은 원시 data 객체라는 것을 종종 간과하게됩니다. Vue 인스턴스는 단순히 그것에 대한 액세스를 프록시합니다. 따라서 여러 인스턴스에서 공유해야하는 상태가 있으면 ID로 간단히 공유 할 수 있습니다. 123456789const sourceOfTruth = &#123;&#125;const vmA = new Vue(&#123; data: sourceOfTruth&#125;)const vmB = new Vue(&#123; data: sourceOfTruth&#125;) 이제 sourceOfTruth가 변형 될 때마다vmA와vmB가 자동으로 뷰를 갱신합니다. 이 인스턴스들 각각의 하위 컴포넌트들은this.$root.$data를 통해 접근 할 수 있습니다. 우리는 현재 단일 소스를 가지고 있지만 디버깅은 악몽 같을 것입니다. 모든 데이터는 흔적을 남기지 않고 언제든지 앱의 일부에서 변경할 수 있습니다. 이 문제를 해결하기 위해 간단한 store 패턴 을 사용할 수 있습니다. 1234567891011121314var store = &#123; debug: true, state: &#123; message: 'Hello!' &#125;, setMessageAction (newValue) &#123; if (this.debug) console.log('setMessageAction triggered with', newValue) this.state.message = newValue &#125;, clearMessageAction () &#123; if (this.debug) console.log('clearMessageAction triggered') this.state.message = '' &#125;&#125; store의 상태를 변경시키는 모든 조치는 store 자체에 들어 있습니다. 이러한 유형의 중앙 집중식 상태 관리는 어떤 유형의 돌연변이가 발생할 수 있는지, 어떻게 유발되는지를보다 쉽게 이해할 수있게 합니다. 무언가가 잘못 될 경우 버그에 이르는 일에 대한 로그가 생성됩니다. 또한 각 인스턴스 / 컴포넌트는 여전히 자체적으로 비공개 상태를 가지고 관리할 수 있습니다. 12345678910111213var vmA = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;)var vmB = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;) 액션에서 원래 상태 객체를 절대 교체하면 안된다는 점에 유의해야 합니다. 컴포넌트와 저장소는 변이를 관찰하기 위해 같은 객체에 대한 참조를 공유해야 합니다. 컴포넌트가 store에 속한 상태를 직접 변이 시킬 수 없지만 store에 조작을 수행하도록 알리는 이벤트를 보내야하는 컨벤션을 계속 개발할 때 결국 [Flux](https://facebook.github.io/flux) 아키텍처에 다다르게 됩니다. 이 컨벤션의 이점은 store에서 발생하는 모든 상태 변이를 기록하고 mutation 로그, 스냅 샷 및 히스토리 되돌리기 / 시간 여행과 같은 고급 디버깅 도우미를 구현할 수 있다는 것입니다. 이것은 우리에게 vuex에 대한 완전함을 가져다 줍니다. 이제 지금까지 읽은 것을 시험해 볼 시간입니다!","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"라우팅","date":"2019-05-01T10:04:47.000Z","path":"wiki/vue/routing/","text":"공식 라우터대부분의 단일 페이지 애플리케이션의 경우 공식적으로 지원되는 vue-router library를 사용하는 것이 좋습니다. 자세한 내용은 vue-router의 문서를 참조하십시오. 단순한 라우팅 시작하기매우 단순한 라우팅만 필요하고 완전한 기능을 갖춘 라우터 라이브러리를 사용하지 않으려면 다음과 같이 페이지 수준 컴포넌트를 동적으로 렌더링하면됩니다. 123456789101112131415161718192021const NotFound = &#123; template: '&lt;p&gt;Page not found&lt;/p&gt;' &#125;const Home = &#123; template: '&lt;p&gt;home page&lt;/p&gt;' &#125;const About = &#123; template: '&lt;p&gt;about page&lt;/p&gt;' &#125;const routes = &#123; '/': Home, '/about': About&#125;new Vue(&#123; el: '#app', data: &#123; currentRoute: window.location.pathname &#125;, computed: &#123; ViewComponent () &#123; return routes[this.currentRoute] || NotFound &#125; &#125;, render (h) &#123; return h(this.ViewComponent) &#125;&#125;) HTML5 History API와 결합하여 매우 기본적이지만 기능이 완벽한 클라이언트측 라우터를 구축할 수 있습니다. 이를 실제로 보려면 예제 앱을 확인하십시오. 써드파티 라우터 목록써드파티 라우터를 사용하기 위해서, 예를 들어 Page.js 또는 Director는 쉽습니다. 여기에 Page.js를 사용하는 완벽한 예제가 있습니다.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"프로덕션 배포 팁","date":"2019-04-04T10:04:47.000Z","path":"wiki/vue/deployment/","text":"Most of the tips below are enabled by default if you are using Vue CLI. This section is only relevant if you are using a custom build setup. 프로덕션 모드를 켜세요개발 과정에서 Vue는 일반적인 오류 및 함정을 해결하는 데 도움이 되는 많은 경고를 제공합니다. 그러나 이러한 경고 문자열은 프로덕션에서는 쓸모 없으며 앱의 페이로드 크기를 키웁니다. 또한 이러한 경고 검사 중 일부는 프로덕션 모드에서 피할 수 있는 런타임 비용이 적습니다. 빌드 도구를 사용하지 않는 경우전체 빌드를 사용하는 경우 (즉, 빌드 도구 없이 스크립트 태그를 통해 Vue를 직접 포함하는 경우) 프로덕션 환경을 위해 축소 버전(vue.min.js)을 사용해야합니다. 두가지 버전 모두 설치 안내 빌드 도구를 사용하는 경우Webpack이나 Browserify와 같은 빌드 툴을 사용할 때, 프로덕션 모드는 Vue의 소스 코드 안에있는 process.env.NODE_ENV에 의해 결정 될 것이며, 기본적으로 개발 모드가 될 것입니다. 두 빌드 도구 모두 이 변수를 덮어 쓸 수있는 방법을 제공하여 Vue의 프로덕션 모드를 사용할 수있게하고 빌드하는 동안 minifier가 경고를 제거합니다. 모든 vue-cli 템플릿에는 다음과 같은 것들이 미리 설정 되어 있습니다. 그러나 그것이 어떻게 처리되는지 아는 것은 유익할 것입니다. WebpackWebpack 4+에서는 mode 옵션을 사용할 수 있습니다. 123module.exports = &#123; mode: 'production'&#125; 하지만, Webpack 3 과 그 이전 버전에서는 DefinePlugin사용 이 필요합니다. 1234567891011var webpack = require('webpack')module.exports = &#123; // ... plugins: [ // ... new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify('production') &#125;) ]&#125; Browserify &quot;production &quot;으로 설정된 실제 NODE_ENV 환경 변수로 번들링 명령을 실행하십시오. 이렇게 하면 핫 리로드 및 개발 관련 코드가 포함되지 않도록 vueify에 알립니다. 번들에 전역 envify 변형을 적용하십시오. 이렇게하면 minifier가 env 변수 조건부 블록에 래핑 된 Vue 소스 코드의 모든 경고를 제거 할 수 있습니다. 1NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m &gt; build.js 또는 Gulp와 envify를 함께 사용할 수 있습니다. 1234567891011// envify 사용자 정의 모듈을 사용하여 환경 변수 지정var envify = require('envify/custom')browserify(browserifyOptions) .transform(vueify) .transform( // node_modules 파일을 처리하기 위해 필요합니다. &#123; global: true &#125;, envify(&#123; NODE_ENV: 'production' &#125;) ) .bundle() Or, using envify with Grunt and grunt-browserify: 123456789101112131415161718// Use the envify custom module to specify environment variablesvar envify = require('envify/custom')browserify: &#123; dist: &#123; options: &#123; // Function to deviate from grunt-browserify's default order configure: b =&gt; b .transform('vueify') .transform( // Required in order to process node_modules files &#123; global: true &#125;, envify(&#123; NODE_ENV: 'production' &#125;) ) .bundle() &#125; &#125;&#125; Rolluprollup-plugin-replace을 사용하세요. 12345678910const replace = require('rollup-plugin-replace')rollup(&#123; // ... plugins: [ replace(&#123; 'process.env.NODE_ENV': JSON.stringify( 'production' ) &#125;) ]&#125;).then(...) 사전 컴파일한 템플릿DOM 안의 템플릿 또는 JavaScript 안의 템플릿 문자열을 사용하면 템플릿에서 렌더 함수로의 컴파일이 즉시 수행됩니다. 일반적으로 대부분의 경우 속도가 빠르지만 애플리케이션이 성능에 민감한 경우에는 사용하지 않는 것이 가장 좋습니다. 템플릿을 미리 컴파일하는 가장 쉬운 방법은 싱글 파일 컴포넌트를 사용하는 것입니다. 관련 빌드 설정은 자동으로 사전 컴파일을 수행하므로 내장 코드에 원시 템플릿 문자열 대신 이미 컴파일 된 렌더링 함수가 포함되어 있습니다. Webpack을 사용하고 JavaScript 및 템플릿 파일을 분리하는 것을 선호하는 경우에 vue-template-loader를 사용하여 템플릿 파일을 JavaScript로 변환할 수 있습니다 빌드 단계 중 렌더 함수를 수행합니다. 컴포넌트의 CSS 추출하기싱글 파일 컴포넌트를 사용할 때, 컴포넌트 내부의 CSS는 JavaScript를 통해 &lt;style&gt;태그로 동적으로 삽입됩니다. 런타임 비용이 적고, 서버 측 렌더링을 사용하는 경우 “스타일이없는 내용의 깜빡임”이 발생합니다. 모든 컴포넌트에서 CSS를 같은 파일로 추출하는 것은 이러한 문제를 피할 수 있고, CSS 축소 및 캐싱을 향상시킬 수 있습니다. 이를 적용하려면 해당 빌드 도구 문서를 참조하십시오. Webpack + vue-loader (vue-cli의 webpack 템플릿은 이미 이 설정이 되어 있습니다) Browserify + vueify Rollup + rollup-plugin-vue 런타임 에러 추적하기구성 요소의 렌더링 중에 런타임 오류가 발생하면 전역 Vue.config.errorHandler config 함수로 전달됩니다. 이 훅을 공식적인 통합을 제공하는 Sentry와 같은 오류 추적 서비스와 함께 활용하면 좋습니다.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"단위 테스팅","date":"2019-04-03T10:04:47.000Z","path":"wiki/vue/unit-testing/","text":"Vue CLI 는 Jest, 혹은 Mocha 를 사용해 어려운 설정 없이 유닛테스트를 진행하기 위한 옵션이 있습니다. 커스텀 셋업의 가이드가 되는 Vue Test Utils도 있습니다. 간단한 테스트하기테스팅을 위한 코드 구성 측면에서, 특별히 추가로 해야할 작업이 없습니다. 원시 옵션들만 내보내면 됩니다. 12345678910111213141516&lt;template&gt; &lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; message: 'hello!' &#125; &#125;, created () &#123; this.message = 'bye!' &#125; &#125;&lt;/script&gt; 해당 컴포넌트를 테스트할 때 Vue와 함께 options의 객체를 Import해 테스트를 실행합니다. (여기서는 예로 Jasmine/Jest스타일의 expect어서션을 사용하고 있습니다). 1234567891011121314151617181920212223242526272829303132// Vue 및 테스트할 컴포넌트 가져오기import Vue from 'vue'import MyComponent from 'path/to/MyComponent.vue'// Jasmine 2.0 테스트는 다음과 같습니다.// 원하는 테스트 러너 / 테스트 라이브러리를 사용하십시오describe('MyComponent', () =&gt; &#123; // 원시 컴포넌트 옵션을 검사합니다. it('has a created hook', () =&gt; &#123; expect(typeof MyComponent.created).toBe('function') &#125;) // 원시 컴포넌트 옵션에서 함수 결과를 테스트합니다. it('sets the correct default data', () =&gt; &#123; expect(typeof MyComponent.data).toBe('function') const defaultData = MyComponent.data() expect(defaultData.message).toBe('hello!') &#125;) // 마운트 할 때 컴포넌트 인스턴스를 검사합니다. it('correctly sets the message when created', () =&gt; &#123; const vm = new Vue(MyComponent).$mount() expect(vm.message).toBe('bye!') &#125;) // 인스턴스를 마운트하고 출력된 결과를 검사합니다. it('renders the correct message', () =&gt; &#123; const Constructor = Vue.extend(MyComponent) const vm = new Constructor().$mount() expect(vm.$el.textContent).toBe('bye!') &#125;)&#125;) 테스트 가능한 컴포넌트 작성많은 컴포넌트 렌더링 출력은 주로 받은 props에 의해 결정됩니다. 사실, 컴포넌트의 렌더링 출력이 그 props에만 의존하는 경우 다른 전달인자를 가지는 순수한 함수의 반환 값을 검사하는 것과 마찬가지로 테스트하기가 매우 쉽습니다. 아래 예를 보십시오. 123456789&lt;template&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: ['msg'] &#125;&lt;/script&gt; propsData 옵션을 사용해 다른 props로 렌더링 출력을 지정할 수 있습니다. 123456789101112131415161718192021import Vue from 'vue'import MyComponent from './MyComponent.vue'// 렌더링 된 텍스트를 마운트하고 반환하는 헬퍼 함수function getRenderedText (Component, propsData) &#123; const Constructor = Vue.extend(Component) const vm = new Constructor(&#123; propsData: propsData &#125;).$mount() return vm.$el.textContent&#125;describe('MyComponent', () =&gt; &#123; it('renders correctly with different props', () =&gt; &#123; expect(getRenderedText(MyComponent, &#123; msg: 'Hello' &#125;)).toBe('Hello') expect(getRenderedText(MyComponent, &#123; msg: 'Bye' &#125;)).toBe('Bye') &#125;)&#125;) 비동기 업데이트 검사Vue는 DOM 업데이트를 비동기적으로 수행하기 때문에, 상태 변경으로 인한 DOM 업데이트에 대한 검사는 Vue.nextTick 콜백에서 수행해야 합니다. 1234567891011// 상태 갱신 후 생성된 HTML을 검사합니다.it('updates the rendered message when vm.message updates', done =&gt; &#123; const vm = new Vue(MyComponent).$mount() vm.message = 'foo' // DOM 변경을 검사하기 전에 상태가 변경된 후 \"tick\"을 기다립니다. Vue.nextTick(() =&gt; &#123; expect(vm.$el.textContent).toBe('foo') done() &#125;)&#125;) 우리는 다른 제약 조건 (예: 자식 컴포넌트를 무시하는 얕은 렌더링)을 사용하여 컴포넌트를 렌더링 하는 것이 훨씬 간단하고 결과를 나타낼 수 있는 공통 테스트 모음을 개발할 계획 입니다. Vue의 유닛 테스트에 관한 상세 정보는 Vue Test Utils 와 쿡북 엔트리 unit testing vue components를 확인해주세요.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"TypeScript 지원","date":"2019-04-03T10:04:47.000Z","path":"wiki/vue/typescript/","text":"Vue CLI 는 TypeScript 툴링 지원을 포함하여 제공됩니다. NPM 패키지 공식 선언A static type system can help prevent many potential runtime errors, especially as applications grow. That’s why Vue ships with official type declarations for TypeScript - not only in Vue core, but also for vue-router and vuex as well. Since these are published on NPM, and the latest TypeScript knows how to resolve type declarations in NPM packages, this means when installed via NPM, you don’t need any additional tooling to use TypeScript with Vue. 추천 설정123456789101112// tsconfig.json&#123; \"compilerOptions\": &#123; // Vue의 브라우저 지원과 같습니다. \"target\": \"es5\", // 이러면 `this`에 대한 데이터 속성에 대한 더 엄격한 추측이 가능합니다. \"strict\": true, // webpack 2 이상 또는 rollup을 사용하여 트리셰이킹을 하려면, \"module\": \"es2015\", \"moduleResolution\": \"node\" &#125;&#125; 컴포넌트 메소드에서 this의 타입 체크를 활용하려면 strict: true (또는 적어도 strict 플래그의 일부인 noImplicitThis: true)를 포함해야합니다. 그렇지 않으면 항상 any 타입으로 처리됩니다. TypeScript 컴파일러 옵션 문서에서 자세한 내용을 확인하세요 개발시 도구 활용프로젝트 생성Vue CLI 3 can generate new projects that use TypeScript. To get started: 12345# 1. Install Vue CLI, if it's not already installednpm install --global @vue/cli# 2. Create a new project, then choose the \"Manually select features\" optionvue create my-project-name 에디터 서포트TypeScript를 사용해 Vue를 개발하려면 Visual Studio Code를 사용하세요. TypeScript에 대한 기본적인 지원이 포함되어 있습니다. 싱글 파일 컴포넌트 (SFCs)를 사용하는 경우 훌륭한 Vetur extension를 사용해 TypeScript 유추를 제공합니다. 싱글 파일 컴포넌트 및 기타 많은 훌륭한 기능을 제공합니다. 또한 WebStorm은 타입스크립트와 Vue.js를 모두 지원합니다. 기본 사용법Vue 컴포넌트 옵션안에서 TypeScript를 사용하려면 Vue.component 또는 Vue.extend로 컴포넌트를 정의해야합니다. 12345678910import Vue from 'vue'const Component = Vue.extend(&#123; // 타입 유추기능 사용&#125;)const Component = &#123; // 이 방식은 타입 유추가 되지 않습니다. // TypeScript가 Vue 컴포넌트에 대한 옵션을 알 수 없기 때문입니다.&#125; 클래스 스타일 Vue 컴포넌트컴포넌트를 선언할 때 클래스 기반 API를 선호하는 경우 공식 vue-class-component 데코레이터를 사용할 수 있습니다. 1234567891011121314151617import Vue from 'vue'import Component from 'vue-class-component'// @Component 데코레이터는 클래스가 Vue 컴포넌트임을 나타냅니다.@Component(&#123; // 모든 컴포넌트 옵션이 이곳에 허용됩니다. template: '&lt;button @click=\"onClick\"&gt;Click!&lt;/button&gt;'&#125;)export default class MyComponent extends Vue &#123; // 초기 데이터는 인스턴스 속성으로 선언할 수 있습니다. message: string = 'Hello!' // 컴포넌트 메소드는 인스턴스 메소드로 선언할 수 있습니다. onClick (): void &#123; window.alert(this.message) &#125;&#125; 플러그인과 함께 사용하기 위한 타입 확장플러그인은 Vue에 전역 혹은 인스턴스 property와 컴포넌트 옵션을 추가할 수 있습니다. 이러한 경우 TypeScript에서 플러그인을 컴파일하려면 유형 선언이 필요합니다. 다행스럽게도 TypeScript에는 이미 존재하는 타입을 보충하기 위한 module augmentation이라는 기능이 있습니다. 예를 들어, instance property인 $myProperty를 string 타입으로 선언하고자 하는 경우: 1234567891011// 1. 'vue'를 보충된 타입 선언 전에 import해야 합니다.import Vue from 'vue'// 2. 보충하고자 하는 타입이 있는 파일을 지정하세요.// Vue의 constructor type은 types/vue.d.ts에 있습니다.declare module 'vue/types/vue' &#123; // 3. Vue에 보강할 내용을 선언하세요. interface Vue &#123; $myProperty: string &#125;&#125; 위의 코드를 선언 파일 형태로 (my-property.d.ts 처럼) include하면, $myProperty를 Vue 인스턴스 내에서 사용할 수 있습니다. 12var vm = new Vue()console.log(vm.$myProperty) // This should compile successfully 추가적인 전역 property나 컴포넌트 옵션을 선언할 수도 있습니다. 12345678910111213141516import Vue from 'vue'declare module 'vue/types/vue' &#123; // `VueConstructor` 인터페이스에서 // 전역 속성을 선언할 수 있습니다 interface VueConstructor &#123; $myGlobal: string &#125;&#125;// ComponentOptions는 types/options.d.ts에 선언되어 있습니다.declare module 'vue/types/options' &#123; interface ComponentOptions&lt;V extends Vue&gt; &#123; myOption?: string &#125;&#125; 위 선언들을 통해 다음과 같은 코드를 컴파일할 수 있게 됩니다. 1234567// 전역 propertyconsole.log(Vue.$myGlobal)// 추가적인 component optionvar vm = new Vue(&#123; myOption: 'Hello'&#125;) 반환 타입 어노테이팅Vue의 선언 파일의 순환 특성때문에 TypeScript는 특정 메서드의 타입을 추론하는데 어려움이 있을 수 있습니다. 이런 이유로 render와 같은 메소드와 computed의 메소드에 리턴 타입에 어노테이팅이 필요가 있습니다. 12345678910111213141516171819202122232425import Vue, &#123; VNode &#125; from 'vue'const Component = Vue.extend(&#123; data () &#123; return &#123; msg: 'Hello' &#125; &#125;, methods: &#123; // `this` 때문에 리턴 타입에 어노테이션이 필요합니다. greet (): string &#123; return this.msg + ' world' &#125; &#125;, computed: &#123; // 어노테이션 필요 greeting(): string &#123; return this.greet() + '!' &#125; &#125;, // `createElement`가 유추되었지만 `render`는 리턴 타입을 필요로 합니다. render (createElement): VNode &#123; return createElement('div', this.greeting) &#125;&#125;) 타입 유추를 찾거나 멤버 자동완성이 효과가 없다면 특정 방법에 주석을 달아 이러한 문제를 해결하는데 도움이 될 수 있습니다. --noImplicitAny 옵션을 사용하면 많은 주석을 달지 않은 메소드를 찾을 수 있습니다.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"싱글 파일 컴포넌트","date":"2019-04-01T10:04:47.000Z","path":"wiki/vue/single-file-components/","text":"소개Watch a free video lesson on Vue School 많은 Vue 프로젝트에서, 전역 컴포넌트는 `Vue.component`를 사용해 정의되고, 다음에 모든 페이지의 container 엘리먼트를 대상으로 하는 `new Vue({el: '#container'})`가 정의됩니다. 이것은 특정 뷰를 향상시키는 용도로만 사용되는 중소 규모 프로젝트에서 유용합니다. 하지만 좀 더 복잡한 프로젝트의 경우 또는 프론트엔드가 JavaScript 기반인 경우 단점이 분명해집니다. 전역 정의 모든 구성 요소에 대해 고유한 이름을 지정하도록 강요됩니다. 문자열 템플릿 구문 강조가 약해 여러 줄로 된 HTML에 보기 안좋은 슬래시가 많이 필요합니다. CSS 지원 없음 HTML 및 JavaScript가 컴포넌트로 모듈화 되어 있으나 CSS가 빠져 있는 것을 말합니다. 빌드 단계 없음 Pug (이전의 Jade) 및 Babel과 같은 전처리기가 아닌 HTML 및 ES5 JavaScript로 제한됩니다. 위 모든 것들은 Webpack 또는 Browserify와 같은 빌드 도구를 이용해 .vue 확장자를 가진 싱글 파일 컴포넌트 로 해결 됩니다. 다음은 Hello.vue 파일의 간단한 예입니다. 이제 우리는 할 수 있습니다: 완전한 구문 강조 CommonJS 모듈 컴포넌트에만 제한된 CSS 약속대로 Jade, Babel (ES2015 모듈을 포함합니다), Stylus와 같은 전처리기를 사용해 더 깨끗하고 기능이 풍부한 컴포넌트를 사용할 수 있습니다. 이러한 특정 언어는 예제일 뿐입니다. Bublé, TypeScript, SCSS, PostCSS 또는 생산성 향상에 도움을 주는 다른 전처리기를 쉽게 사용할 수 있습니다. Webpack을 vue-loader와 함께 사용하면 CSS 모듈에 대한 1등급 클래스를 지원합니다. 관심사의 분리는 무엇입니까?주목해야 할 중요한 점은 관심사 분리가 파일 타입 분리와 같지 않다는 것입니다. 현대적인 UI 개발에서 코드베이스를 서로 얽혀있는 세 개의 거대한 레이어로 나누는 대신, 느슨하게 결합 된 컴포넌트로 나누고 구성하는 것이 더 중요합니다. 컴포넌트 내부에서 템플릿, 로직 및 스타일이 본질적으로 결합되어 배치되면 컴포넌트의 응집력과 유지 보수성이 향상됩니다. 싱글 파일 컴포넌트에 대한 아이디어가 마음에 들지 않더라도 JavaScript와 CSS를 별도의 파일로 분리하여 핫 리로드 및 사전 컴파일 기능을 활용할 수 있습니다. 123456&lt;!-- my-component.vue --&gt;&lt;template&gt; &lt;div&gt;이 곳은 사전에 컴파일 됩니다.&lt;/div&gt;&lt;/template&gt;&lt;script src=\"./my-component.js\"&gt;&lt;/script&gt;&lt;style src=\"./my-component.css\"&gt;&lt;/style&gt; 시작하기예제 샌드박스지금 당장 싱글 파일 컴포넌트를 사용하고 싶다면 CodeSandbox의 단순한 할일 앱을 확인하세요. JavaScript에서 모듈 빌드 시스템을 처음 사용하는 사용자를 위한 내용.vue 컴포넌트로, 우리는 진보한 JavaScript 영역에 들어서고 있습니다. 약간의 아직 배우지 않은 추가 도구 사용방법을 배워야 합니다. Node Package Manager (NPM) : 시작 안내서에서 어떻게 레지스트리에서 패키지를 가져오는지 읽어보세요. ES2015/16를 사용하는 최신 JavaScript : Babel의 ES2015 교육 가이드를 읽어보세요. 지금 당장 모든 기능을 외울 필요는 없으나 이 페이지는 언제든지 다시 볼 수 있도록 가지고 계세요. 위 내용을 얻으려면 하루정도 걸립니다. 이 후에 Vue CLI 3 를 확인하는 것을 추천합니다. 설명을 따라 가면 .vue 컴포넌트, ES2015 및 핫 리로드가 포함된 Vue 프로젝트를 즉시 사용할 수 있게 됩니다. 템플릿은 여러 “모듈”을 가져와 최종 응용프로그램에 묶는 모듈 번들러인 Webpack을 사용합니다. Webpack 자체에 대한 자세한 내용을 보려면 이 동영상에서 좋은 소개를 볼 수 있습니다. 일단 기본을 익히면 Egghead.io의 고급 Webpack 코스과 Webpack Academy를 확인하십시오. 고급 사용자를 위한 내용The CLI takes care of most of the tooling configurations for you, but also allows fine-grained customization through its own config options. In case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with vue-loader. To learn more about webpack itself, check out their official docs and Webpack Academy.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"필터","date":"2019-03-05T10:04:47.000Z","path":"wiki/vue/filters/","text":"Vue는 텍스트 형식화를 적용할 수 있는 필터를 지원합니다. 이 필터들은 중괄호 보간법 혹은 v-bind표현법 을 이용할 때 사용가능합니다. (v-bind 표현법에서는 2.1.0+ 부터 사용 가능합니다.) 필터는 자바스크립트 표현식 마지막에 “파이프”심볼과 함께 추가되어야 합니다. 12345&lt;!-- 중괄호 보간법 --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- v-bind 표현 --&gt;&lt;div v-bind:id=\"rawId | formatId\"&gt;&lt;/div&gt; 컴포넌트 옵션에서 로컬 필터를 정의할 수 있습니다. 1234567filters: &#123; capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;&#125; 또는 다음과 같이 Vue 인스턴스를 생성하기 전에 전역 필터를 정의할 수 있습니다. 123456789Vue.filter('capitalize', function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1)&#125;)new Vue(&#123; // ...&#125;) When the global filter has the same name as the local filter, the local filter will be preferred. 아래는 capitalize를 사용한 예제입니다. {{ message | capitalize }} new Vue({ el: '#example_1', data: function () { return { message: 'john' } }, filters: { capitalize: function (value) { if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) } } }) 필터의 함수는 항상 첫 번째 전달인자로 표현식의 값(이전 체이닝의 결과)을 받습니다. 위 예제에서, capitalize 필터 함수는 message의 값을 전달인자로받습니다. 필터는 체이닝 할 수 있습니다. 1&#123;&#123; message | filterA | filterB &#125;&#125; 위와 같은 경우에, 하나의 인수를 받는 filterA는 message값을 받을 것이고 filterA가 message와 함께 실행된 결과가 filterB에 넘겨질 것입니다. 필터는 기본적으로 자바스크립트 함수이기 때문에 두개 이상의 인수를 받을 수 있습니다. 1&#123;&#123; message | filterA('arg1', arg2) &#125;&#125; 여기서 filterA는 세개의 인수를 받는 함수로 정의되었습니다. message의 값은 첫번째 인수로 전달될 것이며, 순수 문자열인 &#39;arg1&#39;은 두번째 인수로 전달될 것이며, 자바스크립트 표현식인 arg2는 표현식이 실행된 이후에 세번째 인수로 전달될 것입니다.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"플러그인","date":"2019-03-04T10:04:47.000Z","path":"wiki/vue/plugins/","text":"플러그인은 일반적으로 전역 수준 기능을 Vue에 추가합니다. 플러그인에는 엄격하게 정의된 범위는 없습니다. 일반적으로 작성할 수있는 플러그인에는 여러 유형이 있습니다. 약간의 전역 메소드 또는 속성 추가 예. vue-custom-element 하나 이상의 글로벌 에셋 추가 : 디렉티브 / 필터 / 트랜지션 등. vue-router 글로벌 mixin으로 일부 컴포넌트 옵션을 추가하십시오. 예. vuex Vue.prototype에 Vue 인스턴스 메소드를 연결하여 Vue 인스턴스 메소드를 추가하십시오. 가지고 있는 API를 제공하면서 동시에 위의 일부 조합을 주입하는 라이브러리. 예. vue-router 플러그인 사용하기Vue.use() 글로벌 메소드를 호출하여 플러그인을 사용하십시오. 123456// `MyPlugin.install(Vue)` 호출Vue.use(MyPlugin)new Vue(&#123; //... options&#125;) 선택적으로 몇 가지 옵션을 전달할 수 있습니다. 1Vue.use(MyPlugin, &#123; someOption: true &#125;) Vue.use는 자동으로 같은 플러그인을 두 번 이상 사용하지 못하기 때문에 같은 플러그인에서 여러 번 호출하면 플러그인이 한 번만 설치됩니다. vue-router와 같은 Vue.js 공식 플러그인이 제공하는 일부 플러그인은Vue가 전역 변수로 사용 가능한 경우 자동으로Vue.use()를 호출합니다. 그러나 CommonJS와 같은 모듈 환경에서는 항상Vue.use()를 명시 적으로 호출해야합니다 : 123456// Browserify 또는 Webpack을 통해 CommonJS를 사용할 때var Vue = require('vue')var VueRouter = require('vue-router')// 잊지 마세요Vue.use(VueRouter) 커뮤니티에서 기여한 많은 플러그인 및 라이브러리 컬렉션을 awesome-vue에서 확인하세요. 플러그인 작성하기Vue.js 플러그인은install 메소드를 노출해야합니다. 이 메소드는 첫 번째 인자로 Vue 생성자와 함께 가능한 옵션과 함께 호출 될 것입니다. 123456789101112131415161718192021222324252627MyPlugin.install = function (Vue, options) &#123; // 1. 전역 메소드 또는 속성 추가 Vue.myGlobalMethod = function () &#123; // 필요한 로직 ... &#125; // 2. 전역 에셋 추가 Vue.directive('my-directive', &#123; bind (el, binding, vnode, oldVnode) &#123; // 필요한 로직 ... &#125; ... &#125;) // 3. 컴포넌트 옵션 주입 Vue.mixin(&#123; created: function () &#123; // 필요한 로직 ... &#125; ... &#125;) // 4. 인스턴스 메소드 추가 Vue.prototype.$myMethod = function (methodOptions) &#123; // 필요한 로직 ... &#125;&#125;","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"Render Functions & JSX","date":"2019-03-03T10:04:47.000Z","path":"wiki/vue/render-function/","text":"기본Vue는 템플릿을 사용하여 대다수의 경우 HTML을 작성할 것을 권장합니다. 그러나 JavaScript가 완전히 필요한 상황이 있습니다. 바로 여기에서 템플릿에 더 가까운 컴파일러인 render 함수를 사용할 수 있습니다. render 함수가 실용적 일 수있는 간단한 예제를 살펴 보겠습니다. 링크를 포함한 헤더를 생성한다고 가정한 예제 입니다. 12345&lt;h1&gt; &lt;a name=\"hello-world\" href=\"#hello-world\"&gt; Hello world! &lt;/a&gt;&lt;/h1&gt; 위의 HTML의 경우 이 컴포넌트 인터페이스가 필요하다고 결정합니다. 1&lt;anchored-heading :level=\"1\"&gt;Hello world!&lt;/anchored-heading&gt; level prop를 기반으로 방금 제목을 생성하는 컴포넌트를 이용하면 다음과 같이 빠르게 만들 수 있습니다. 1234567891011121314151617181920&lt;script type=\"text/x-template\" id=\"anchored-heading-template\"&gt; &lt;h1 v-if=\"level === 1\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h1&gt; &lt;h2 v-else-if=\"level === 2\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h2&gt; &lt;h3 v-else-if=\"level === 3\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h3&gt; &lt;h4 v-else-if=\"level === 4\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h4&gt; &lt;h5 v-else-if=\"level === 5\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h5&gt; &lt;h6 v-else-if=\"level === 6\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h6&gt;&lt;/script&gt; 123456789Vue.component('anchored-heading', &#123; template: '#anchored-heading-template', props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) 이 템플릿은 별로 좋지 않습니다. 이것은 장황할 뿐만 아니라 모든 헤딩 수준에 대해 &lt;slot&gt; &lt;/slot&gt;을 중복으로 가지고 있으며 앵커 엘리먼트를 추가 할 때도 똑같이 해야합니다. 템플릿은 대부분의 컴포넌트에서 훌륭하게 작동하지만 분명하지는 않습니다. 이제 render 함수로 다시 작성해 봅니다. 1234567891011121314Vue.component('anchored-heading', &#123; render: function (createElement) &#123; return createElement( 'h' + this.level, // 태그 이름 this.$slots.default // 자식의 배열 ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) 훨씬 간단 합니다! 이 코드는 더 짧지만 Vue 인스턴스 속성에 더 익숙해야합니다. 이 경우 anchored-heading 안에 Hello world!와 같이 slot 속성 없이 자식을 패스 할 때 그 자식들은 $slots.default 에있는 컴포넌트 인스턴스에 저장된다는 것을 알아야합니다. 아직 구현하지 않았다면 render 함수로 들어가기 전에 instance properties API를 읽는 것이 좋습니다. 노드, 트리, 그리고 버추얼 DOM렌더 함수를 알아보기 전에 브라우저 작동 방식을 알아야합니다. 아래 HTML 예제를 보세요 12345&lt;div&gt; &lt;h1&gt;My title&lt;/h1&gt; Some text content &lt;!-- TODO: Add tagline --&gt;&lt;/div&gt; 브라우저가 이 코드를 읽게 되면, 모든 내용을 추적하기 위해 가계도처럼 “DOM 노드” 트리를 만듭니다. 위 HTML의 DOM 노드 트리는 아래와 같습니다. 모든 엘리먼트는 노드입니다. 각 텍스트도 노드입니다. 심지어 주석도 노드입니다! 노드는 페이지를 이루는 각각의 조각입니다. 그리고 트리에서 보듯 각 노드는 자식을 가질 수 있습니다. (즉, 각 조각들은 다른 조각들을 포함할 수 있습니다.) 노드를 효율적으로 갱신하는 것은 어렵지만 수동으로 할 필요는 없습니다. 템플릿에서 Vue가 페이지에서 수정하기 원하는 HTML만 지정하면 됩니다. 1&lt;h1&gt;&#123;&#123; blogTitle &#125;&#125;&lt;/h1&gt; 또는 렌더 함수에서 123render: function (createElement) &#123; return createElement('h1', this.blogTitle)&#125; 두가지 경우 모두 Vue는 페이지를 자동으로 갱신합니다. blogTitle의 변경 또한 마찬가지입니다. 버추얼 DOMVue는 실제 DOM에 필요한 변경사항을 추적하기 위해 virtual DOM을 만듭니다. 이를 자세히 살펴보면 아래와 같습니다. 1return createElement('h1', this.blogTitle) createElement는 실제로 무엇을 반환할까요? 실제 DOM 엘리먼트와 정확하게 일치하지는 않습니다. Vue에게 자식노드에 대한 설명을 포함하여 페이지에서 렌더링해야하는 노드의 종류를 설명하는 정보를 포함하기 때문에 더 정확하게 createNodeDescription이라는 이름을 지정할 수 있습니다. 이 노드에 관한 설명을 VNode로 축약된 가상 노드라고 부릅니다. “버추얼 DOM”은 Vue 컴포넌트 트리로 만들어진 VNode 트리입니다. createElement 전달인자다음으로 살펴볼 것은 createElement 함수에서 템플릿 기능을 사용하는 방법입니다. 다음은 createElement가 받아들이는 전달인자입니다. 123456789101112131415161718192021222324252627// @returns &#123;VNode&#125;createElement( // &#123;String | Object | Function&#125; // HTML 태그 이름, 컴포넌트 옵션 또는 함수 중 // 하나를 반환하는 함수입니다. 필수 사항. 'div', // &#123;Object&#125; // 템플릿에서 사용할 속성에 해당하는 데이터 객체입니다 // 데이터 객체입니다. 선택 사항. &#123; // (아래 다음 섹션에 자세히 설명되어 있습니다.) &#125;, // &#123;String | Array&#125; // VNode 자식들. `createElement()`를 사용해 만들거나, // 간단히 문자열을 사용해 'text VNodes'를 얻을 수 있습니다. 선택사항 [ 'Some text comes first.', createElement('h1', 'A headline'), createElement(MyComponent, &#123; props: &#123; someProp: 'foobar' &#125; &#125;) ]) 데이터 객체 깊이 알아 보기한가지 주의 해야 할 점은 v-bind:class 와 v-bind:style이 템플릿에서 특별한 처리를 하는 것과 비슷하게, VNode 데이터 객체에 최상위 필드가 있습니다. 이 객체는innerHTML과 같은 DOM 속성뿐 아니라 일반적인 HTML 속성도 바인딩 할 수 있게 합니다.(이것은v-html 디렉티브를 대신해 사용할 수 있습니다.) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&#123; // `v-bind:class` 와 같음 // accepting either a string, object, or array of strings and objects. class: &#123; foo: true, bar: false &#125;, // `v-bind:style` 와 같음 // accepting either a string, object, or array of objects. style: &#123; color: 'red', fontSize: '14px' &#125;, // 일반 HTML 속성 attrs: &#123; id: 'foo' &#125;, // 컴포넌트 props props: &#123; myProp: 'bar' &#125;, // DOM 속성 domProps: &#123; innerHTML: 'baz' &#125;, // `v-on:keyup.enter`와 같은 수식어가 지원되지 않으나 // 이벤트 핸들러는 `on` 아래에 중첩됩니다. // 수동으로 핸들러에서 keyCode를 확인해야 합니다. on: &#123; click: this.clickHandler &#125;, // 컴포넌트 전용. // `vm.$emit`를 사용하여 컴포넌트에서 발생하는 이벤트가 아닌 // 기본 이벤트를 받을 수 있게 합니다. nativeOn: &#123; click: this.nativeClickHandler &#125;, // 사용자 지정 디렉티브. // Vue는 이를 관리하기 때문에 바인딩의 oldValue는 설정할 수 없습니다. directives: [ &#123; name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: &#123; bar: true &#125; &#125; ], // 범위 지정 슬롯. 형식은 // &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; 입니다. scopedSlots: &#123; default: props =&gt; createElement('span', props.text) &#125;, // 이 컴포넌트가 다른 컴포넌트의 자식인 경우, 슬롯의 이름입니다. slot: 'name-of-slot', // 기타 최고 레벨 속성 key: 'myKey', ref: 'myRef', // If you are applying the same ref name to multiple // elements in the render function. This will make `$refs.myRef` become an // array refInFor: true&#125; 전체 예제이 지식과 함께 이제 컴포넌트를 마칠 수 있습니다. 1234567891011121314151617181920212223242526272829303132333435var getChildrenTextContent = function (children) &#123; return children.map(function (node) &#123; return node.children ? getChildrenTextContent(node.children) : node.text &#125;).join('')&#125;Vue.component('anchored-heading', &#123; render: function (createElement) &#123; // kebabCase id를 만듭니다. var headingId = getChildrenTextContent(this.$slots.default) .toLowerCase() .replace(/\\W+/g, '-') .replace(/(^-|-$)/g, '') return createElement( 'h' + this.level, [ createElement('a', &#123; attrs: &#123; name: headingId, href: '#' + headingId &#125; &#125;, this.$slots.default) ] ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) 제약사항VNodes는 고유해야 합니다컴포넌트 트리의 모든 VNode는 고유 해야 합니다. 아래 예제는 다음 렌더링 함수가 유효하지 않음을 의미합니다. 1234567render: function (createElement) &#123; var myParagraphVNode = createElement('p', 'hi') return createElement('div', [ // 이런 - Vnode가 중복입니다! myParagraphVNode, myParagraphVNode ])&#125; 같은 엘리먼트 / 컴포넌트를 여러 번 복제하려는 경우 팩토리 기능을 사용하여 여러 번 반복 할 수 있습니다. 예를 들어, 다음 렌더링 함수는 20개의 같은 p태그를 완벽하게 렌더링하는 방법입니다. 1234567render: function (createElement) &#123; return createElement('div', Array.apply(null, &#123; length: 20 &#125;).map(function () &#123; return createElement('p', 'hi') &#125;) )&#125; 템플릿 기능을 일반 JavaScript로 변경하기v-if 와 v-for일반 JavaScript를 사용할 수 있는 환경이면 어디든지 Vue 렌더링 함수는 한가지 방법만을 제공하지는 않습니다. 예를 들어,v-if와v-for를 사용하는 템플릿에서 : 1234&lt;ul v-if=\"items.length\"&gt; &lt;li v-for=\"item in items\"&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No items found.&lt;/p&gt; 이것은 render 함수에서 if /else 와 map을 사용하여 재 작성 될 수 있습니다. 12345678910props: ['items'],render: function (createElement) &#123; if (this.items.length) &#123; return createElement('ul', this.items.map(function (item) &#123; return createElement('li', item.name) &#125;)) &#125; else &#123; return createElement('p', 'No items found.') &#125;&#125; v-model렌더 함수에는 직접적으로 v-model에 대응되는 것이 없습니다. 직접 구현해야합니다. 1234567891011121314props: ['value'],render: function (createElement) &#123; var self = this return createElement('input', &#123; domProps: &#123; value: self.value &#125;, on: &#123; input: function (event) &#123; self.$emit('input', event.target.value) &#125; &#125; &#125;)&#125; 이것은 더 깊은 수준으로 건드려야 하지만 v-model에 비해 상호 작용에 대한 세부 사항을 훨씬 더 많이 제어 할 수 있습니다. 이벤트 및 키 수식어.passive, .capture 및 .once 이벤트 수식어를 위해 Vue는 on과 함께 사용할 수있는 접두사를 제공합니다 수식어 접두어 .passive &amp; .capture ! .once ~ .capture.once 또는.once.capture ~! 예제 12345on: &#123; '!click': this.doThisInCapturingMode, '~keyup': this.doThisOnce, '~!mouseover': this.doThisOnceInCapturingMode&#125; 다른 모든 이벤트 및 키 수식어의 경우 처리기에서 이벤트 메서드를 간단하게 사용할 수 있으므로 고유한 접두사는 필요하지 않습니다. 수식어 동등한 핸들러 .stop event.stopPropagation() .prevent event.preventDefault() .self if (event.target !== event.currentTarget) return 키:.enter, .13 if (event.keyCode !== 13) return (13을 다른 키 수식어의 다른 키 코드로 변경합니다.) Modifiers Keys:.ctrl, .alt, .shift, .meta if (!event.ctrlKey) return (ctrlKey를 altKey, shiftKey 또는 metaKey로 각각 변경하십시오.) 다음은 위의 수식어들이 사용된 예제 입니다. 12345678910111213141516on: &#123; keyup: function (event) &#123; // 이벤트를 내보내는 요소가 이벤트가 바인딩 된 요소가 아닌 경우 // 중단합니다. if (event.target !== event.currentTarget) return // 키보드에서 뗀 키가 Enter키 (13)이 아니며 // Shift키가 동시에 눌러지지 않은 경우 // 중단합니다. if (!event.shiftKey || event.keyCode !== 13) return // 전파를 멈춥니다. event.stopPropagation() // 엘리먼트 기본 동작을 방지합니다. event.preventDefault() // ... &#125;&#125; Slotsthis.$slots에서 정적 슬롯 내용을 VNodes의 배열로 접근할 수 있습니다. 1234render: function (createElement) &#123; // `&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;` return createElement('div', this.$slots.default)&#125; 또한 특정 범위를 가지는 슬롯 this.$scopedSlots에서 VNode를 반환하는 함수로 접근할 수 있습니다. 123456789props: ['message'],render: function (createElement) &#123; // `&lt;div&gt;&lt;slot :text=\"message\"&gt;&lt;/slot&gt;&lt;/div&gt;` return createElement('div', [ this.$scopedSlots.default(&#123; text: this.message &#125;) ])&#125; 범위 함수 슬롯을 렌더링 함수를 사용하여 하위 컴포넌트로 전달하려면 VNode 데이터에서 scopedSlots 필드를 사용하십시오. 12345678910111213render: function (createElement) &#123; return createElement('div', [ createElement('child', &#123; // 데이터 객체의 `scopedSlots`를 다음 형식으로 전달합니다 // &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: function (props) &#123; return createElement('span', props.text) &#125; &#125; &#125;) ])&#125; JSXrender 함수를 많이 작성하면 다음과 같이 작성하는 것이 고통스럽게 느껴질 수 있습니다. 12345678910createElement( 'anchored-heading', &#123; props: &#123; level: 1 &#125; &#125;, [ createElement('span', 'Hello'), ' world!' ]) 템플릿 버전이 아래 처럼 너무 간단한 경우에 특히 더 그럴 것 입니다. 123&lt;anchored-heading :level=\"1\"&gt; &lt;span&gt;Hello&lt;/span&gt; world!&lt;/anchored-heading&gt; 그래서 Vue와 JSX를 함께 사용하기 위해 Babel plugin를 이용할 수 있습니다. 123456789101112import AnchoredHeading from './AnchoredHeading.vue'new Vue(&#123; el: '#demo', render: function (h) &#123; return ( &lt;AnchoredHeading level=&#123;1&#125;&gt; &lt;span&gt;Hello&lt;/span&gt; world! &lt;/AnchoredHeading&gt; ) &#125;&#125;) `createElement`를 별칭 `h`로 이용하는 것은 Vue 생태계에서 볼 수 있는 공통된 관습이며 실제로 JSX에 필요합니다. Starting with [version 3.4.0](https://github.com/vuejs/babel-plugin-transform-vue-jsx#h-auto-injection) of the Babel plugin for Vue, we automatically inject `const h = this.$createElement` in any method and getter (not functions or arrow functions), declared in ES2015 syntax that has JSX, so you can drop the `(h)` parameter. With prior versions of the plugin, your app would throw an error if `h` was not available in the scope. 사용하는 범위에서 `h`를 사용할 수 없다면, 앱은 오류를 발생시킵니다. JSX가 JavaScript에 매핑되는 방법에 대한 [자세한 내용](https://github.com/vuejs/jsx#installation)을 확인하세요. 함수형 컴포넌트앞에 작성한 anchor를 가지는 heading 컴포넌트는 비교적 간단합니다. 어떤 상태도 없고 전달된 상태를 감시하며 라이프사이클 관련 메소드도 없습니다. 실제로 단지 props를 가지는 기능일 뿐입니다. 이와 같은 경우, 컴포넌트를 함수형 또는 기능적으로 표시할 수 있습니다. 즉, 컴포넌트가 상태가 없고(data 없음) 인스턴스 화 되지 않은 경우(this 컨텍스트가 없음)를 말합니다. 함수형 컴포넌트 는 다음과 같습니다. 123456789101112Vue.component('my-component', &#123; functional: true, // Props는 선택사항입니다. props: &#123; // ... &#125; // 인스턴스의 부족함을 보완하기 위해 // 이제 2번째에 컨텍스트 인수가 제공됩니다. render: function (createElement, context) &#123; // ... &#125;,&#125;) 주의 : 2.3.0 이전 버전에서, 함수형 컴포넌트에서 props을 받아들이려면 props 옵션이 필요합니다. 2.3.0 이상에서는 props 옵션을 생략할 수 있으며, 컴포넌트 노드에서 발견된 모든 속성은 암시적으로 props으로 추출됩니다. The reference will be HTMLElement when used with functional components because they’re stateless and instanceless. 2.5.0+ 이후로, 싱글 파일 컴포넌트를 사용하는 경우, 템플릿 기반의 함수형 컴포넌트를 정의할 수 있습니다. 12&lt;template functional&gt;&lt;/template&gt; context를 통해 컴포넌트에서 필요한 모든 것이 전달 됩니다. 이 객체는 다음을 포함합니다. props: 전달받은 props에 대한 객체 children: VNode 자식의 배열 slots: 슬롯 객체를 반환하는 함수 scopedSlots: (2.6.0+) An object that exposes passed-in scoped slots. Also exposes normal slots as functions. data: 컴포넌트에 전달된 전체 데이터 객체 parent: 상위 컴포넌트에 대한 참조 listeners: (2.3.0+) 부모에게 등록된 이벤트 리스너를 가진 객체입니다. data.on의 알리아스입니다. injections: (2.3.0+) inject 옵션을 사용하면 리졸브드 인젝션을 가집니다 functional:true를 추가한 후 anchor를 가지는 heading 컴포넌트의 렌더 함수를 업데이트 하는 것은 단순히 context 전달인자를 추가하고 this.$slots.default를 context.children으로 갱신한 다음 this.level을 context.props.level로 갱신하면 됩니다. 함수형 컴포넌트는 단지 함수일 뿐이므로 렌더링에 들어가는 비용이 적습니다. 그러나 Vue 크롬 개발자 도구의 컴포넌트 트리에서 함수형 컴포넌트를 볼 수 없습니다. 또한 래퍼 컴포넌트로도 매우 유용합니다. 예를 들어, 1234567891011121314151617181920212223242526272829303132var EmptyList = &#123; /* ... */ &#125;var TableList = &#123; /* ... */ &#125;var OrderedList = &#123; /* ... */ &#125;var UnorderedList = &#123; /* ... */ &#125;Vue.component('smart-list', &#123; functional: true, props: &#123; items: &#123; type: Array, required: true &#125;, isOrdered: Boolean &#125;, render: function (createElement, context) &#123; function appropriateListComponent () &#123; var items = context.props.items if (items.length === 0) return EmptyList if (typeof items[0] === 'object') return TableList if (context.props.isOrdered) return OrderedList return UnorderedList &#125; return createElement( appropriateListComponent(), context.data, context.children ) &#125;&#125;) 자식 요소/컴포넌트에 속성과 이벤트 전달하기On normal components, attributes not defined as props are automatically added to the root element of the component, replacing or intelligently merging with any existing attributes of the same name. Functional components, however, require you to explicitly define this behavior: 1234567Vue.component('my-functional-button', &#123; functional: true, render: function (createElement, context) &#123; // Transparently pass any attributes, event listeners, children, etc. return createElement('button', context.data, context.children) &#125;&#125;) By passing context.data as the second argument to createElement, we are passing down any attributes or event listeners used on my-functional-button. It’s so transparent, in fact, that events don’t even require the .native modifier. If you are using template-based functional components, you will also have to manually add attributes and listeners. Since we have access to the individual context contents, we can use data.attrs to pass along any HTML attributes and listeners (the alias for data.on) to pass along any event listeners. 123456789&lt;template functional&gt; &lt;button class=\"btn btn-primary\" v-bind=\"data.attrs\" v-on=\"listeners\" &gt; &lt;slot/&gt; &lt;/button&gt;&lt;/template&gt; slots() vs children왜 slots()와 children을 모두 사용 해야 하는지 궁금할 수 있습니다. slots().default는 children과 같지 않나요? 어떤 경우에는 그렇습니다. 그러나 다음 자식들과 함께 함수형 컴포넌트를 가지고 있다면 어떻게 될까요? 123456&lt;my-functional-component&gt; &lt;p v-slot:foo&gt; first &lt;/p&gt; &lt;p&gt;second&lt;/p&gt;&lt;/my-functional-component&gt; 이 컴포넌트의 경우 children은 두개의 단락을 제공할 것이고 slots().default는 오직 두번째 단락을 반환합니다. 따라서 children과 slots()을 모두 사용하면 컴포넌트가 슬롯 시스템에 대해 알고 있는지 또는 단순하게 children을 전달하여 다른 컴포넌트에 책임을 위임할 지 선택할 수 있습니다. 템플릿 컴파일Vue의 템플릿이 실제로 함수를 렌더링 하기 위해 컴파일 되는 것을 알고 싶을 것입니다. 이는 일반적으로 알 필요가 없는 내부 구현 사항이지만 특정 템플릿 기능을 컴파일 하는 방법을 보고 싶다면 흥미로울 수 있습니다. 다음은 Vue.compile을 사용해 템플릿 문자열을 실시간 컴파일 하는데 사용되는 데모 입니다.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"사용자 지정 디렉티브","date":"2019-03-02T10:04:47.000Z","path":"wiki/vue/custom-directive/","text":"시작Watch a free video lesson on Vue School Vue는 코어에 포함된 기본 디렉티브 세트(`v-model`과 `v-show`) 외에도 사용자 정의 디렉티브를 등록할 수 있습니다. Vue 2.0에서 코드 재사용 및 추상화의 기본 형식은 컴포넌트 입니다. 그러나 일반 엘리먼트에 하위 수준의 DOM 액세스가 필요한 경우가 있을 수 있으며 이 경우 사용자 지정 디렉티브가 여전히 유용할 수 있습니다. 다음은 input 엘리먼트와 focusing에 대한 예제입니다. Vue.directive('focus', { inserted: function (el) { el.focus() } }) new Vue({ el: '#simplest-directive-example' }) 페이지가 로드되면 해당 엘리먼트는 포커스를 얻습니다. (참고: autofocus는 모바일 사파리에서 작동하지 않습니다.) 사실, 이 페이지를 방문한 이후 다른것을 클릭하지 않았다면 이 input 엘리먼트에 포커스가 되어 있어야 합니다.(참고: 모바일 사파리에서는 작동하지 않습니다.) 이제 이 작업을 수행하는 디렉티브를 작성하겠습니다. 12345678// 전역 사용자 정의 디렉티브 v-focus 등록Vue.directive('focus', &#123; // 바인딩 된 엘리먼트가 DOM에 삽입되었을 때... inserted: function (el) &#123; // 엘리먼트에 포커스를 줍니다 el.focus() &#125;&#125;) 지시어를 로컬로 등록하기 위해서 컴포넌트는 directives 옵션을 허용합니다. 12345678directives: &#123; focus: &#123; // 디렉티브 정의 inserted: function (el) &#123; el.focus() &#125; &#125;&#125; 그런 다음 템플릿에서 다음과 같이 모든 요소에서 새로운 v-focus 속성을 사용할 수 있습니다. 1&lt;input v-focus&gt; 훅 함수디렉티브 정의 객체는 여러가지 훅 함수를 제공할 수 있습니다.(모두 선택사항입니다.) bind: 디렉티브가 처음 엘리먼트에 바인딩 될 때 한번만 호출 됩니다. 이곳에서 일회성 설정을 할 수 있습니다. inserted: 바인딩 된 엘리먼트가 부모 노드에 삽입 되었을 때 호출 됩니다. (이것은 부모 노드 존재를 보장하며 반드시 document 내에 있는 것은 아닙니다.) update: 포함하는 컴포넌트가 업데이트 된 후 호출됩니다. 그러나 자식이 업데이트 되기 전일 가능성이 있습니다 디렉티브의 값은 변경되었거나 변경되지 않았을 수 있지만 바인딩의 현재 값과 이전 값을 비교하여 불필요한 업데이트를 건너 뛸 수 있습니다. (아래의 훅 전달인자를 참조하세요) We'll cover VNodes in more detail [later](./render-function.html#The-Virtual-DOM), when we discuss [render functions](./render-function.html). - `componentUpdated`: 포함하고 있는 컴포넌트와 __그 자식들__ 이 업데이트 된 후에 호출됩니다. - `unbind`: 디렉티브가 엘리먼트로부터 언바인딩된 경우에만 한번 호출됩니다. 다음 섹션에서 이 훅으로 전달된 인자 (예: binding, vnode 및 oldVnode)를 살펴 보겠습니다. 디렉티브 훅 전달인자디렉티브 훅은 다음을 전달인자로 사용할 수 있습니다. el: 디렉티브가 바인딩된 엘리먼트. 이 것을 사용하면 DOM 조작을 할 수 있습니다. binding: 아래의 속성을 가진 객체입니다. name: 디렉티브 이름, v- 프리픽스가 없습니다. value: 디렉티브에서 전달받은 값. 예를 들어 v-my-directive=&quot;1 + 1&quot;인 경우 value는 2 입니다. oldValue: 이전 값. update와 componentUpdated에서만 사용할 수 있습니다. 이를 통해 값이 변경되었는지 확인할 수 있습니다. expression: 표현식 문자열. 예를 들어 v-my-directive=&quot;1 + 1&quot;이면, 표현식은 &quot;1 + 1&quot; 입니다. arg: 디렉티브의 전달인자, 있는 경우에만 존재합니다. 예를 들어 v-my-directive:foo 이면 &quot;foo&quot; 입니다. modifiers: 포함된 수식어 객체, 있는 경우에만 존재합니다. 예를 들어 v-my-directive.foo.bar이면, 수식어 객체는 { foo: true, bar: true }입니다. vnode: Vue 컴파일러가 만든 버추얼 노드. VNode API에 전체 설명이 있습니다. oldVnode: 이전의 버추얼 노드. update와 componentUpdated에서만 사용할 수 있습니다. `el` 뿐만아니라 모든 전달인자는 읽기 전용으로 사용하여야 합니다. 절대 변경하면 안됩니다. 훅을 통해 이 정보들을 전달하는 경우, 엘리먼트의 [dataset](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset)을 이용하면 됩니다. 위 특성 중 일부를 사용하는 사용자 정의 디렉티브 예제입니다. 1&lt;div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\"&gt;&lt;/div&gt; 12345678910111213141516171819Vue.directive('demo', &#123; bind: function (el, binding, vnode) &#123; var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '&lt;br&gt;' + 'value: ' + s(binding.value) + '&lt;br&gt;' + 'expression: ' + s(binding.expression) + '&lt;br&gt;' + 'argument: ' + s(binding.arg) + '&lt;br&gt;' + 'modifiers: ' + s(binding.modifiers) + '&lt;br&gt;' + 'vnode keys: ' + Object.keys(vnode).join(', ') &#125;&#125;)new Vue(&#123; el: '#hook-arguments-example', data: &#123; message: 'hello!' &#125;&#125;) Vue.directive('demo', { bind: function (el, binding, vnode) { var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '' + 'value: ' + s(binding.value) + '' + 'expression: ' + s(binding.expression) + '' + 'argument: ' + s(binding.arg) + '' + 'modifiers: ' + s(binding.modifiers) + '' + 'vnode keys: ' + Object.keys(vnode).join(', ') } }) new Vue({ el: '#hook-arguments-example', data: { message: 'hello!' } }) 다이나믹 디렉티브 전달인자Directive arguments can be dynamic. For example, in v-mydirective:[argument]=&quot;value&quot;, the argument can be updated based on data properties in our component instance! This makes our custom directives flexible for use throughout our application. Let’s say you want to make a custom directive that allows you to pin elements to your page using fixed positioning. We could create a custom directive where the value updates the vertical positioning in pixels, like this: 1234&lt;div id=\"baseexample\"&gt; &lt;p&gt;Scroll down the page&lt;/p&gt; &lt;p v-pin=\"200\"&gt;Stick me 200px from the top of the page&lt;/p&gt;&lt;/div&gt; 12345678910Vue.directive('pin', &#123; bind: function (el, binding, vnode) &#123; el.style.position = 'fixed' el.style.top = binding.value + 'px' &#125;&#125;)new Vue(&#123; el: '#baseexample'&#125;) This would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to pin the element from the left, instead of the top? Here’s where a dynamic argument that can be updated per component instance comes in very handy: 1234&lt;div id=\"dynamicexample\"&gt; &lt;h3&gt;Scroll down inside this section ↓&lt;/h3&gt; &lt;p v-pin:[direction]=\"200\"&gt;I am pinned onto the page at 200px to the left.&lt;/p&gt;&lt;/div&gt; 12345678910111213141516Vue.directive('pin', &#123; bind: function (el, binding, vnode) &#123; el.style.position = 'fixed' var s = (binding.arg == 'left' ? 'left' : 'top') el.style[s] = binding.value + 'px' &#125;&#125;)new Vue(&#123; el: '#dynamicexample', data: function () &#123; return &#123; direction: 'left' &#125; &#125;&#125;) Result: See the Pen Dynamic Directive Arguments by Vue (@Vue) on CodePen. Our custom directive is now flexible enough to support a few different use cases. 함수 약어많은 경우에, bind와 update에서 같은 동작이 필요할 수 있습니다. 그러나 다른 훅은 신경 쓸 필요가 없습니다. 그 예로 123Vue.directive('color-swatch', function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;) 객체 리터럴디렉티브에 여러 값이 필요한 경우, JavaScript 객체 리터럴을 전달할 수도 있습니다. 디렉티브는 유효한 JavaScript 표현식을 사용할 수 있습니다. 1&lt;div v-demo=\"&#123; color: 'white', text: 'hello!' &#125;\"&gt;&lt;/div&gt; 1234Vue.directive('demo', function (el, binding) &#123; console.log(binding.value.color) // =&gt; \"white\" console.log(binding.value.text) // =&gt; \"hello!\"&#125;)","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"믹스인","date":"2019-03-01T10:04:47.000Z","path":"wiki/vue/mixins/","text":"기초Mixins는 Vue 컴포넌트에 재사용 가능한 기능을 배포하는 유연한 방법입니다. mixin 객체는 모든 구성 요소 옵션을 포함할 수 있습니다. 컴포넌트에 mixin을 사용하면 해당 mixin의 모든 옵션이 컴포넌트의 고유 옵션에 “혼합”됩니다. Watch a video explanation on Vue Mastery Example: 123456789101112131415161718// mixin 객체 생성var myMixin = &#123; created: function () &#123; this.hello() &#125;, methods: &#123; hello: function () &#123; console.log('hello from mixin!') &#125; &#125;&#125;// mixin을 사용할 컴포넌트 정의var Component = Vue.extend(&#123; mixins: [myMixin]&#125;)var component = new Component() // =&gt; \"hello from mixin!\" 옵션 병합mixin과 컴포넌트 자체에 중첩 옵션이 포함되어 있으면 적절한 전략을 사용하여 “병합”됩니다. For example, data objects undergo a recursive merge, with the component’s data taking priority in cases of conflicts. 12345678910111213141516171819202122var mixin = &#123; data: function () &#123; return &#123; message: 'hello', foo: 'abc' &#125; &#125;&#125;new Vue(&#123; mixins: [mixin], data: function () &#123; return &#123; message: 'goodbye', bar: 'def' &#125; &#125;, created: function () &#123; console.log(this.$data) // =&gt; &#123; message: \"goodbye\", foo: \"abc\", bar: \"def\" &#125; &#125;&#125;) 같은 이름의 훅 함수가 배열에 병합되어 모든 함수가 호출됩니다. 또한 mixin 훅은 컴포넌트 자체의 훅 이전에 호출됩니다. 123456789101112131415var mixin = &#123; created: function () &#123; console.log('mixin hook called') &#125;&#125;new Vue(&#123; mixins: [mixin], created: function () &#123; console.log('component hook called') &#125;&#125;)// =&gt; \"mixin hook called\"// =&gt; \"component hook called\" methods,components,directives와 같은 객체 값을 요구하는 옵션은 같은 객체에 병합됩니다. 이러한 객체에 충돌하는 키가 있을 경우 컴포넌트의 옵션이 우선순위를 갖습니다. 1234567891011121314151617181920212223242526var mixin = &#123; methods: &#123; foo: function () &#123; console.log('foo') &#125;, conflicting: function () &#123; console.log('from mixin') &#125; &#125;&#125;var vm = new Vue(&#123; mixins: [mixin], methods: &#123; bar: function () &#123; console.log('bar') &#125;, conflicting: function () &#123; console.log('from self') &#125; &#125;&#125;)vm.foo() // =&gt; \"foo\"vm.bar() // =&gt; \"bar\"vm.conflicting() // =&gt; \"from self\" 같은 병합 전략이 Vue.extend()에서 사용된다는 것에 주의하십시오. 전역 Mixinmixin은 전역으로 적용할 수 있습니다. 주의하세요! mixin을 전역으로 적용하면 이후에 생성된 모든 Vue 인스턴스 에 영향을 미칩니다. 적절히 사용하면 사용자 정의 옵션에 대한 처리 로직을 주입하는 데 사용할 수 있습니다. 1234567891011121314// `myOption` 사용자 정의 옵션을 위한 핸들러 주입Vue.mixin(&#123; created: function () &#123; var myOption = this.$options.myOption if (myOption) &#123; console.log(myOption) &#125; &#125;&#125;)new Vue(&#123; myOption: 'hello!'&#125;)// =&gt; \"hello!\" 글로벌 mixin은 써드파티 컴포넌트를 포함하여 생성된 모든 단일 Vue 인스턴스에 영향을 주기 때문에 적게 이용하고 신중하게 사용하십시오. 대부분의 경우 위 예제에서와 같이 사용자 지정 옵션 처리에만 사용해야합니다. 중복 적용을 피하기 위해 [Plugins](plugins.html)로 제공하는 것도 좋은 생각입니다. ## 사용자 정의 옵션 병합 전략 사용자 지정 옵션을 병합할 때 기본 옵션을 사용하면 기존 값을 덮어씁니다. 커스텀 로직을 사용해 커스텀 옵션을 병합하려면,Vue.config.optionMergeStrategies에 함수를 추가할 필요가 있습니다. 123Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) &#123; // return 병합된 값&#125; 대부분의 객체 기반 옵션에서 methods에서 사용한 것과 같은 전략을 간단하게 사용할 수 있습니다 : 12var strategies = Vue.config.optionMergeStrategiesstrategies.myOption = strategies.methods 더 고급 예제는 Vuex의 1.x 병합 전략에서 확인하실 수 있습니다. 12345678910const merge = Vue.config.optionMergeStrategies.computedVue.config.optionMergeStrategies.vuex = function (toVal, fromVal) &#123; if (!toVal) return fromVal if (!fromVal) return toVal return &#123; getters: merge(toVal.getters, fromVal.getters), state: merge(toVal.state, fromVal.state), actions: merge(toVal.actions, fromVal.actions) &#125;&#125;","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"Style Guide","date":"2019-02-20T10:04:47.000Z","path":"wiki/vue/style-guide/","text":"스타일 가이드이 문서는 Vue 코드에 대한 공식 스타일 가이드입니다. 만약 현재 Vue를 사용하여 프로젝트를 진행중이라면 이 문서는 에러와 바이크쉐딩(bikeshedding), 안티패턴을 피하는 좋은 참조가 될것 입니다. 그러나 무조건 이 문서에서 제시하는 스타일 가이드가 당신의 프로젝트에 적합한 것은 아닙니다. 그러므로 당신의 경험과 기술스택, 개인적 통찰력을 바탕으로 이 스타일 가이드가 적용되는 것을 권장해드립니다. 대부분의 경우 우리는 HTML과 자바스크립트에 대한 제안은 일반적으로 피합니다. 우리는 당신이 세미콜론이나 쉼표(trailing commas)에 대한 사용여부는 신경쓰지 않습니다. 우리는 당신이 HTML의 속성값을 위해 작음따옴표를 사용하지는 큰따옴표를 사용하는지 신경쓰지 않습니다. 그러나 특정 패턴이 뷰 컨텍스트에서 유용하다고 발견된 경우 예외가 존재합니다. Soon, we’ll also provide tips for enforcement. Sometimes you’ll simply have to be disciplined, but wherever possible, we’ll try to show you how to use ESLint and other automated processes to make enforcement simpler. 마지막으로, 우리는 규칙을 4가지 범주로 분류하였습니다. 규칙 분류우선순위 A: 필수이 규칙은 오류를 예방하는데 도움을 주기 때문에 모든 비용을 통해서 학습하고 준수하여야 합니다. 예외상황이 존재하겠지만 매우 드물며 자바스크립트와 뷰에 대한 전문 지식이 있어야 만들 수 있습니다. 우선순위 B: 매우 추천함이 규칙은 대부분의 프로젝트에서 가독성 그리고 개발자경험을 향상시키는 것으로 발견되었습니다. 해당 규칙을 위반해도 코드는 여전히 실행되지만 위반은 드물고 정당합니다. 우선순위 C: 추천함동일하게 좋은 여러가지 옵션이 존재하는 경우, 일관성을 보장하기 위해 임의의 선택을 할 수 있습니다. 이 규칙은 각각의 수용가능한 옵션을 설명하고 기본 선택을 제안합니다. 즉, 일관성 있고 좋은 이유가 있으면 당신의 코드베이스에서 자유롭게 다른 선택을 할 수 있습니다. 좋은 이유가 있어야 합니다! 커뮤니티 표준에 적응되기 위해서 당신은 다음과 같이 해야합니다. 당신이 마주하는 대부분의 커뮤니티 코드를 더 쉽게 분석할 수 있도록 훈련하세요 커뮤니티 코드 예제를 수정하기 한고 복사 그리고 붙혀넣기 할 수 있어야 합니다 적어도 뷰에 있어서는 당신이 선호하는 코딩 스타일을 수용하는 새로운 직원을 자주 찾을 것입니다 우선순위 D: 주의요함뷰의 몇 가지 은 특성은 드문 엣지 케이스 또는 레거시 코드로의 부터 마이크레이션을 위해 존재합니다. 그러나 그것들을 남용하면 당신의 코드를 유지보수하기 어렵게만들거나 버그를 발생시키는 원인이 될 수 있습니다. 이 규칙은 잠재적 위험요소를 인식시켜주고 언제 그리고 왜 피해야되는지 설명해 줍니다. 우선순위 A 규칙: 필수 (에러 방지)컴포넌트 이름에 합성어 사용 필수root 컴포넌트인 App 과 &lt;transition&gt;, &lt;component&gt;등 Vue에서 제공되는 빌트인 컴포넌트를 제외하고 컴포넌트의 이름은 항상 합성어를 사용해야한다. 모든 HTML 엘리먼트의 이름은 한 단어이기 때문에 합성어를 사용하는 것은 기존 그리고 향후 HTML엘리먼트와의 충돌을 방지해줍니다. 나쁨Vue.component(‘todo’, { // …}) 123456​``` jsexport default &#123; name: &apos;Todo&apos;, // ...&#125; 좋음123Vue.component('todo-item', &#123; // ...&#125;) 1234export default &#123; name: 'TodoItem', // ...&#125; 컴포넌트 데이터 필수컴포넌트의 data 는 반드시 함수여야 합니다. 컴포넌트(i.e. new Vue를 제외한 모든곳)의 data 프로퍼티의 값은 반드시 객체(object)를 반환하는 함수여야 한다. 자세한 설명 data 의 값이 오브젝트일 경우, 컴포넌트의 모든 인스턴스가 공유한다. 예를 들어, 다음 data 를 가진 TodoList 컴포넌트를 상상해보자. 1234data: &#123; listTitle: '', todos: []&#125; 이 컴포넌트는 재사용하여 사용자가 여러 목록(e.g. 쇼핑, 소원, 오늘 할일 등)을 유지할 수 있도록 해야 할 수 있다. 컴포넌트의 모든 인스턴스가 동일한 data 객체를 참조하므로, 하나의 목록의 타이틀을 변경할 때 다른 모든 리스트의 타이틀도 변경될 것이다. Todo를 추가/수정/삭제하는 경우에도 마찬가지다. 대신 우리는 각 컴포넌트의 인스턴스 자체 data만을 관리하기를 원한다. 이렇게 하려면 각 인스턴스는 고유한 data 객체를 생성해야 한다. JavaScript에서는 함수안에서 객체를 반환하는 방법으로 해결할 수 있다: 123456data: function () &#123; return &#123; listTitle: '', todos: [] &#125;&#125; 나쁨12345Vue.component('some-comp', &#123; data: &#123; foo: 'bar' &#125;&#125;) 12345export default &#123; data: &#123; foo: 'bar' &#125;&#125; 좋음1234567Vue.component('some-comp', &#123; data: function () &#123; return &#123; foo: 'bar' &#125; &#125;&#125;) 12345678// In a .vue fileexport default &#123; data () &#123; return &#123; foo: 'bar' &#125; &#125;&#125; 12345678// It's OK to use an object directly in a root// Vue instance, since only a single instance// will ever exist.new Vue(&#123; data: &#123; foo: 'bar' &#125;&#125;) Props 정의 필수Prop은 가능한 상세하게 정의되어야 합니다. 커밋 된 코드에서, prop 정의는 적어도 타입은 명시되도록 가능한 상세하게 정의되어야 합니다. 자세한 설명 자세한 prop definitions 두 가지 이점을 갖는다: 이 API는 컴포넌트의 API를 문서화하므로 컴포넌트의 사용 방법을 쉽게 알 수 있다. 개발 중에, Vue는 컴포넌트의 타입이 잘못 지정된 props를 전달하면 경고 메시지를 표시하여 오류의 잠재적 원인을 파악할 수 있도록 도와준다. 나쁨12// This is only OK when prototypingprops: ['status'] 좋음123props: &#123; status: String&#125; 123456789101112131415// Even better!props: &#123; status: &#123; type: String, required: true, validator: function (value) &#123; return [ 'syncing', 'synced', 'version-conflict', 'error' ].indexOf(value) !== -1 &#125; &#125;&#125; v-for 에 key 지정 필수v-for는 key와 항상 함께 사용합니다. 서브트리의 내부 컴포넌트 상태를 유지하기 위해 v-for는 항상 key와 함께 요구됩니다. 비록 엘리먼트이긴 하지만 에니메이션의 객체 불변성과 같이 예측 가능한 행동을 유지하는것은 좋은 습관입니다. 자세한 설명 할일 목록이 있다고 가정 해보자: 1234567891011121314data: function () &#123; return &#123; todos: [ &#123; id: 1, text: 'Learn to use v-for' &#125;, &#123; id: 2, text: 'Learn to use key' &#125; ] &#125;&#125; 그 다음 알파벳순으로 정렬한다. DOM 이 업데이트될 때, Vue는 가능한 적은 DOM 전이(mutations)를 수행하기 위해 렌더링을 최적화한다. 즉, 첫번째 할일 엘리먼트를 지우고, 리스트의 마지막에 다시 추가한다. The problem is, there are cases where it’s important not to delete elements that will remain in the DOM. For example, you may want to use &lt;transition-group&gt; to animate list sorting, or maintain focus if the rendered element is an &lt;input&gt;. In these cases, adding a unique key for each item (e.g. :key=&quot;todo.id&quot;) will tell Vue how to behave more predictably. In our experience, it’s better to always add a unique key, so that you and your team simply never have to worry about these edge cases. Then in the rare, performance-critical scenarios where object constancy isn’t necessary, you can make a conscious exception. 나쁨12345&lt;ul&gt; &lt;li v-for=\"todo in todos\"&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 좋음12345678&lt;ul&gt; &lt;li v-for=\"todo in todos\" :key=\"todo.id\" &gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt;&lt;/ul&gt; v-if와 v-for를 동시에 사용하지 마세요 필수v-for가 사용된 엘리먼트에 절대 v-if를 사용하지 마세요. 사용 가능해 보이는 두 가지 일반적인 경우가 있습니다: 리스트 목록을 필터링하기 위해서 입니다 (e.g. v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;). 이 경우 users을 새로운 computed 속성으로 필더링된 목록으로 대체하십시오(e.g. activeUsers). 숨기기 위해 리스트의 랜더링을 피할 때 입니다 (e.g. v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;). 이 경우 v-if를 컨테이너 엘리먼트로 옮기세요 (e.g. ul, ol). 자세한 설명 When Vue processes directives, v-for has a higher priority than v-if, so that this template: 123456789&lt;ul&gt; &lt;li v-for=\"user in users\" v-if=\"user.isActive\" :key=\"user.id\" &gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; Will be evaluated similar to: 12345this.users.map(function (user) &#123; if (user.isActive) &#123; return user.name &#125;&#125;) So even if we only render elements for a small fraction of users, we have to iterate over the entire list every time we re-render, whether or not the set of active users has changed. By iterating over a computed property instead, like this: 1234567computed: &#123; activeUsers: function () &#123; return this.users.filter(function (user) &#123; return user.isActive &#125;) &#125;&#125; 12345678&lt;ul&gt; &lt;li v-for=\"user in activeUsers\" :key=\"user.id\" &gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 다음과 같은 이점을 얻을 수 있다: The filtered list will only be re-evaluated if there are relevant changes to the users array, making filtering much more efficient. Using v-for=&quot;user in activeUsers&quot;, we only iterate over active users during render, making rendering much more efficient. Logic is now decoupled from the presentation layer, making maintenance (change/extension of logic) much easier. We get similar benefits from updating: 123456789&lt;ul&gt; &lt;li v-for=\"user in users\" v-if=\"shouldShowUsers\" :key=\"user.id\" &gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; to: 12345678&lt;ul v-if=\"shouldShowUsers\"&gt; &lt;li v-for=\"user in users\" :key=\"user.id\" &gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; By moving the v-if to a container element, we’re no longer checking shouldShowUsers for every user in the list. Instead, we check it once and don’t even evaluate the v-for if shouldShowUsers is false. 나쁨123456789&lt;ul&gt; &lt;li v-for=\"user in users\" v-if=\"user.isActive\" :key=\"user.id\" &gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 123456789&lt;ul&gt; &lt;li v-for=\"user in users\" v-if=\"shouldShowUsers\" :key=\"user.id\" &gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 좋음12345678&lt;ul&gt; &lt;li v-for=\"user in activeUsers\" :key=\"user.id\" &gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 12345678&lt;ul v-if=\"shouldShowUsers\"&gt; &lt;li v-for=\"user in users\" :key=\"user.id\" &gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 컴포넌트 스타일 스코프 필수For applications, styles in a top-level App component and in layout components may be global, but all other components should always be scoped. This is only relevant for single-file components. It does not require that the scoped attribute be used. Scoping could be through CSS modules, a class-based strategy such as BEM, or another library/convention. Component libraries, however, should prefer a class-based strategy instead of using the scoped attribute. This makes overriding internal styles easier, with human-readable class names that don’t have too high specificity, but are still very unlikely to result in a conflict. 자세한 설명 If you are developing a large project, working with other developers, or sometimes include 3rd-party HTML/CSS (e.g. from Auth0), consistent scoping will ensure that your styles only apply to the components they are meant for. Beyond the scoped attribute, using unique class names can help ensure that 3rd-party CSS does not apply to your own HTML. For example, many projects use the button, btn, or icon class names, so even if not using a strategy such as BEM, adding an app-specific and/or component-specific prefix (e.g. ButtonClose-icon) can provide some protection. 나쁨123456789&lt;template&gt; &lt;button class=\"btn btn-close\"&gt;X&lt;/button&gt;&lt;/template&gt;&lt;style&gt;.btn-close &#123; background-color: red;&#125;&lt;/style&gt; 좋음123456789101112131415&lt;template&gt; &lt;button class=\"button button-close\"&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- Using the `scoped` attribute --&gt;&lt;style scoped&gt;.button &#123; border: none; border-radius: 2px;&#125;.button-close &#123; background-color: red;&#125;&lt;/style&gt; 123456789101112131415&lt;template&gt; &lt;button :class=\"[$style.button, $style.buttonClose]\"&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- Using CSS modules --&gt;&lt;style module&gt;.button &#123; border: none; border-radius: 2px;&#125;.buttonClose &#123; background-color: red;&#125;&lt;/style&gt; 123456789101112131415&lt;template&gt; &lt;button class=\"c-Button c-Button--close\"&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- Using the BEM convention --&gt;&lt;style&gt;.c-Button &#123; border: none; border-radius: 2px;&#125;.c-Button--close &#123; background-color: red;&#125;&lt;/style&gt; Private 속성 이름 필수플러그인, mixin 등에서 커스텀 사용자 private 프로터피에는 항상 접두사 $_를 사용하라. 그 다음 다른 사람의 코드와 충돌을 피하려면 named scope를 포함하라. (e.g. $_yourPluginName_). 자세한 설명 Vue uses the _ prefix to define its own private properties, so using the same prefix (e.g. _update) risks overwriting an instance property. Even if you check and Vue is not currently using a particular property name, there is no guarantee a conflict won’t arise in a later version. As for the $ prefix, its purpose within the Vue ecosystem is special instance properties that are exposed to the user, so using it for private properties would not be appropriate. Instead, we recommend combining the two prefixes into $_, as a convention for user-defined private properties that guarantee no conflicts with Vue. 나쁨12345678var myGreatMixin = &#123; // ... methods: &#123; update: function () &#123; // ... &#125; &#125;&#125; 12345678var myGreatMixin = &#123; // ... methods: &#123; _update: function () &#123; // ... &#125; &#125;&#125; 12345678var myGreatMixin = &#123; // ... methods: &#123; $update: function () &#123; // ... &#125; &#125;&#125; 12345678var myGreatMixin = &#123; // ... methods: &#123; $_update: function () &#123; // ... &#125; &#125;&#125; 좋음12345678var myGreatMixin = &#123; // ... methods: &#123; $_myGreatMixin_update: function () &#123; // ... &#125; &#125;&#125; 12345678910111213141516// Even better!var myGreatMixin = &#123; // ... methods: &#123; publicMethod() &#123; // ... myPrivateFunction() &#125; &#125;&#125;function myPrivateFunction() &#123; // ...&#125;export default myGreatMixin 우선순위 B 규칙: 매우 추천함 (가독성 향상을 위함)컴포넌트 파일 매우 추천함Whenever a build system is available to concatenate files, each component should be in its own file. This helps you to more quickly find a component when you need to edit it or review how to use it. 나쁨1234567Vue.component('TodoList', &#123; // ...&#125;)Vue.component('TodoItem', &#123; // ...&#125;) 좋음123components/|- TodoList.js|- TodoItem.js 123components/|- TodoList.vue|- TodoItem.vue 싱글 파일 컴포넌트 이름 규칙 지정(casing) 매우 추천함Filenames of single-file components should either be always PascalCase or always kebab-case. PascalCase works best with autocompletion in code editors, as it’s consistent with how we reference components in JS(X) and templates, wherever possible. However, mixed case filenames can sometimes create issues on case-insensitive file systems, which is why kebab-case is also perfectly acceptable. 나쁨12components/|- mycomponent.vue 12components/|- myComponent.vue 좋음12components/|- MyComponent.vue 12components/|- my-component.vue 베이스 컴포넌트 이름 매우 추천함Base components (a.k.a. presentational, dumb, or pure components) that apply app-specific styling and conventions should all begin with a specific prefix, such as Base, App, or V. 자세한 설명 These components lay the foundation for consistent styling and behavior in your application. They may only contain: HTML elements, other base components, and 3rd-party UI components. But they’ll never contain global state (e.g. from a Vuex store). Their names often include the name of an element they wrap (e.g. BaseButton, BaseTable), unless no element exists for their specific purpose (e.g. BaseIcon). If you build similar components for a more specific context, they will almost always consume these components (e.g. BaseButton may be used in ButtonSubmit). Some advantages of this convention: When organized alphabetically in editors, your app’s base components are all listed together, making them easier to identify. Since component names should always be multi-word, this convention prevents you from having to choose an arbitrary prefix for simple component wrappers (e.g. MyButton, VueButton). Since these components are so frequently used, you may want to simply make them global instead of importing them everywhere. A prefix makes this possible with Webpack: 1234567891011var requireComponent = require.context(\"./src\", true, /^Base[A-Z]/)requireComponent.keys().forEach(function (fileName) &#123; var baseComponentConfig = requireComponent(fileName) baseComponentConfig = baseComponentConfig.default || baseComponentConfig var baseComponentName = baseComponentConfig.name || ( fileName .replace(/^.+\\//, '') .replace(/\\.\\w+$/, '') ) Vue.component(baseComponentName, baseComponentConfig)&#125;) 나쁨1234components/|- MyButton.vue|- VueTable.vue|- Icon.vue 좋음1234components/|- BaseButton.vue|- BaseTable.vue|- BaseIcon.vue 1234components/|- AppButton.vue|- AppTable.vue|- AppIcon.vue 1234components/|- VButton.vue|- VTable.vue|- VIcon.vue 싱글 인스턴스 컴포넌트 이름 매우 추천함Components that should only ever have a single active instance should begin with the The prefix, to denote that there can be only one. This does not mean the component is only used in a single page, but it will only be used once per page. These components never accept any props, since they are specific to your app, not their context within your app. If you find the need to add props, it’s a good indication that this is actually a reusable component that is only used once per page for now. 나쁨123components/|- Heading.vue|- MySidebar.vue 좋음123components/|- TheHeading.vue|- TheSidebar.vue 강한 연관성을 가진 컴포넌트 이름 매우 추천함Child components that are tightly coupled with their parent should include the parent component name as a prefix. If a component only makes sense in the context of a single parent component, that relationship should be evident in its name. Since editors typically organize files alphabetically, this also keeps these related files next to each other. 자세한 설명 You might be tempted to solve this problem by nesting child components in directories named after their parent. For example: 123456components/|- TodoList/ |- Item/ |- index.vue |- Button.vue |- index.vue or: 123456components/|- TodoList/ |- Item/ |- Button.vue |- Item.vue|- TodoList.vue This isn’t recommended, as it results in: Many files with similar names, making rapid file switching in code editors more difficult. Many nested sub-directories, which increases the time it takes to browse components in an editor’s sidebar. 나쁨1234components/|- TodoList.vue|- TodoItem.vue|- TodoButton.vue 123components/|- SearchSidebar.vue|- NavigationForSearchSidebar.vue 좋음1234components/|- TodoList.vue|- TodoListItem.vue|- TodoListItemButton.vue 123components/|- SearchSidebar.vue|- SearchSidebarNavigation.vue 컴포넌트 이름의 단어 순서 정렬 매우 추천함Component names should start with the highest-level (often most general) words and end with descriptive modifying words. 자세한 설명 You may be wondering: “Why would we force component names to use less natural language?” In natural English, adjectives and other descriptors do typically appear before the nouns, while exceptions require connector words. For example: Coffee with milk Soup of the day Visitor to the museum You can definitely include these connector words in component names if you’d like, but the order is still important. Also note that what’s considered “highest-level” will be contextual to your app. For example, imagine an app with a search form. It may include components like this one: 1234567components/|- ClearSearchButton.vue|- ExcludeFromSearchInput.vue|- LaunchOnStartupCheckbox.vue|- RunSearchButton.vue|- SearchInput.vue|- TermsCheckbox.vue As you might notice, it’s quite difficult to see which components are specific to the search. Now let’s rename the components according to the rule: 1234567components/|- SearchButtonClear.vue|- SearchButtonRun.vue|- SearchInputExcludeGlob.vue|- SearchInputQuery.vue|- SettingsCheckboxLaunchOnStartup.vue|- SettingsCheckboxTerms.vue Since editors typically organize files alphabetically, all the important relationships between components are now evident at a glance. You might be tempted to solve this problem differently, nesting all the search components under a “search” directory, then all the settings components under a “settings” directory. We only recommend considering this approach in very large apps (e.g. 100+ components), for these reasons: It generally takes more time to navigate through nested sub-directories, than scrolling through a single components directory. Name conflicts (e.g. multiple ButtonDelete.vue components) make it more difficult to quickly navigate to a specific component in a code editor. Refactoring becomes more difficult, because find-and-replace often isn’t sufficient to update relative references to a moved component. 나쁨1234567components/|- ClearSearchButton.vue|- ExcludeFromSearchInput.vue|- LaunchOnStartupCheckbox.vue|- RunSearchButton.vue|- SearchInput.vue|- TermsCheckbox.vue 좋음1234567components/|- SearchButtonClear.vue|- SearchButtonRun.vue|- SearchInputQuery.vue|- SearchInputExcludeGlob.vue|- SettingsCheckboxTerms.vue|- SettingsCheckboxLaunchOnStartup.vue 셀프 클로징 컴포넌트 매우 추천함Components with no content should be self-closing in single-file components, string templates, and JSX - but never in DOM templates. Components that self-close communicate that they not only have no content, but are meant to have no content. It’s the difference between a blank page in a book and one labeled “This page intentionally left blank.” Your code is also cleaner without the unnecessary closing tag. Unfortunately, HTML doesn’t allow custom elements to be self-closing - only official “void” elements. That’s why the strategy is only possible when Vue’s template compiler can reach the template before the DOM, then serve the DOM spec-compliant HTML. 나쁨12&lt;!-- In single-file components, string templates, and JSX --&gt;&lt;MyComponent&gt;&lt;/MyComponent&gt; 12&lt;!-- In DOM templates --&gt;&lt;my-component/&gt; 좋음12&lt;!-- In single-file components, string templates, and JSX --&gt;&lt;MyComponent/&gt; 12&lt;!-- In DOM templates --&gt;&lt;my-component&gt;&lt;/my-component&gt; 템플릿에서 컴포넌트 이름 규칙 지정(casing) 매우 추천함In most projects, component names should always be PascalCase in single-file components and string templates - but kebab-case in DOM templates. PascalCase has a few advantages over kebab-case: Editors can autocomplete component names in templates, because PascalCase is also used in JavaScript. &lt;MyComponent&gt; is more visually distinct from a single-word HTML element than &lt;my-component&gt;, because there are two character differences (the two capitals), rather than just one (a hyphen). If you use any non-Vue custom elements in your templates, such as a web component, PascalCase ensures that your Vue components remain distinctly visible. Unfortunately, due to HTML’s case insensitivity, DOM templates must still use kebab-case. Also note that if you’ve already invested heavily in kebab-case, consistency with HTML conventions and being able to use the same casing across all your projects may be more important than the advantages listed above. In those cases, using kebab-case everywhere is also acceptable. 나쁨12&lt;!-- In single-file components and string templates --&gt;&lt;mycomponent/&gt; 12&lt;!-- In single-file components and string templates --&gt;&lt;myComponent/&gt; 12&lt;!-- In DOM templates --&gt;&lt;MyComponent&gt;&lt;/MyComponent&gt; 좋음12&lt;!-- In single-file components and string templates --&gt;&lt;MyComponent/&gt; 12&lt;!-- In DOM templates --&gt;&lt;my-component&gt;&lt;/my-component&gt; OR 12&lt;!-- Everywhere --&gt;&lt;my-component&gt;&lt;/my-component&gt; JS/JSX에서 컴포넌트 이름 규칙 지정(casing) 매우 추천함Component names in JS/JSX should always be PascalCase, though they may be kebab-case inside strings for simpler applications that only use global component registration through Vue.component. 자세한 설명 In JavaScript, PascalCase is the convention for classes and prototype constructors - essentially, anything that can have distinct instances. Vue components also have instances, so it makes sense to also use PascalCase. As an added benefit, using PascalCase within JSX (and templates) allows readers of the code to more easily distinguish between components and HTML elements. However, for applications that use only global component definitions via Vue.component, we recommend kebab-case instead. The reasons are: It’s rare that global components are ever referenced in JavaScript, so following a convention for JavaScript makes less sense. These applications always include many in-DOM templates, where kebab-case must be used. 나쁨123Vue.component('myComponent', &#123; // ...&#125;) 1import myComponent from './MyComponent.vue' 1234export default &#123; name: 'myComponent', // ...&#125; 1234export default &#123; name: 'my-component', // ...&#125; 좋음123Vue.component('MyComponent', &#123; // ...&#125;) 123Vue.component('my-component', &#123; // ...&#125;) 1import MyComponent from './MyComponent.vue' 1234export default &#123; name: 'MyComponent', // ...&#125; 전체 이름 컴포넌트 이름 매우 추천함Component names should prefer full words over abbreviations. The autocompletion in editors make the cost of writing longer names very low, while the clarity they provide is invaluable. Uncommon abbreviations, in particular, should always be avoided. 나쁨123components/|- SdSettings.vue|- UProfOpts.vue 좋음123components/|- StudentDashboardSettings.vue|- UserProfileOptions.vue Prop 이름 규칙 지정(casing) 매우 추천함Prop names should always use camelCase during declaration, but kebab-case in templates and JSX. We’re simply following the conventions of each language. Within JavaScript, camelCase is more natural. Within HTML, kebab-case is. 나쁨123props: &#123; 'greeting-text': String&#125; 1&lt;WelcomeMessage greetingText=\"hi\"/&gt; 좋음123props: &#123; greetingText: String&#125; 1&lt;WelcomeMessage greeting-text=\"hi\"/&gt; 다중 속성 엘리먼트 매우 추천함Elements with multiple attributes should span multiple lines, with one attribute per line. In JavaScript, splitting objects with multiple properties over multiple lines is widely considered a good convention, because it’s much easier to read. Our templates and JSX deserve the same consideration. 나쁨1&lt;img src=\"https://vuejs.org/images/logo.png\" alt=\"Vue Logo\"&gt; 1&lt;MyComponent foo=\"a\" bar=\"b\" baz=\"c\"/&gt; 좋음1234&lt;img src=\"https://vuejs.org/images/logo.png\" alt=\"Vue Logo\"&gt; 12345&lt;MyComponent foo=\"a\" bar=\"b\" baz=\"c\"/&gt; 템플릿에서 단순한 표현식 매우 추천함Component templates should only include simple expressions, with more complex expressions refactored into computed properties or methods. Complex expressions in your templates make them less declarative. We should strive to describe what should appear, not how we’re computing that value. Computed properties and methods also allow the code to be reused. 나쁨12345&#123;&#123; fullName.split(' ').map(function (word) &#123; return word[0].toUpperCase() + word.slice(1) &#125;).join(' ')&#125;&#125; 좋음12&lt;!-- In a template --&gt;&#123;&#123; normalizedFullName &#125;&#125; 12345678// The complex expression has been moved to a computed propertycomputed: &#123; normalizedFullName: function () &#123; return this.fullName.split(' ').map(function (word) &#123; return word[0].toUpperCase() + word.slice(1) &#125;).join(' ') &#125;&#125; 단순한 계산된 속성 매우 추천함Complex computed properties should be split into as many simpler properties as possible. 자세한 설명 Simpler, well-named computed properties are: Easier to test When each computed property contains only a very simple expression, with very few dependencies, it’s much easier to write tests confirming that it works correctly. Easier to read Simplifying computed properties forces you to give each value a descriptive name, even if it’s not reused. This makes it much easier for other developers (and future you) to focus in on the code they care about and figure out what’s going on. More adaptable to changing requirements Any value that can be named might be useful to the view. For example, we might decide to display a message telling the user how much money they saved. We might also decide to calculate sales tax, but perhaps display it separately, rather than as part of the final price. Small, focused computed properties make fewer assumptions about how information will be used, so require less refactoring as requirements change. 나쁨123456789computed: &#123; price: function () &#123; var basePrice = this.manufactureCost / (1 - this.profitMargin) return ( basePrice - basePrice * (this.discountPercent || 0) ) &#125;&#125; 좋음1234567891011computed: &#123; basePrice: function () &#123; return this.manufactureCost / (1 - this.profitMargin) &#125;, discount: function () &#123; return this.basePrice * (this.discountPercent || 0) &#125;, finalPrice: function () &#123; return this.basePrice - this.discount &#125;&#125; 속성 값에 따옴표 매우 추천함Non-empty HTML attribute values should always be inside quotes (single or double, whichever is not used in JS). While attribute values without any spaces are not required to have quotes in HTML, this practice often leads to avoiding spaces, making attribute values less readable. 나쁨1&lt;input type=text&gt; 1&lt;AppSidebar :style=&#123;width:sidebarWidth+'px'&#125;&gt; 좋음1&lt;input type=\"text\"&gt; 1&lt;AppSidebar :style=\"&#123; width: sidebarWidth + 'px' &#125;\"&gt; 축약형 디렉티브 매우 추천함Directive shorthands (: for v-bind:, @ for v-on: and # for v-slot) should be used always or never. 나쁨1234&lt;input v-bind:value=\"newTodoText\" :placeholder=\"newTodoInstructions\"&gt; 1234&lt;input v-on:input=\"onInput\" @focus=\"onFocus\"&gt; 1234567&lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt;&lt;/template&gt;&lt;template #footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt;&lt;/template&gt; 좋음1234&lt;input :value=\"newTodoText\" :placeholder=\"newTodoInstructions\"&gt; 1234&lt;input v-bind:value=\"newTodoText\" v-bind:placeholder=\"newTodoInstructions\"&gt; 1234&lt;input @input=\"onInput\" @focus=\"onFocus\"&gt; 1234&lt;input v-on:input=\"onInput\" v-on:focus=\"onFocus\"&gt; 1234567&lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt;&lt;/template&gt;&lt;template v-slot:footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt;&lt;/template&gt; 1234567&lt;template #header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt;&lt;/template&gt;&lt;template #footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt;&lt;/template&gt; 우선순위 C 규칙: 추천함 (선택의 혼란 또는 판단 오버헤드 최소화)컴포넌트/인스턴스 옵션 순서 추천함컴포넌트/인스턴스 옵션의 순서는 언제나 일정한 순서로 정렬되어야 합니다. 아래는 권장하는 컴포넌트 옵션 순서입니다. 유형별로 나누어 놓았으므로, 플러그인으로 추가되는 새로운 옵션들 역시 이에 맞추어 정렬하면 됩니다. 사이드 이펙트(Side Effects) (컴포넌트 외부에 효과가 미치는 옵션) el 전역 인지(Global Awareness) (컴포넌트 바깥의 지식을 필요로 하는 옵션) name parent 컴포넌트 유형(Component Type) (컴포넌트의 유형을 바꾸는 옵션) functional 템플릿 변경자(Template Modifiers) (템플릿이 컴파일되는 방식을 바꾸는 옵션) delimiters comments 템플릿 의존성(Template Dependencies) (템플릿에 이용되는 요소들을 지정하는 옵션) components directives filters 컴포지션(Composition) (다른 컴포넌트의 속성을 가져와 합치는 옵션) extends mixins 인터페이스(Interface) (컴포넌트의 인터페이스를 지정하는 옵션) inheritAttrs model props/propsData 지역 상태(Local State) (반응적인 지역 속성들을 설정하는 옵션) data computed 이벤트(Events) (반응적인 이벤트에 의해 실행되는 콜백을 지정하는 옵션) watch 라이프사이클 이벤트 (호출 순서대로 정렬) beforeCreate created beforeMount mounted beforeUpdate updated activated deactivated beforeDestroy destroyed 비반응적 속성(Non-Reactive Properties) (시스템의 반응성과 관계 없는 인스턴스 속성을 지정하는 옵션) methods 렌더링(Rendering) (컴포넌트 출력을 선언적으로 지정하는 옵션) template/render renderError 엘리먼트 속성 순서 추천함엘리먼트 및 컴포넌트의 속성은 언제나 일정한 순서로 정렬되어야 합니다. 아래는 권장하는 엘리먼트 속성 순서입니다. 유형별로 나누어 놓았으므로, 커스텀 속성이나 directive 역시 이에 맞추어 정렬하면 됩니다. 정의(Definition) (컴포넌트 옵션을 제공하는 속성) is 리스트 렌더링(List Rendering) (같은 엘리먼트의 변형을 여러 개 생성하는 속성) v-for 조건부(Conditionals) (엘리먼트가 렌더링되는지 혹은 보여지는지 여부를 결정하는 속성) v-if v-else-if v-else v-show v-cloak 렌더 변경자(Render Modifiers) (엘리먼트의 렌더링 방식을 변경하는 속성) v-pre v-once 전역 인지(Global Awareness) (컴포넌트 바깥의 지식을 요구하는 속성) id 유일한 속성(Unique Attributes) (유일한 값을 가질 것을 요구하는 속성) ref key slot 양방향 바인딩(Two-Way Binding) (바인딩과 이벤트를 결합하는 속성) v-model 기타 속성 (따로 언급하지 않은 속성들) 이벤트(Events) (컴포넌트 이벤트 리스너를 지정하는 속성) v-on 내용(Content) (엘리먼트의 내용을 덮어쓰는 속성) v-html v-text 컴포넌트/인스턴스 옵션간 빈 줄 추천함You may want to add one empty line between multi-line properties, particularly if the options can no longer fit on your screen without scrolling. When components begin to feel cramped or difficult to read, adding spaces between multi-line properties can make them easier to skim again. In some editors, such as Vim, formatting options like this can also make them easier to navigate with the keyboard. 좋음123456789101112131415161718192021222324props: &#123; value: &#123; type: String, required: true &#125;, focused: &#123; type: Boolean, default: false &#125;, label: String, icon: String&#125;,computed: &#123; formattedValue: function () &#123; // ... &#125;, inputClasses: function () &#123; // ... &#125;&#125; 12345678910111213141516171819202122// No spaces are also fine, as long as the component// is still easy to read and navigate.props: &#123; value: &#123; type: String, required: true &#125;, focused: &#123; type: Boolean, default: false &#125;, label: String, icon: String&#125;,computed: &#123; formattedValue: function () &#123; // ... &#125;, inputClasses: function () &#123; // ... &#125;&#125; 싱글 파일 컴포넌트 최상위 엘리먼트 순서 추천함Single-file components should always order &lt;script&gt;, &lt;template&gt;, and &lt;style&gt; tags consistently, with &lt;style&gt; last, because at least one of the other two is always necessary. 나쁨123&lt;style&gt;/* ... */&lt;/style&gt;&lt;script&gt;/* ... */&lt;/script&gt;&lt;template&gt;...&lt;/template&gt; 123456789&lt;!-- ComponentA.vue --&gt;&lt;script&gt;/* ... */&lt;/script&gt;&lt;template&gt;...&lt;/template&gt;&lt;style&gt;/* ... */&lt;/style&gt;&lt;!-- ComponentB.vue --&gt;&lt;template&gt;...&lt;/template&gt;&lt;script&gt;/* ... */&lt;/script&gt;&lt;style&gt;/* ... */&lt;/style&gt; 좋음123456789&lt;!-- ComponentA.vue --&gt;&lt;script&gt;/* ... */&lt;/script&gt;&lt;template&gt;...&lt;/template&gt;&lt;style&gt;/* ... */&lt;/style&gt;&lt;!-- ComponentB.vue --&gt;&lt;script&gt;/* ... */&lt;/script&gt;&lt;template&gt;...&lt;/template&gt;&lt;style&gt;/* ... */&lt;/style&gt; 123456789&lt;!-- ComponentA.vue --&gt;&lt;template&gt;...&lt;/template&gt;&lt;script&gt;/* ... */&lt;/script&gt;&lt;style&gt;/* ... */&lt;/style&gt;&lt;!-- ComponentB.vue --&gt;&lt;template&gt;...&lt;/template&gt;&lt;script&gt;/* ... */&lt;/script&gt;&lt;style&gt;/* ... */&lt;/style&gt; 우선순위 D 규칙: 주의요함 (잠재적인 위험을 내포한 패턴)key가 없는 v-if/v-if-else/v-else 주의요함It’s usually best to use key with v-if + v-else, if they are the same element type (e.g. both &lt;div&gt; elements). By default, Vue updates the DOM as efficiently as possible. That means when switching between elements of the same type, it simply patches the existing element, rather than removing it and adding a new one in its place. This can have unintended consequences if these elements should not actually be considered the same. 나쁨123456&lt;div v-if=\"error\"&gt; Error: &#123;&#123; error &#125;&#125;&lt;/div&gt;&lt;div v-else&gt; &#123;&#123; results &#125;&#125;&lt;/div&gt; 좋음123456789101112&lt;div v-if=\"error\" key=\"search-status\"&gt; Error: &#123;&#123; error &#125;&#125;&lt;/div&gt;&lt;div v-else key=\"search-results\"&gt; &#123;&#123; results &#125;&#125;&lt;/div&gt; scoped에서 엘리먼트 셀렉터 사용 주의요함Element selectors should be avoided with scoped. Prefer class selectors over element selectors in scoped styles, because large numbers of element selectors are slow. 자세한 설명 To scope styles, Vue adds a unique attribute to component elements, such as data-v-f3f3eg9. Then selectors are modified so that only matching elements with this attribute are selected (e.g. button[data-v-f3f3eg9]). The problem is that large numbers of element-attribute selectors (e.g. button[data-v-f3f3eg9]) will be considerably slower than class-attribute selectors (e.g. .btn-close[data-v-f3f3eg9]), so class selectors should be preferred whenever possible. 나쁨123456789&lt;template&gt; &lt;button&gt;X&lt;/button&gt;&lt;/template&gt;&lt;style scoped&gt;button &#123; background-color: red;&#125;&lt;/style&gt; 좋음123456789&lt;template&gt; &lt;button class=\"btn btn-close\"&gt;X&lt;/button&gt;&lt;/template&gt;&lt;style scoped&gt;.btn-close &#123; background-color: red;&#125;&lt;/style&gt; 부모-자식간 의사소통 주의요함Props and events should be preferred for parent-child component communication, instead of this.$parent or mutating props. An ideal Vue application is props down, events up. Sticking to this convention makes your components much easier to understand. However, there are edge cases where prop mutation or this.$parent can simplify two components that are already deeply coupled. The problem is, there are also many simple cases where these patterns may offer convenience. Beware: do not be seduced into trading simplicity (being able to understand the flow of your state) for short-term convenience (writing less code). 나쁨123456789Vue.component('TodoItem', &#123; props: &#123; todo: &#123; type: Object, required: true &#125; &#125;, template: '&lt;input v-model=\"todo.text\"&gt;'&#125;) 123456789101112131415161718192021222324Vue.component('TodoItem', &#123; props: &#123; todo: &#123; type: Object, required: true &#125; &#125;, methods: &#123; removeTodo () &#123; var vm = this vm.$parent.todos = vm.$parent.todos.filter(function (todo) &#123; return todo.id !== vm.todo.id &#125;) &#125; &#125;, template: ` &lt;span&gt; &#123;&#123; todo.text &#125;&#125; &lt;button @click=\"removeTodo\"&gt; X &lt;/button&gt; &lt;/span&gt; `&#125;) 좋음1234567891011121314Vue.component('TodoItem', &#123; props: &#123; todo: &#123; type: Object, required: true &#125; &#125;, template: ` &lt;input :value=\"todo.text\" @input=\"$emit('input', $event.target.value)\" &gt; `&#125;) 12345678910111213141516Vue.component('TodoItem', &#123; props: &#123; todo: &#123; type: Object, required: true &#125; &#125;, template: ` &lt;span&gt; &#123;&#123; todo.text &#125;&#125; &lt;button @click=\"$emit('delete')\"&gt; X &lt;/button&gt; &lt;/span&gt; `&#125;) 전역 상태 관리 주의요함전역 상태 관리에는 this.$root 나 글로벌 이벤트 버스(global event bus)보다는 Vuex를 이용하는 것이 좋습니다. 전역 상태 관리에 this.$root나 글로벌 이벤트 버스를 이용하는 것은 아주 단순한 경우에는 편리할 수 있지만 대부분의 Application에는 부적절합니다. Vuex는 상태를 관리하는 중앙 저장소를 제공하는 것만이 아니라 상태 변화를 체계화하고, 추적하며, 디버깅을 용이하게 하는 도구들을 제공합니다. 나쁨1234567891011121314151617// main.jsnew Vue(&#123; data: &#123; todos: [] &#125;, created: function () &#123; this.$on('remove-todo', this.removeTodo) &#125;, methods: &#123; removeTodo: function (todo) &#123; var todoIdToRemove = todo.id this.todos = this.todos.filter(function (todo) &#123; return todo.id !== todoIdToRemove &#125;) &#125; &#125;&#125;) 좋음12345678910111213141516// store/modules/todos.jsexport default &#123; state: &#123; list: [] &#125;, mutations: &#123; REMOVE_TODO (state, todoId) &#123; state.list = state.list.filter(todo =&gt; todo.id !== todoId) &#125; &#125;, actions: &#123; removeTodo (&#123; commit, state &#125;, todo) &#123; commit('REMOVE_TODO', todo.id) &#125; &#125;&#125; 1234567891011121314151617181920212223&lt;!-- TodoItem.vue --&gt;&lt;template&gt; &lt;span&gt; &#123;&#123; todo.text &#125;&#125; &lt;button @click=\"removeTodo(todo)\"&gt; X &lt;/button&gt; &lt;/span&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapActions &#125; from 'vuex'export default &#123; props: &#123; todo: &#123; type: Object, required: true &#125; &#125;, methods: mapActions(['removeTodo'])&#125;&lt;/script&gt; (function () { var enforcementTypes = { none: 'self-discipline', runtime: 'runtime error', linter: 'plugin:vue/recommended' } Vue.component('sg-enforcement', { template: '\\ \\ Enforcement:\\ \\ \\ ', props: { type: { type: String, required: true, validate: function (value) { Object.keys(enforcementTypes).indexOf(value) !== -1 } } }, computed: { humanType: function () { return enforcementTypes[this.type] } } }) // new Vue({ // el: '#main' // }) })()","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"다른 프레임워크와의 비교","date":"2019-02-20T10:04:47.000Z","path":"wiki/vue/comparison/","text":"이 섹션은 작성하기 가장 까다로운 페이지이지만, 중요하다고 생각합니다. 당신은 해결하려는 문제가 있었을 것이고 문제를 해결하기 위해 다른 라이브러리를 사용했을 것입니다. 그리고 Vue가 특정 문제를 더 잘 해결할 수 있는지 알고 싶기 때문에 이 것을 보고 있을 것입니다. 이것이 우리가 당신을 위해 말하고자하는 것입니다. 우리는 편견을 피하려고 아주 열심히 하고 있습니다. 코어 팀으로서 우리는 Vue를 좋아합니다. 우리는 우리가 더 잘 해결할 수 있다고 생각하는 몇 가지 문제가 있습니다. 이를 믿지 않는다면, 우리는 더 이상 연구하지 않을 것입니다. 우리는 공정하고 정확하기를 원합니다. React의 대체 렌더러에 대한 React의 광범위한 생태계 또는 Knockout의 IE6에 대한 브라우저 지원과 같은 다른 라이브러리가 중요한 이점을 제공하는 등이 우리가 다루려는 것 입니다. 자바 스크립트 세계가 빠르게 움직이기 때문에 이 문서를 최신 상태로 유지하는 당신의 도움을 받길 바랍니다. 정확하지 않다고 생각되는 부분이나 잘못된 부분이 있으면 문제 제기로 알려주십시오.). ReactReact와 Vue는 많은 공통점을 공유합니다. 가상 DOM을 활용합니다. 반응적이고 조합 가능한 컴포넌트를 제공합니다. 코어 라이브러리에만 집중하고 있고 라우팅 및 전역 상태를 관리하는 컴패니언 라이브러리가 있습니다. 범위가 너무 비슷하기 때문에 이 비교를 다른 어떤 것보다 자세하게 보는데 더 많은 시간을 투자했습니다. 우리는 기술적 정확성뿐만 아니라 균형을 유지하기를 원합니다. React가 Vue보다 더 빛나는 곳, 예를 들어 생태계가 풍부하고 커스텀 렌더러가 풍부하다는 점을 지적합니다. 그렇다고해서 비교 대상이 일부 React 사용자에게 Vue에 편향된 것처럼 보이는 것은 피할 수 없는 사실입니다. 많은 주제가 탐구되는 것은 어느 정도 주관적입니다. 우리는 다양한 기술적 취향의 존재를 인정합니다. 이 비교는 당신의 취향이 우리와 맞을 경우 Vue가 잠재적으로 더 적합할 수 있는 이유를 개략적으로 설명하기 위한 것입니다. React 팀의 Dan Abramov 덕분에 React 커뮤니티는 이러한 균형을 이루는데 도움이 되었습니다. 그는 우리가 최종 결과에 대해 모두 만족할 때까지이 문서를 수정하는 데 도움이되는 시간과 상당한 전문성을 지극히 관대했습니다. Some of the sections below may also be slightly outdated due to recent updates in React 16+, and we are planning to work with the React community to revamp this section in the near future. 런타임 퍼포먼스React와 Vue 모두 비슷하게 빠르므로 속도는 선택에 있어 결정적인 요인이 되지는 않을 것입니다. 특정 측정 항목에 대해서는 매우 간단한 컴포넌트 트리를 사용하여 원시 렌더링/업데이트 성능에 초점을 맞추는 써드파티 벤치 마크를 확인하십시오. 렌더링 성능UI를 렌더링 할 때 일반적으로 DOM을 조작하는 것이 가장 비용이 많이 드는 작업이며 유감스럽게도 라이브러리는 이러한 원시 작업을 더 빠르게 만들 수 없습니다. 우리가 할 수 있는 최선의 방법은 다음과 같습니다. 필요한 DOM 조작 수를 최소화합니다. React와 Vue는 모두 가상의 DOM 추상화를 사용하여 이 작업을 수행하며 두가지 구현 모두 거의 동일하게 작동합니다. DOM 조작에 가능한 적은 오버헤드(순수 JavaScript 계산)만 가합니다. 이 것은 Vue와 React의 차이입니다. JavaScript의 오버헤드는 필요한 DOM 작업을 계산하는 메커니즘과 직접적으로 관련이 있습니다. Vue와 React 모두 가상 DOM을 사용하여 이를 구현하지만 Vue의 가상 DOM 구현(snabbdom의 포크)은 훨씬 가벼우므로 React보다 더 적은 오버 헤드가 발생합니다. Vue와 React 모두 상태가 없고 및 인스턴스가 없는 컴포넌트를 제공하므로 오버 헤드가 적습니다. 이러한 성능이 중요한 상황에서 사용되면 Vue가 다시 한 번 더 빠릅니다. 이를 입증하기 위해 우리는 10,000 개의 목록 항목을 100 번 렌더링하는 간단한 벤치 마크 프로젝트를 만들었습니다. 결과는 하드웨어와 사용되는 브라우저에 따라 다르므로 실제로 시도해 보는 것이 좋습니다. 실제로는 JavaScript 엔진의 특성으로 인해 실행간에 차이는 있습니다. 약간 귀찮더라도, 아래는 2014 년 MacBook Air의 Chrome 52에서 실행 된 숫자입니다. 체리 피킹을 피하기 위해 두 벤치 마크는 실제로 20번의 별도 시간에 실행되었으며 아래에 포함 된 최상의 실행 결과가 있습니다. Vue React Fastest 23ms 63ms Median 42ms 81ms Average 51ms 94ms 95th Perc. 73ms 164ms Slowest 343ms 453ms 갱신 성능React에서는 컴포넌트의 상태가 변경되면 해당 컴포넌트에서 루트로 시작하여 전체 컴포넌트 하위 트리를 다시 렌더링합니다. 불필요한 자식 컴포넌트의 재 렌더링을 피하려면 어디에서나 shouldComponentUpdate를 구현하고 변경 불가능한 데이터 구조를 사용해야 합니다. Vue에서 컴포넌트의 종속성은 렌더링 중 자동으로 추적되므로 시스템은 실제로 다시 렌더링해야하는 컴포넌트를 정확히 알고 있습니다. 즉 최적화되지 않은 Vue의 업데이트는 최적화되지 않은 React보다 훨씬 빠르며 실제로 Vue의 렌더링 성능이 향상되므로 완전히 최적화 된 React도 보통 Vue가 기본 제공되는 것보다 느립니다. 개발에 있어서프로덕션 환경에서의 성능은 최종 사용자 경험과 직접 관련되어 있기 때문에 더 중요한 부분이지만 개발 경험은 개발자 경험과 관련되어 있으므로 여전히 중요합니다. Vue와 React 모두 거의 대부분의 일반적인 애플리케이션에서 속도가 빠릅니다. 그러나 높은 프레임 속도의 데이터 시각화 또는 애니메이션을 프로토 타이핑 할 때 Vue는 개발시 초당 10 프레임을 처리하는 반면 React는 초당 약 1 프레임으로 떨어지는 경우를 보았습니다. 이것은 많은 우수한 경고와 오류 메시지를 제공하는 데 도움이되는 개발 모드에서의 React의 많은 무질서한 검사 때문입니다. 우리는 이 것들이 Vue에서도 중요하다는 것에 동의하지만, 이를 이행하는 동안 성과를 면밀히 관찰하려고 노력했습니다. HTML &amp; CSSReact에서는 모든 것이 JavaScript입니다. JSX를 통해서 HTML 구조가 들어와있을 뿐만 아니라 요즘에는 CSS 관리도 JavaScript에서 하는 추세죠. 이 접근 법도 나름대로 장점이 있습니다만 모든 개발자들에게 적합하다고 하기에는 단점이 좀 있습니다. Vue는 고전적인 웹기술들을 받아들여서 그 기반 위에 만들어졌습니다. 몇 가지 예를 통해서 무슨 뜻인지 살펴보겠습니다. JSX vs TemplateReact에서 모든 컴포넌트는 JSX를 사용하는 렌더링 함수를 통해서 UI를 표현합니다. JSX는 JavaScript에서 작동하는 선언적인 XML 유사 문법입니다.React에서 모든 컴포넌트는 JavaScript에서 작동하는 선언적 XML 유사 구문인 JSX를 사용해 렌더링 함수 안에서 UI를 표현합니다. JSX를 이용하는 렌더링 함수를 사용하면 몇 가지 장점이 있습니다. 완전한 프로그레밍 언어(JavaScript)를 이용해서 뷰를 만들 수 있습니다. 임시 변수, 플로우 제어에 스코프 내에서 직접적으로 JavaScript의 값을 가져다 쓸 수도 있겠죠. JSX의 툴 지원(예: linting, 형 검사, 자동완성 기능)은 어떤 측면에서 현재 사용할 수 있는 Vue 템플릿보다 더 진보된 기능입니다. Vue에서도 렌더링 함수에 심지어 JSX 지원을 쓸 수 있습니다. 때로는 그 힘이 필요하거든요. 하지만 기본적으로는 템플릿 이용을 더 간단한 대안으로 제공합니다. 때로는 그 강력함이 필요하기 때문입니다. 그러나 기본적으로 우리는 더 간단한 대안으로 템플릿을 제공합니다. 잘 작동하는 HTML은 Vue 템플릿으로도 잘 작동하며 여기에서 오는 장점들이 있습니다. HTML로 작업해온 많은 개발자에게는 템플릿을 읽고 쓰는 것이 어렵지 않습니다. 선호라는 것은 다소 주관적일 수도 있겠지만 개발자의 생산성이 올라간다면 그건 객관적인 거죠. HTML 기반 템플릿을 이용하면 기존의 어플리케이션을 Vue로 점진적으로 이전하기가 훨씬 쉽습니다. 또한 디자이너와 경험이 적은 개발자들이 코드를 분석하고 기여하기에도 훨씬 쉽습니다.(역자: 러닝 커브가 낮습니다) Vue 템플릿을 쓸 때 Pug(이전의 Jade)같은 프리프로세서를 사용할 수도 있습니다. 어떤 사람들은 템플릿을 작성하기 위해서는 별도의 언어(DSL, Domain-Specific Language)를 또 배워야 한다고도 합니다. 하지만 저희가 볼 때는 그 차이가 기껏해봐야 매우 피상적인 수준이라고 생각합니다. 먼저 JSX도 사용하려면 학습을 해야 합니다. JSX도 플레인 JavaScript에 문법이 추가되어 있어서 JavaScript에 익숙한 사람이라면 공부할 것이 많지는 않겠지만 따로 더 배울게 없다고 할 수는 없죠. 비슷하게 템플릿도 플레인 HTML에 문법을 추가한 것이라서 HTML에 익숙한 사람에게는 공부할 것이 많지 않습니다. 별도의 언어(역자: 템플릿 문법)를 써서 사용자들이 더 적은 코드(예: v-on 수식어)를 써서 더 많을 것을 처리할 수 있습니다. JSX나 렌더링 함수를 쓰면 같은 일을 처리하기 위해서 더 많은 코드를 써야 합니다. 좀 더 높은 수준에서 이야기하자면 컴포넌트는 표현형과 논리형 두 가지로 나눌 수 있습니다. 템플릿은 표현형 컴포넌트에, 렌더링 함수와 JSX는 논리형 컴포넌트에 사용하는 것이 좋습니다. 어떤 어플리케이션을 만드는가에 따라 어느 형의 컴포넌트가 많을 지는 다릅니다만 일반적으로는 표현형 컴포넌트가 더 많습니다. 컴포넌트 범위의 CSS컴포넌트를 여러 파일 (예: CSS 모듈)을 통해 배포하지 않는 한 React의 CSS 범위 지정은 CSS-in-JS 방식으로 해결합니다. (e.g. styled-components, glamorous, 그리고 emotion) 이는 일반적인 CSS 작성 프로세스와는 다른 새로운 컴포넌트 지향 스타일링 패러다임을 뜻합니다. 또한 빌드타임에 단일 스타일시트에 CSS를 추출할 수 있는 지원이 있지만 스타일이 제대로 작동하려면 런타임이 번들에 포함되어야하는 것이 일반적입니다. 스타일을 작성하는 동안 JavaScript의 역동적인 기능을 사용할 수 있지만 증가한 번들 크기 및 런타임 비용으로 종종 그 대가를 치룹니다. CSS-in-JS의 팬이라면 유명한 CSS-in-JS 라이브러리들도 Vue를 지원한다는 점을 눈여겨봐주시기 바랍니다.(예 styled-components-vue와 vue-emotion). 여기서 React와 Vue의 가장 큰 차이점은 Vue에서는 기본 스타일링 방식으로 싱글 파일 컴포넌트 안에서 우리에게 익숙한 style 태그를 사용한다는 것입니다. 싱글 파일 컴포넌트를 통해서 다른 컴포넌트 코드와 마찬가지로 CSS에 접근할 수 있습니다. 1234567&lt;style scoped&gt; @media (min-width: 250px) &#123; .list-container:hover &#123; background: orange; &#125; &#125;&lt;/style&gt; 옵션인 scoped 속성은 자동적으로 엘리먼트에 유일한 속성(예 : data-v-21e5b78)을 추가해서 .list-container:hover를 .list-container[data-v-21e5b78]:hover로 컴파일 합니다. 마지막으로 Vue의 싱글 파일 컴포넌트의 스타일은 매우 유연합니다. vue-loader를 통해 전처리기, 포스트 프로세서 및 CSS Modules와의 긴밀한 통합을 할 수 있습니다. 모든 스타일은 &lt;style&gt; 엘리먼트 안에 있습니다. 규모규모 확장대형 애플리케이션의 경우 Vue와 React는 강력한 라우팅 솔루션을 제공합니다. React 커뮤니티는 또한 상태 관리 솔루션 (Flux/Redux 등) 측면에서 매우 혁신적입니다. 이러한 상태 관리 패턴과 심지어 Redux 자체는 Vue 애플리케이션에 쉽게 통합할 수 있습니다. 실제로, Vue는 우수한 모델 개발 경험을 제공한다고 생각하는 Vue에 깊이 통합되어있는 Elm의 영감을받은 상태 관리 솔루션인 Vuex를 통해 이 모델을 더욱 발전 시켰습니다. 또 다른 중요한 차이점은 상태 관리 및 라우팅을 위한 Vue의 기타 라이브러리 (기타 관심사 중)는 모두 공식적으로 지원되며 핵심 라이브러리와 함께 최신 상태로 유지된다는 것입니다. 반대로 React는 커뮤니티에 이러한 결정을 맡기고 더 분열 된 생태계를 만드는 것을 선택했습니다. 그 결과 React의 생태계는 Vue보다 훨씬 풍부합니다. 마지막으로, Vue는 CLI 프로젝트 생성기를 제공하여, 대화형식의 프로젝트 구축마법사를 이용해 새로운 프로젝트를 간단하게 시작할 수 있습니다. 또한, 컴포넌트의 인스턴트 프로토타이핑 또한 사용할 수 있습니다. 리액트에도 create-react-app이 있고, 이 분야에서 진보를 이루고 있습니다만, 현상황에서는 몇가지 제약이 있습니다. It does not allow any configuration during project generation, while Vue CLI runs on top of an upgradeable runtime dependency that can be extended via plugins. 단일 페이지 애플리케이션을 작성한다고 가정하는 단일 템플릿만 제공하며, Vue는 다양한 목적을 위해 다양한 템플릿를 제공하고 시스템을 빌드합니다. 엔터프라이즈 환경에서 특히 유용하게 사용될 수 있는 사용자 정의 프리셋으로부터의 프로젝트 생성을 할수 없습니다. 이러한 제한 사항 중 상당수는 create-react-app 팀이 의도적으로 설계한 것입니다. 예를 들어, 프로젝트의 요구가 매우 간단하고 빌드 프로세스를 사용자 정의하기 위해 “추출”할 필요가없는 한, 이를 종속으로 업데이트 할 수 있습니다. 여기에서 다른 철학에 대해 더 많이 읽을 수 있습니다. 규모 축소React는 가파른 학습 곡선으로 유명합니다. 실제로 시작하기 전에 JSX와 아마도 ES2015+에 대해 알아야합니다. 많은 예제가 React의 클래스 구문을 사용하기 때문입니다. Babel Standalone을 기술적으로 사용하여 브라우저에서 코드를 라이브 컴파일 할 수는 있지만 작성에 적합하지 않기 때문에 빌드 시스템에 대해서도 배워야합니다. React와 동일하게, Vue는 스케일 업도 가능한 한편, jQuery처럼 스케일 다운하는것 또한 가능합니다. 맞습니다. 처음 시작하기 위해서, 단 1줄의 스크립트 태그를 삽입하는것 만으로 충분합니다. 1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; Vue 코드를 작성하고 성능 문제에 대해 걱정할 필요없이 걱정하지 않고 최소화 버전을 배포 버전에 제공 할 수 있습니다. Vue를 시작하기 위해 JSX, ES2015 또는 빌드 시스템에 대해 알 필요가 없으므로 일반적으로 개발자가 일상적인 애플리케이션을 빌드하는 데 필요한 충분한 지식을 얻기 위해 가이드를 읽는 데 하루가 걸리지 않습니다. 네이티브 렌더링ReactNative를 사용하면 같은 React 컴포넌트 모델을 사용하여 iOS 및 Android 용 기본 렌더링 애플리케이션을 작성할 수 있습니다. 이것은 개발자로서 여러 플랫폼에서 에 대한 지식을 적용할 수 있다는 점에서 매우 좋습니다. Vue는 Vue를 JavaScript 런타임으로 사용하는 Alibaba Group에서 개발 한 크로스 플랫폼 UI인 Weex와 공식 협업을 맺고 있습니다. 즉, Weex를 사용하면 같은 Vue 컴포넌트 문법을 사용하여 브라우저에서 렌더링할 수 있을 뿐만 아니라 iOS 및 Android에서도 렌더링 할 수있는 컴포넌트를 작성할 수 있습니다! 현재 Weex는 아직 개발 중이며 ReactNative만큼 성숙하고 전투적인 테스트를 거치지는 않았지만 개발은 세계 최대의 전자 상거래 비즈니스의 생산 요구에 의해 주도되고 있고 Vue 팀은 적극적으로 협력 할 것입니다. Weex 팀과 함께 Vue 개발자를위한 원활한 경험을 보장합니다. NativeScript는 또 다른 대안입니다. 커뮤니티 주도 플러그인이 개발 중입니다. MobXMobX는 React 커뮤니티에서 꽤 유명해졌고 실제로 Vue와 거의 같은 반응형 시스템을 사용합니다. 제한된 범위 내에서 React + MobX 워크플로우는 좀 더 장황한 Vue로 생각할 수 있습니다. 따라서 이 조합을 사용하고 있고 그것을 즐기고 있다면 Vue로 넘어오는 것이 아마도 다음 단계일 것입니다. Preact와 React 계열 라이브러리React같은 라이브러리는 대개 실현 가능한 React와 API와 생태계를 공유하려고 노력합니다. 이러한 이유로, 위의 대부분의 비교도 그들에게 적용될 것입니다. 주된 차이점은 일반적으로 React에 비해 생태계가 현저히 축소되는 것입니다. 이러한 라이브러리들은 React 생태계의 모든 것과 100% 호환될 수 없으므로 일부 툴링 및 동반 라이브러리는 사용할 수 없을 수도 있습니다. 혹은 작동하는 것처럼 보여도, 당신 react계열 라이브러리가 React와 동등한 공식 지원을 받지 않는 한 언제라도 구현이 깨질 수도 있습니다. Preact and Other React-Like LibrariesReact-like libraries usually try to share as much of their API and ecosystem with React as is feasible. For that reason, the vast majority of comparisons above will also apply to them. The main difference will typically be a reduced ecosystem, often significantly, compared to React. Since these libraries cannot be 100% compatible with everything in the React ecosystem, some tooling and companion libraries may not be usable. Or, even if they appear to work, they could break at any time unless your specific React-like library is officially supported on par with React. AngularJS (Angular 1)일부 Vue의 문법은 Angular와 매우 유사합니다 (예 :v-if와ng-if). Angular가 제대로 된 많은 것들을 가지고 있었기 때문에 이것은 개발 초기에 Vue에게 영감이 되었습니다. Angular와 함께 제공되는 많은 고통이 있었지만 Vue가 상당한 개선을 제공하려고 시도하였습니다. 복잡도Vue는 API와 디자인면에서 Angular 1보다 훨씬 간단합니다. 평범하지 않은 애플리케이션을 작성하기에 충분한 학습기간은 일반적으로 1 일 미만으로 소요되며 Angular 1에서는 그렇지 않습니다. 유연성과 모듈성Angular는 애플리케이션을 어떻게 구성해야 하는지에 대한 강요가 강하고 Vue는 더욱 유연하고 모듈방식의 솔루션입니다. 이로 인해 Vue는 다양한 프로젝트에보다 적합하게 적용될 수 있으며, 때로는 코딩을 시작하기 위해 의사 결정을 내리는데 유용 할 때가 있습니다. 그렇기 때문에 핫 모듈 리로딩, 린트 (linting), CSS 추출과 같은 고급 기능에 대한 액세스 권한을 부여하는 동시에 빠르게 설정할 수있는 Vue CLI를 제공합니다. 데이터 바인딩Angular 1은 스코프간 양방향 바인딩을 사용하는 반면 Vue는 컴포넌트 간에 단방향의 데이터 흐름을 사용합니다. 이로 인해 데이터의 흐름이 단순한 애플리케이션에서는 데이터의 흐름을 쉽게 파악할 수 있습니다. 디렉티브 vs 컴포넌트Vue는 디렉티브와 컴포넌트를 명확하게 구분합니다. 지시어는 DOM 조작만 캡슐화 하기 위한 것이고 컴포넌트는 자체 뷰와 데이터 로직이 있는 자체의 포함 단위입니다. Angular에서는 이 둘 사이에 많은 혼란이 있습니다. 런타임 퍼포먼스Vue는 더 나은 성능을 가지며 변경에 대한 검사를 하지 않기 때문에 훨씬 쉽게 최적화 할 수 있습니다. Angular 1은 감시자가 많으면 느려집니다. 범위가 변경 될 때마다 이러한 모든 감시자를 다시 평가해야하기 때문입니다. 또한 일부 감시자가 다른 업데이트를 트리거하는 경우 다이제스트 주기를 여러 번 실행하여 “안정화”해야 할 수도 있습니다. Angular 사용자는 다이제스트 주기를 벗어나기 위해 종종 숨겨진 기술에 의지해야하며 경우에 따라 많은 감시자와 함께 범위를 최적화 할 수있는 방법이 없습니다. Vue는 비동기 대기열이 있는 투명한 종속성 추적 관찰 시스템을 사용하기 때문에이 문제가 전혀 발생하지 않습니다. 모든 변경 사항은 명시적 종속 관계가 없는 한 독립적으로 트리거됩니다. 흥미롭게도 AngularJS와 Vue가 문제를 해결하는 방법에는 몇 가지 유사점이 있습니다. Angular (Formerly known as Angular 2)Angular 2는 완전히 새로운 것이기 때문에 별도의 섹션을 만들었습니다. 예를 들어, 1급 컴포넌트 시스템이 있으며 많은 구현 세부 사항이 완전히 다시 작성 되었으며 API도 상당히 크게 변경되었습니다. TypeScriptAngular는 TypeScript가 필수적입니다. 문서 또한 TypeScript 기반입니다. TypeScript를 사용하면 Java와 C#을 다루던 사용자에게 생산성을 올려주고 정적 타입 체크 등의 많은 이익이 있습니다. 그러나 모든 사람들이 TypeScript를 사용하려고 하지는 않습니다. 많은 소규모 사례에서 TypeScript를 사용하면 생산성 향상보다 더 많은 오버헤드가 발생할 수 있습니다. 이 경우 TypeScript 없이 Angular를 사용하는 것이 어려울 수 있기 때문에 Vue를 사용하는 것이 좋습니다. Vue는 엔터프라이즈 환경에도 매우 적합하며 공식 Typings 및 공식 decorator를 통해 TypeScript와 함께 사용할 수도 있습니다. 런타임 퍼포먼스두 프레임워크 모두 빠르며 비슷한 벤치마크 결과를 보여줍니다. 브라우저에 초점을 맞춘 분석을 보면 더욱 상세하게 비교를 하실 수 있을 것입니다. 그러나 속도는 선택할 때 큰 영향을 줄 것으로 생각되지 않습니다. 용량최신 AOT compilation과 tree-shaking을 포함한 Angular는 크기가 매우 작어졌습니다. 그럼에도 불구하고 모든 기능을 갖춘 Vue 2 프로젝트(30kb gzipped)는 angular-cli(130kb gzipped)보다 훨씬 작습니다. 유연성Vue는 Angular 2보다 훨씬 덜 강요적이며, 다양한 빌드 시스템에 대한 공식적인 지원을 제공하며 애플리케이션 구조를 제한하지 않습니다. 많은 개발자가 이러한 자유를 누리고 있지만 일부 개발자는 모든 애플리케이션을 빌드하는 데 올바른 방법이 하나만 있는 것을 선호합니다. 학습 곡선Vue를 시작하려면 HTML 및 ES5 JavaScript (즉, 일반 자바 스크립트)에 익숙해야합니다. 이러한 기본 기술을 사용하면 안내서를 읽는 하루 만에 작은 애플리케이션을 작성할 수 있습니다. Angular의 학습곡선은 훨씬 가파릅니다. 프레임워크 API는 방대하며 생산성이 올라가기 전에 매우 많은 것들을 알아야합니다. Angular의 복잡성은 대규모 앱을 목표로 합니다. 하지만 경험이 부족한 개발자가 선택하기에 훨씬 어렵습니다. EmberEmber는 높은 찬사를 받는 완전한 기능의 프레임워크입니다. 그것은 많은 기존의 관행을 제공하며, 일단 익숙해지면 생산성을 높일 수 있습니다. 그러나 이는 학습 곡선이 높고 유연성이 떨어지는 것을 의미합니다. 함께 작동하는 느슨하게 결합 된 도구 집합을 사용하여 독창적인 프레임워크와 라이브러리를 선택하려고 하면 트레이드 오프가 있습니다. 후자는 더 많은 자유를 제공하지만 더 많은 구조에 대한 결정을 요구합니다. 즉, Vue 코어와 Ember의 templating 및 객체 모델 레이어을 비교하면 더 잘 알 수 있습니다. Vue는 일반 JavaScript 객체 및 완전히 자동으로 계산된 속성에 대해 눈에 거슬리지 않는 반응형을 제공합니다. Ember에서는 Ember 객체의 모든 것을 랩핑하고 계산된 속성의 종속성을 수동으로 선언 해야합니다. Vue의 템플릿 문법은 JavaScript 표현식의 모든 기능을 활용하지만 Handlebars의 표현식 및 헬퍼 문법은 의도적으로 비교할 때 매우 제한적입니다. 성능 측면에서 Vue는 Ember 2.0의 최신 Glimmer 엔진 업데이트 이후에도 Ember보다 월등히 뛰어납니다. Vue는 업데이트를 자동으로 일괄 처리하지만 Ember에서는 성능이 중요한 상황에서 실행 루프를 수동으로 관리해야합니다. KnockoutKnockout은 MVVM 및 의존성 추적의 개척자였으며 반응형 시스템은 Vue의 그것과 매우 유사합니다. 브라우저 지원은 IE6에 대한 지원과 함께 모든 것을 고려하여 매우 인상적입니다! Vue는 IE9+ 만 지원합니다. 하지만 시간이 지남에 따라 개발 속도가 느려졌고 오래되어 보이기 시작했습니다. 예를 들어 컴포넌트 시스템에는 라이프 사이클 훅이 전혀 없으며 매우 일반적인 사용 사례이지만 컴포넌트에 자식을 전달하기위한 인터페이스는 Vue에 비해 약간 어색함을 느낄 수 있습니다. API 디자인에는 철학적인 차이가 있는 것 같아 호기심이 생긴다면 단순한 할 일 목록을 어떻게 작성하는지 보여줄 수 있습니다. 분명히 다소 주관적이지만, 많은 사람들은 Vue의 API가 덜 복잡하고 구조가 잘 구성되어 있다고 생각합니다. PolymerPolymer는 Google이 후원하는 또 다른 프로젝트이며 실제로 Vue의 영감의 원천이었습니다. Vue의 컴포넌트는 Polymer의 사용자 지정 엘리먼트와 느슨하게 비교할 수 있으며 둘 다 매우 유사한 개발 스타일을 제공합니다. 가장 큰 차이점은 Polymer는 최신 웹 컴포넌트 기능을 기반으로하며 이러한 기능을 기본적으로 지원하지 않는 브라우저에서는 성능이 저하되는 약간의 폴리필을 요구합니다. 대조적으로, Vue는 IE9에 의존성이나 폴리필이 없이도 작동합니다. Polymer 1.0에서 팀은 성능을 보완하기 위해 데이터 바인딩 시스템을 매우 제한적으로 만들었습니다. 예를 들어, Polymer 템플릿에서 지원되는 유일한 표현식은 Boolean 부정 및 단일 메소드 호출입니다. 계산된 속성 구현 또한 매우 유연하지 않습니다. Polymer 사용자 정의 엘리먼트는 HTML 파일로 제작되어 일반 JavaScript/CSS(및 현재 브라우저에서 지원되는 언어 기능)로 제한됩니다. 이에 비해 Vue의 싱글 파일 컴포넌트를 사용하면 ES2015+ 및 원하는 모든 CSS 전처리기를 쉽게 사용할 수 있습니다. 프로덕션 환경으로 배포 할 때 Polymer는 브라우저에서 스펙을 구현한다고 가정하는 HTML 가져오기 및 서버와 클라이언트 모두에서 HTTP/2 지원을 사용하여 모든 것을 로드하는 것을 권장합니다. 이는 대상 사용자 및 배포 환경에 따라 가능할 수도 있고 그렇지 않을 수도 있습니다. 이것이 바람직하지 않은 경우에는 Vulcanizer라고하는 특수 도구를 사용하여 폴리머 엘리먼트를 묶어야합니다. 앞에서 볼 때 Vue는 비동기 컴포넌트 기능과 Webpack의 코드 분할 기능을 결합하여 애플리케이션 번들의 일부를 지연 로드 되도록 쉽게 분리 할 수 있습니다. 이를 통해 이전 브라우저와의 호환성을 유지하면서 앱 로드 성능을 높일 수 있습니다. Vue와 사용자 정의 엘리먼트 및 Shadow DOM 스타일 캡슐화와 같은 웹 컴포넌트 스펙을 더욱 완벽하게 통합하는 것도 가능합니다. 그러나 현재로서는 모든 주요 브라우저에서 사양을 성숙시키고 광범위하게 구현하기를 기다리고 있습니다. RiotRiot 3.0은 작고 아름답게 디자인 된 API를 사용하여 유사한 컴포넌트 기반 개발 모델 (Riot에서 “태그”라고 함)을 제공합니다. Riot과 Vue는 디자인 철학에 많은 부분을 공유합니다. 그러나 Vue는 Riot보다 약간 무겁지만 몇 가지 중요한 이점을 제공합니다. 더 나은 성능. 가상 DOM을 사용하는 것보다 Riot은 DOM 트리 순회를 하므로 앵귤러 1과 같은 성능 문제가 있습니다. 보다 성숙한 도구 지원. Vue는 Webpack및 Browserify에 대한 공식적으로 지원하지만 Riot는 빌드 시스템 통합을 커뮤니티 지원에 의존합니다.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"Handling Edge Cases","date":"2019-02-06T10:04:47.000Z","path":"wiki/vue/components-edge-cases/","text":"This page assumes you’ve already read the Components Basics. Read that first if you are new to components. All the features on this page document the handling of edge cases, meaning unusual situations that sometimes require bending Vue's rules a little. Note however, that they all have disadvantages or situations where they could be dangerous. These are noted in each case, so keep them in mind when deciding to use each feature. ## Element & Component Access In most cases, it’s best to avoid reaching into other component instances or manually manipulating DOM elements. There are cases, however, when it can be appropriate. Accessing the Root InstanceIn every subcomponent of a new Vue instance, this root instance can be accessed with the $root property. For example, in this root instance: 123456789101112// The root Vue instancenew Vue(&#123; data: &#123; foo: 1 &#125;, computed: &#123; bar: function () &#123; /* ... */ &#125; &#125;, methods: &#123; baz: function () &#123; /* ... */ &#125; &#125;&#125;) All subcomponents will now be able to access this instance and use it as a global store: 1234567891011// Get root datathis.$root.foo// Set root datathis.$root.foo = 2// Access root computed propertiesthis.$root.bar// Call root methodsthis.$root.baz() This can be convenient for demos or very small apps with a handful of components. However, the pattern does not scale well to medium or large-scale applications, so we strongly recommend using Vuex to manage state in most cases. ### Accessing the Parent Component Instance Similar to $root, the $parent property can be used to access the parent instance from a child. This can be tempting to reach for as a lazy alternative to passing data with a prop. In most cases, reaching into the parent makes your application more difficult to debug and understand, especially if you mutate data in the parent. When looking at that component later, it will be very difficult to figure out where that mutation came from. There are cases however, particularly shared component libraries, when this _might_ be appropriate. For example, in abstract components that interact with JavaScript APIs instead of rendering HTML, like these hypothetical Google Maps components: 123&lt;google-map&gt; &lt;google-map-markers v-bind:places=\"iceCreamShops\"&gt;&lt;/google-map-markers&gt;&lt;/google-map&gt; The &lt;google-map&gt; component might define a map property that all subcomponents need access to. In this case &lt;google-map-markers&gt; might want to access that map with something like this.$parent.getMap, in order to add a set of markers to it. You can see this pattern in action here. Keep in mind, however, that components built with this pattern are still inherently fragile. For example, imagine we add a new &lt;google-map-region&gt; component and when &lt;google-map-markers&gt; appears within that, it should only render markers that fall within that region: 12345&lt;google-map&gt; &lt;google-map-region v-bind:shape=\"cityBoundaries\"&gt; &lt;google-map-markers v-bind:places=\"iceCreamShops\"&gt;&lt;/google-map-markers&gt; &lt;/google-map-region&gt;&lt;/google-map&gt; Then inside &lt;google-map-markers&gt; you might find yourself reaching for a hack like this: 1var map = this.$parent.map || this.$parent.$parent.map This has quickly gotten out of hand. That’s why to provide context information to descendent components arbitrarily deep, we instead recommend dependency injection. Accessing Child Component Instances &amp; Child ElementsDespite the existence of props and events, sometimes you might still need to directly access a child component in JavaScript. To achieve this you can assign a reference ID to the child component using the ref attribute. For example: 1&lt;base-input ref=\"usernameInput\"&gt;&lt;/base-input&gt; Now in the component where you’ve defined this ref, you can use: 1this.$refs.usernameInput to access the &lt;base-input&gt; instance. This may be useful when you want to, for example, programmatically focus this input from a parent. In that case, the &lt;base-input&gt; component may similarly use a ref to provide access to specific elements inside it, such as: 1&lt;input ref=\"input\"&gt; And even define methods for use by the parent: 123456methods: &#123; // Used to focus the input from the parent focus: function () &#123; this.$refs.input.focus() &#125;&#125; Thus allowing the parent component to focus the input inside &lt;base-input&gt; with: 1this.$refs.usernameInput.focus() When ref is used together with v-for, the ref you get will be an array containing the child components mirroring the data source. $refs are only populated after the component has been rendered, and they are not reactive. It is only meant as an escape hatch for direct child manipulation - you should avoid accessing $refs from within templates or computed properties. ### Dependency Injection Earlier, when we described Accessing the Parent Component Instance, we showed an example like this: 12345&lt;google-map&gt; &lt;google-map-region v-bind:shape=\"cityBoundaries\"&gt; &lt;google-map-markers v-bind:places=\"iceCreamShops\"&gt;&lt;/google-map-markers&gt; &lt;/google-map-region&gt;&lt;/google-map&gt; In this component, all descendants of &lt;google-map&gt; needed access to a getMap method, in order to know which map to interact with. Unfortunately, using the $parent property didn’t scale well to more deeply nested components. That’s where dependency injection can be useful, using two new instance options: provide and inject. The provide options allows us to specify the data/methods we want to provide to descendent components. In this case, that’s the getMap method inside &lt;google-map&gt;: 12345provide: function () &#123; return &#123; getMap: this.getMap &#125;&#125; Then in any descendants, we can use the inject option to receive specific properties we’d like to add to that instance: 1inject: ['getMap'] You can see the full example here. The advantage over using $parent is that we can access getMap in any descendant component, without exposing the entire instance of &lt;google-map&gt;. This allows us to more safely keep developing that component, without fear that we might change/remove something that a child component is relying on. The interface between these components remains clearly defined, just as with props. In fact, you can think of dependency injection as sort of “long-range props”, except: ancestor components don’t need to know which descendants use the properties it provides descendant components don’t need to know where injected properties are coming from However, there are downsides to dependency injection. It couples components in your application to the way they're currently organized, making refactoring more difficult. Provided properties are also not reactive. This is by design, because using them to create a central data store scales just as poorly as using $root for the same purpose. If the properties you want to share are specific to your app, rather than generic, or if you ever want to update provided data inside ancestors, then that's a good sign that you probably need a real state management solution like Vuex instead. Learn more about dependency injection in [the API doc](https://vuejs.org/v2/api/#provide-inject). Programmatic Event ListenersSo far, you’ve seen uses of $emit, listened to with v-on, but Vue instances also offer other methods in its events interface. We can: Listen for an event with $on(eventName, eventHandler) Listen for an event only once with $once(eventName, eventHandler) Stop listening for an event with $off(eventName, eventHandler) You normally won’t have to use these, but they’re available for cases when you need to manually listen for events on a component instance. They can also be useful as a code organization tool. For example, you may often see this pattern for integrating a 3rd-party library: 1234567891011121314// Attach the datepicker to an input once// it's mounted to the DOM.mounted: function () &#123; // Pikaday is a 3rd-party datepicker library this.picker = new Pikaday(&#123; field: this.$refs.input, format: 'YYYY-MM-DD' &#125;)&#125;,// Right before the component is destroyed,// also destroy the datepicker.beforeDestroy: function () &#123; this.picker.destroy()&#125; This has two potential issues: It requires saving the picker to the component instance, when it’s possible that only lifecycle hooks need access to it. This isn’t terrible, but it could be considered clutter. Our setup code is kept separate from our cleanup code, making it more difficult to programmatically clean up anything we set up. You could resolve both issues with a programmatic listener: 12345678910mounted: function () &#123; var picker = new Pikaday(&#123; field: this.$refs.input, format: 'YYYY-MM-DD' &#125;) this.$once('hook:beforeDestroy', function () &#123; picker.destroy() &#125;)&#125; Using this strategy, we could even use Pikaday with several input elements, with each new instance automatically cleaning up after itself: 12345678910111213141516mounted: function () &#123; this.attachDatepicker('startDateInput') this.attachDatepicker('endDateInput')&#125;,methods: &#123; attachDatepicker: function (refName) &#123; var picker = new Pikaday(&#123; field: this.$refs[refName], format: 'YYYY-MM-DD' &#125;) this.$once('hook:beforeDestroy', function () &#123; picker.destroy() &#125;) &#125;&#125; See this fiddle for the full code. Note, however, that if you find yourself having to do a lot of setup and cleanup within a single component, the best solution will usually be to create more modular components. In this case, we’d recommend creating a reusable &lt;input-datepicker&gt; component. To learn more about programmatic listeners, check out the API for Events Instance Methods. Note that Vue's event system is different from the browser's EventTarget API. Though they work similarly, $emit, $on, and $off are not aliases for dispatchEvent, addEventListener, and removeEventListener. ## Circular References Recursive ComponentsComponents can recursively invoke themselves in their own template. However, they can only do so with the name option: 1name: 'unique-name-of-my-component' When you register a component globally using Vue.component, the global ID is automatically set as the component’s name option. 123Vue.component('unique-name-of-my-component', &#123; // ...&#125;) If you’re not careful, recursive components can also lead to infinite loops: 12name: 'stack-overflow',template: '&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;' A component like the above will result in a “max stack size exceeded” error, so make sure recursive invocation is conditional (i.e. uses a v-if that will eventually be false). Circular References Between ComponentsLet’s say you’re building a file directory tree, like in Finder or File Explorer. You might have a tree-folder component with this template: 1234&lt;p&gt; &lt;span&gt;&#123;&#123; folder.name &#125;&#125;&lt;/span&gt; &lt;tree-folder-contents :children=\"folder.children\"/&gt;&lt;/p&gt; Then a tree-folder-contents component with this template: 123456&lt;ul&gt; &lt;li v-for=\"child in children\"&gt; &lt;tree-folder v-if=\"child.children\" :folder=\"child\"/&gt; &lt;span v-else&gt;&#123;&#123; child.name &#125;&#125;&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt; When you look closely, you’ll see that these components will actually be each other’s descendent and ancestor in the render tree - a paradox! When registering components globally with Vue.component, this paradox is resolved for you automatically. If that’s you, you can stop reading here. However, if you’re requiring/importing components using a module system, e.g. via Webpack or Browserify, you’ll get an error: 1Failed to mount component: template or render function not defined. To explain what’s happening, let’s call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc. It’s stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, “A needs B eventually, but there’s no need to resolve B first.” In our case, let’s make that point the tree-folder component. We know the child that creates the paradox is the tree-folder-contents component, so we’ll wait until the beforeCreate lifecycle hook to register it: 123beforeCreate: function () &#123; this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default&#125; Or alternatively, you could use Webpack’s asynchronous import when you register the component locally: 123components: &#123; TreeFolderContents: () =&gt; import('./tree-folder-contents.vue')&#125; Problem solved! Alternate Template DefinitionsInline TemplatesWhen the inline-template special attribute is present on a child component, the component will use its inner content as its template, rather than treating it as distributed content. This allows more flexible template-authoring. 123456&lt;my-component inline-template&gt; &lt;div&gt; &lt;p&gt;These are compiled as the component's own template.&lt;/p&gt; &lt;p&gt;Not parent's transclusion content.&lt;/p&gt; &lt;/div&gt;&lt;/my-component&gt; Your inline template needs to be defined inside the DOM element to which Vue is attached. However, inline-template makes the scope of your templates harder to reason about. As a best practice, prefer defining templates inside the component using the template option or in a &lt;template&gt; element in a .vue file. ### X-Templates Another way to define templates is inside of a script element with the type text/x-template, then referencing the template by an id. For example: 123&lt;script type=\"text/x-template\" id=\"hello-world-template\"&gt; &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/script&gt; 123Vue.component('hello-world', &#123; template: '#hello-world-template'&#125;) Your x-template needs to be defined outside the DOM element to which Vue is attached. These can be useful for demos with large templates or in extremely small applications, but should otherwise be avoided, because they separate templates from the rest of the component definition. ## Controlling Updates Thanks to Vue’s Reactivity system, it always knows when to update (if you use it correctly). There are edge cases, however, when you might want to force an update, despite the fact that no reactive data has changed. Then there are other cases when you might want to prevent unnecessary updates. Forcing an UpdateIf you find yourself needing to force an update in Vue, in 99.99% of cases, you've made a mistake somewhere. You may not have accounted for change detection caveats [with arrays](https://vuejs.org/v2/guide/list.html#Caveats) or [objects](https://vuejs.org/v2/guide/list.html#Object-Change-Detection-Caveats), or you may be relying on state that isn't tracked by Vue's reactivity system, e.g. with `data`. However, if you’ve ruled out the above and find yourself in this extremely rare situation of having to manually force an update, you can do so with $forceUpdate. Cheap Static Components with v-onceRendering plain HTML elements is very fast in Vue, but sometimes you might have a component that contains a lot of static content. In these cases, you can ensure that it’s only evaluated once and then cached by adding the v-once directive to the root element, like this: 12345678Vue.component('terms-of-service', &#123; template: ` &lt;div v-once&gt; &lt;h1&gt;Terms of Service&lt;/h1&gt; ... a lot of static content ... &lt;/div&gt; `&#125;) Once again, try not to overuse this pattern. While convenient in those rare cases when you have to render a lot of static content, it's simply not necessary unless you actually notice slow rendering -- plus, it could cause a lot of confusion later. For example, imagine another developer who's not familiar with v-once or simply misses it in the template. They might spend hours trying to figure out why the template isn't updating correctly.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"슬롯(Slots)","date":"2019-02-04T10:04:47.000Z","path":"wiki/vue/components-slots/","text":"이 페이지는 여러분이 이미 컴포넌트 기초를 읽었다고 가정하고 쓴 내용입니다. 컴포넌트가 처음이라면 기초 문서를 먼저 읽으시기 바랍니다. 2.6.0 버전에서 ‘이름이 있는 슬롯’과 ‘범위를 가지는 슬롯’을 위한 새로운 통합 문법(‘v-slot’ 디렉티브)을 도입했습니다. 새 디렉티브가 slot과 slot-scope 속성을 대체하고 두 속성은 이제 사라질 예정입니다. 아직 삭제된 건 아니고 문서는 여기에서 볼 수 있습니다. 새 문법이 도입된 이유는 이 RFC에서 찾아볼 수 있습니다.(역자 주: 간략히 설명드리자면 기존 문법이 혼란스러운 부분이 있기 때문입니다. ‘이름이 있는 슬롯’과 ‘범위를 가지는 슬롯’을 동시에 쓸 때 좀 더 간결해지긴 하는데 슬롯 자체가 이해가 쉽지는 않습니다.) 슬롯에 들어가는 내용(Slot Content)Vue에 있는 컨텐트 배포 API는 &lt;slot&gt; 요소를 컨텐트 배포 통로로 사용하는 Web Components spec draft에서 영향을 받았습니다.(역자 주: 웹컴포넌트는 2011년에 최초로 제안된 개념으로 구글에서 주로 밀고 있습니다. 표준안만 나오면 가장 가볍고 보편적인 웹 프레임워크가 되었겠지만 브라우저 제작사들이 아직 표준안을 도출하지 못하고 있습니다. 대신 논의 과정에서 나온 여러 개념들이 리액트, 앵귤러, 뷰 등의 웹 프레임워크에 도입되어서 사용되고 있습니다.) 그래서 아래와 같은 컴포넌트를 만들 수 있습니다. 123&lt;navigation-link url=\"/profile\"&gt; Your Profile&lt;/navigation-link&gt; 그리고 &lt;navigation-link&gt; 템플릿을 아래와 같이 만들 수 있습니다. 123456&lt;a v-bind:href=\"url\" class=\"nav-link\"&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/a&gt; 컴포넌트를 렌더링할 때 &lt;slot&gt;&lt;/slot&gt;이 “Your Profile”로 교체됩니다. 슬롯에는 HTML 같은 템플릿 코드를 포함시킬 수 있기 때문입니다. 12345&lt;navigation-link url=\"/profile\"&gt; &lt;!-- Font Awesome 아이콘을 추가합시다 --&gt; &lt;span class=\"fa fa-user\"&gt;&lt;/span&gt; Your Profile&lt;/navigation-link&gt; 다른 컴포넌트(역자 주: &lt;font-awesome-icon&gt;)도 가능합니다. 12345&lt;navigation-link url=\"/profile\"&gt; &lt;!-- 컴포넌트로 아이콘을 추가해봅시다 --&gt; &lt;font-awesome-icon name=\"user\"&gt;&lt;/font-awesome-icon&gt; Your Profile&lt;/navigation-link&gt; 만약 &lt;navigation-link&gt; 템플릿이 &lt;slot&gt; 요소를 가지고 있지 않다면 그 자리에 들어갔어야 할 모든 내용이 무시될 것입니다. 컴파일될 때의 범위(Compilation Scope)슬롯 안에 데이터 옵션을 사용하고 싶을 수 있습니다. 아래의 예를 봅시다. 123&lt;navigation-link url=\"/profile\"&gt; Logged in as &#123;&#123; user.name &#125;&#125;&lt;/navigation-link&gt; 여기서 슬롯은 같은 템플릿의 나머지와 똑같은 인스턴스 속성(즉 같은 “범위”)에 연결되어 있습니다. 슬롯이 &lt;navigation-link&gt;의 범위에 연결된 것이 아닌 거죠. 예를 들어 url에 접근하려고 하면 작동하지 않을 것입니다. 12345678&lt;navigation-link url=\"/profile\"&gt; Clicking here will send you to: &#123;&#123; url &#125;&#125; &lt;!-- `url`은 undefined로 나올 겁니다. 이 데이터는 &lt;navigation-link&gt;_로_ 넘어가지만 &lt;navigation-link&gt; 컴포넌트 _안에_ 정의되어 있지는 않으니까요. --&gt;&lt;/navigation-link&gt; 이 규칙을 기억하세요. 부모 템플릿 안에 있는 것들은 부모 컴포넌트의 범위에 컴파일되고 자식 템플릿 안에 있는 것들은 자식 컴포넌트의 범위에 컴파일됩니다. 기본값 지정(Fallback Content)아무 컨텐트도 전달되지 않았을 때 슬롯에 렌더링시킬 대비책(즉 기본값)을 지정해놓는 것이 유용한 경우가 있을 수 있습니다. &lt;submit-button&gt; 컴포넌트의 예를 살펴봅시다. 123&lt;button type=\"submit\"&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/button&gt; 보통은 &lt;button&gt; 안에 “Submit” 텍스트가 들어가기를 원할 때가 많습니다. “Submit”을 기본값으로 만들기 위해서는 &lt;slot&gt; 태그 사이에 넣어야 합니다. 123&lt;button type=\"submit\"&gt; &lt;slot&gt;Submit&lt;/slot&gt;&lt;/button&gt; 이제 부모 컴포넌트의 &lt;submit-button&gt;를 사용할 때 아래와 같이 슬롯에 해당하는 아무 내용을 전달하지 않으면 1&lt;submit-button&gt;&lt;/submit-button&gt; 기본값인 “Submit”이 렌더링될 것입니다. 123&lt;button type=\"submit\"&gt; Submit&lt;/button&gt; 하지만 슬롯에 어떤 내용을 전달하면 123&lt;submit-button&gt; Save&lt;/submit-button&gt; 전달된 내용이 렌더링되겠죠. 123&lt;button type=\"submit\"&gt; Save&lt;/button&gt; 이름이 있는 슬롯(Named Slots) 2.6.0+에서 업데이트가 있었습니다. 여기에서 slot 속성을 사용하는 기존의 문법을 보실 수 있습니다. 여러 개의 슬롯을 쓰면 더 유용할 때가 있습니다. 예를 들어 &lt;base-layout&gt; 컴포넌트의 아래 템플릿을 봅시다. 1234567891011&lt;div class=\"container\"&gt; &lt;header&gt; &lt;!-- 헤더는 여기에 넣을 겁니다 --&gt; &lt;/header&gt; &lt;main&gt; &lt;!-- 본문은 여기에 넣을 겁니다 --&gt; &lt;/main&gt; &lt;footer&gt; &lt;!-- 푸터는 여기에 넣을 --&gt; &lt;/footer&gt;&lt;/div&gt; 이런 경우를 위해서 &lt;slot&gt; 요소는 서로 다른 슬롯들을 정의할 때 쓸 수 있는 name이라는 특별한 속성을 가지고 있습니다. 1234567891011&lt;div class=\"container\"&gt; &lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; name이 지정되지 않은 &lt;slot&gt;에는 암묵적으로 “default” 값이 사용됩니다. 이름이 있는 슬롯에 내용을 전달하려면 &lt;template&gt;에 v-slot 디렉티브를 쓰고 그 속성에 앞에서 지정한 ‘name’을 넣으면 됩니다. 123456789101112&lt;base-layout&gt; &lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/template&gt;&lt;/base-layout&gt; 이제 &lt;template&gt; 요소들의 모든 내용물이 적절한 슬롯으로 전달되었습니다. v-slot을 쓴 &lt;template&gt;으로 싸여있지 않은 내용물들은 디폴트 슬롯에 해당되는 것으로 간주합니다. 하지만 원한다면 명시적으로 &lt;template&gt;에 ‘default’를 표시하고 그 안에 내용을 넣을 수도 있습니다. 1234567891011121314&lt;base-layout&gt; &lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; &lt;template v-slot:default&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/template&gt;&lt;/base-layout&gt; 양쪽 모두 렌더링된 HTML은 아래와 같게 됩니다. 123456789101112&lt;div class=\"container\"&gt; &lt;header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 삭제될 예정인 slot 속성과 다르게 v-slot만 &lt;template&gt; 태그에 추가할 수 있다는 점을 유의하시기 바랍니다.(예외가 하나 있기는 합니다) 범위가 있는 슬롯(Scoped Slots) 2.6.0+에서 업데이트가 있었습니다. 여기에서 slot-scope 속성을 사용하는 기존의 문법을 보실 수 있습니다. 어떨 때는 자식 컴포넌트에서만 접근할 수 있는 데이터에서 슬롯에 필요한 내용을 가져와야 할 수 있습니다. 아래 템플릿의 &lt;current-user&gt; 컴포넌트의 예를 살펴봅시다. 123&lt;span&gt; &lt;slot&gt;&#123;&#123; user.lastName &#125;&#125;&lt;/slot&gt;&lt;/span&gt; 아래와 같이 기본값을 사용자의 성말고 이름으로 바꾸고 싶을 수도 있습니다. 123&lt;current-user&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt; 하지만 이 파일은 작동하지 않습니다. 왜냐하면 &lt;current-user&gt; 컴포넌트만 user에 접근할 수 있는데 슬롯에 제공되는 내용들은 부모 컴포넌트에서 렌더링되기 때문입니다. 부모 컴포넌트의 슬롯에서 user를 쓸려면 user를 &lt;slot&gt; 요소에 속성으로 연결해야 합니다. 12345&lt;span&gt; &lt;slot v-bind:user=\"user\"&gt; &#123;&#123; user.lastName &#125;&#125; &lt;/slot&gt;&lt;/span&gt; &lt;slot&gt; 요소에 연결된 속성을 슬롯 속성(slot props)라고 합니다. 이제 부모 컴포넌트의 범위(scope)에서 v-slot에 연결한 ‘슬롯 속성(slotProps)’를 쓸 수 있습니다. 12345&lt;current-user&gt; &lt;template v-slot:default=\"slotProps\"&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/template&gt;&lt;/current-user&gt; 이번 사례에서 모든 ‘슬롯 속성’의 이름을 ‘slotProps’라고 썼는데 이 이름은 당연히 사용자가 원하는 대로 바꿀 수 있습니다. 단독 디폴트 슬롯을 위한 축약 문법(Abbreviated Syntax for Lone Default Slots)위의 사례와 같이 제공된 내용이 디폴트 슬롯 밖에 없으면 컴포넌트의 태그를 슬롯의 템플릿으로 바로 쓸 수 있습니다. 즉 v-slot을 컴포넌트에다 쓸 수 있다는 것입니다.(역자 주: 바로 위의 컴포넌트 코드와 비교하세요.) 123&lt;current-user v-slot:default=\"slotProps\"&gt; &#123;&#123; slotProps.user.firstName &#125;&#125;&lt;/current-user&gt; 더 짧게도 만들 수 있습니다. 앞에서 다뤘듯이 특정되지 않은 내용은 디폴트 슬롯에 해당하는 것으로 간주하기 때문에, 속성이 없는 v-slot도 디폴트 슬롯으로 간주합니다.(역자 주: 위의 코드에서는 ‘default’가 ‘name’속성입니다.) 123&lt;current-user v-slot=\"slotProps\"&gt; &#123;&#123; slotProps.user.firstName &#125;&#125;&lt;/current-user&gt; 범위를 모호하게 만들기 때문에 디폴트 슬롯을 위한 축약 문법은 이름이 있는 슬롯들과 함께 쓸 수 없습니다. 1234567&lt;!-- 불가. 경고가 뜰 겁니다 --&gt;&lt;current-user v-slot=\"slotProps\"&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;template v-slot:other=\"otherSlotProps\"&gt; slotProps is NOT available here &lt;/template&gt;&lt;/current-user&gt; 여러 개의 슬롯이 있을 때는 &lt;template&gt;에 기초한 문법 전체를 모든 슬롯에 쓰기 바랍니다. 123456789&lt;current-user&gt; &lt;template v-slot:default=\"slotProps\"&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/template&gt; &lt;template v-slot:other=\"otherSlotProps\"&gt; ... &lt;/template&gt;&lt;/current-user&gt; 슬롯 속성 구조분해(Destructuring Slot Props)프레임워크 내부에서 ‘범위가 있는 슬롯’은 하나의 인수(역자 주: 슬롯 속성)를 가지는 함수로 슬롯에 들어가는 내용을 감싸는 방식으로 작동합니다. 123function (slotProps) &#123; // ... slot content ...&#125; v-slot의 값은 함수 정의식의 인수 위치에서 가능한 어떤 종류의 자바스크립트 표현식도 다 가능합니다. 그러므로 (싱글 파일 컴포넌트나 모던 브라우저처럼) 지원되는 모든 환경에서 아래와 같이 특정 슬롯 속성을 추출하는 ES2015 구조분해를 할 수 있다는 뜻입니다. 123&lt;current-user v-slot=\"&#123; user &#125;\"&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt; 이를 통해서 템플릿을 더 깨끗하게 만들 수 있습니다. 특히 슬롯에서 다양한 슬롯 속성들을 쓸 경우에 그렇습니다. 또 다른 기능으로 user를 person으로 바꾸는 것처럼 속성의 이름을 다시 정할 수도 있죠. 123&lt;current-user v-slot=\"&#123; user: person &#125;\"&gt; &#123;&#123; person.firstName &#125;&#125;&lt;/current-user&gt; 속성이 undefined이면 슬롯 슬롯에 들어갈 기본값을 정할 수도 있습니다. 123&lt;current-user v-slot=\"&#123; user = &#123; firstName: 'Guest' &#125; &#125;\"&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt; 가변 슬롯 이름(Dynamic Slot Names) 2.6.0+ 에서 추가 가변 디렉티브 인수는 가변 슬롯 이름을 정의하는 방식으로 v-slot에서도 작동합니다. 12345&lt;base-layout&gt; &lt;template v-slot:[dynamicSlotName]&gt; ... &lt;/template&gt;&lt;/base-layout&gt; 이름이 있는 슬롯 디렉티브의 단축표기(Named Slots Shorthand) 2.6.0+ 에서 추가 v-on과 v-bind처럼 v-slot도 단축표기를 가지고 있습니다. 인수 앞에 쓰는 부분(v-slot:)을 특수 기호인 #으로 대체하는 것입니다. 예를 들어 v-slot:header는 #header로 쓸 수도 있습니다. 123456789101112&lt;base-layout&gt; &lt;template #header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;template #footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/template&gt;&lt;/base-layout&gt; 하지만 다른 디렉티브와 마찬가지로 단축 표기는 오직 인수가 있을 때만 가능합니다. 즉 아래와 같은 문법은 불가능합니다. 1234&lt;!-- 이런 문법을 쓰면 경고가 나올 겁니다 --&gt;&lt;current-user #=\"&#123; user &#125;\"&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt; 그리고 단축 표기를 쓰려면 반드시 슬롯의 이름을 특정해야 합니다. 123&lt;current-user #default=\"&#123; user &#125;\"&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt; 다른 사례들(Other Examples)슬롯 속성을 통해 슬롯을 입력되는 속성에 따라 다른 내용을 렌더링할 수 있는 재사용가능한 템플릿으로 변환할 수 있습니다. 부모 컴포넌트를 레이아웃 용도로만 사용하고 데이터 로직을 캡슐화한 재사용가능 컴포넌트를 디자인할 때 가장 유용한 방법입니다. 아래에서 목록의 레이아웃과 필터링 로직을 담은 &lt;todo-list&gt; 컴포넌트를 쓸 것입니다. 12345678&lt;ul&gt; &lt;li v-for=\"todo in filteredTodos\" v-bind:key=\"todo.id\" &gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 각각의 할 일에 대해서 하드코딩된 내용을 쓰는 대신 모든 할일 들을 슬롯으로 만들어서 부모 컴포넌트가 관리할 수 있게 만들 수 있습니다. 그리고 todo를 슬롯 속성으로 연결시키는 거죠. 123456789101112131415&lt;ul&gt; &lt;li v-for=\"todo in filteredTodos\" v-bind:key=\"todo.id\" &gt; &lt;!-- 각 할일에 대해 슬롯을 만들고 `todo` 객체를 슬롯 속성으로 보냅니다. --&gt; &lt;slot name=\"todo\" v-bind:todo=\"todo\"&gt; &lt;!-- 기본값 --&gt; &#123;&#123; todo.text &#125;&#125; &lt;/slot&gt; &lt;/li&gt;&lt;/ul&gt; 이제 &lt;todo-list&gt; 컴포넌트를 쓸 때 할일 아이템들을 위해서 자식 컴포넌트의 데이터에도 접근할 수 있는 대체 &lt;template&gt;을 따로 정의할 수도 있습니다. 123456&lt;todo-list v-bind:todos=\"todos\"&gt; &lt;template v-slot:todo=\"&#123; todo &#125;\"&gt; &lt;span v-if=\"todo.isComplete\"&gt;✓&lt;/span&gt; &#123;&#123; todo.text &#125;&#125; &lt;/template&gt;&lt;/todo-list&gt; 하지만 이 정도는 범위가 있는 슬롯으로 무엇을 할 수 있는지 아주 조금 살펴본 것에 불과합니다. 실제로 범위가 있는 슬롯의 사용 예시를 보시려면 Vue Virtual Scroller, Vue Promised, Portal Vue같은 라이브러리들을 둘러볼 것을 추천드립니다. 삭제될 문법 v-slot 디렉티브는 slot과 slot-scope 인수들을 대체하는, 더 발전된 API로 Vue 2.6.0에 도입되었습니다. 새 문법이 도입된 이유는 이 RFC에서 찾아볼 수 있습니다. slot과 slot-scope 인수는 앞으로도 2.x 버전에서는 계속 지원될 것입니다. 하지만 Vue 3에서는 공식적으로 삭제될 예정입니다. slot 인수를 사용하는 이름이 있는 슬롯 2.6.0+ 부터 지원 중단 예정. 여기에서 권장되는 새 문법을 확인하세요. 내용물을 부모 컴포넌트에서 이름이 있는 슬롯에 보내려면 slot 인수를 &lt;template&gt;에서 사용해야 합니다.(여기에서 예시로 사용했던 &lt;base-layout&gt; 컴포넌트를 사용하겠습니다.) 123456789101112&lt;base-layout&gt; &lt;template slot=\"header\"&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;template slot=\"footer\"&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/template&gt;&lt;/base-layout&gt; 혹은 slot 인수를 일반 요소(element)에 바로 사용할 수도 있습니다. 12345678&lt;base-layout&gt; &lt;h1 slot=\"header\"&gt;Here might be a page title&lt;/h1&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;p slot=\"footer\"&gt;Here's some contact info&lt;/p&gt;&lt;/base-layout&gt; 여전히 이름이 없는 슬롯이 하나 있는데 이를 디폴트 슬롯이라고 하고 해당하는 슬롯이 없는 모든 내용들이 여기에 들어갑니다. 위의 두 예시 모두 HTML로 렌더링하면 아래와 같습니다. 123456789101112&lt;div class=\"container\"&gt; &lt;header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; slot-scope 인수를 사용하는 범위가 있는 슬롯 2.6.0+ 부터 지원 중단 예정. 여기에서 권장되는 새 문법을 확인하세요. 슬롯으로 전달된 속성들을 받기 위해서 부모 컴포넌트는 slot-scope 인수와 함께 &lt;template&gt;을 사용할 수 있습니다.(여기에서 예시로 사용했던 &lt;slot-example&gt; 컴포넌트를 사용하겠습니다.) 12345&lt;slot-example&gt; &lt;template slot=\"default\" slot-scope=\"slotProps\"&gt; &#123;&#123; slotProps.msg &#125;&#125; &lt;/template&gt;&lt;/slot-example&gt; 여기서 slot-scope은 넘겨받은 속성들을 slotProps 변수로 선언하고 &lt;template&gt; 범위 안에서 사용할 수 있도록 만들었습니다. slotProps라는 이름은 자바스크립트에서 함수의 인수 이름을 정하듯이 자유롭게 정할 수 있습니다. slot=&quot;default&quot;는 생략할 수도 있습니다. 12345&lt;slot-example&gt; &lt;template slot-scope=\"slotProps\"&gt; &#123;&#123; slotProps.msg &#125;&#125; &lt;/template&gt;&lt;/slot-example&gt; slot-scope 인수는 컴포넌트와 같이 &lt;template&gt; 요소가 아닌 곳에 바로 사용될 수도 있습니다. 12345&lt;slot-example&gt; &lt;span slot-scope=\"slotProps\"&gt; &#123;&#123; slotProps.msg &#125;&#125; &lt;/span&gt;&lt;/slot-example&gt; v-slot의 값은 함수 정의식의 인수 위치에서 가능한 어떤 종류의 자바스크립트 표현식도 다 가능합니다. 그러므로 (싱글 파일 컴포넌트나 모던 브라우저처럼) 지원되는 모든 환경에서 아래와 같이 특정 슬롯 속성을 추출하는 ES2015 구조분해를 할 수 있다는 뜻입니다. 12345&lt;slot-example&gt; &lt;span slot-scope=\"&#123; msg &#125;\"&gt; &#123;&#123; msg &#125;&#125; &lt;/span&gt;&lt;/slot-example&gt; 아래는 여기에서 사례로 설명한 &lt;todo-list&gt;와 똑같은 사례입니다. 123456&lt;todo-list v-bind:todos=\"todos\"&gt; &lt;template slot=\"todo\" slot-scope=\"&#123; todo &#125;\"&gt; &lt;span v-if=\"todo.isComplete\"&gt;✓&lt;/span&gt; &#123;&#123; todo.text &#125;&#125; &lt;/template&gt;&lt;/todo-list&gt;","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"커스텀 이벤트","date":"2019-02-03T10:04:47.000Z","path":"wiki/vue/components-custom-events/","text":"This page assumes you’ve already read the Components Basics. Read that first if you are new to components. 이벤트 이름Unlike components and props, event names don’t provide any automatic case transformation. Instead, the name of an emitted event must exactly match the name used to listen to that event. For example, if emitting a camelCased event name: 1this.$emit('myEvent') Listening to the kebab-cased version will have no effect: 12&lt;!-- Won't work --&gt;&lt;my-component v-on:my-event=\"doSomething\"&gt;&lt;/my-component&gt; Unlike components and props, event names will never be used as variable or property names in JavaScript, so there’s no reason to use camelCase or PascalCase. Additionally, v-on event listeners inside DOM templates will be automatically transformed to lowercase (due to HTML’s case-insensitivity), so v-on:myEvent would become v-on:myevent – making myEvent impossible to listen to. For these reasons, we recommend you always use kebab-case for event names. 컴포넌트의 v-model 커스터마이징 New in 2.2.0+ By default, v-model on a component uses value as the prop and input as the event, but some input types such as checkboxes and radio buttons may want to use the value attribute for a different purpose. Using the model option can avoid a conflict in such cases: 12345678910111213141516Vue.component('base-checkbox', &#123; model: &#123; prop: 'checked', event: 'change' &#125;, props: &#123; checked: Boolean &#125;, template: ` &lt;input type=\"checkbox\" v-bind:checked=\"checked\" v-on:change=\"$emit('change', $event.target.checked)\" &gt; `&#125;) Now when using v-model on this component: 1&lt;base-checkbox v-model=\"lovingVue\"&gt;&lt;/base-checkbox&gt; the value of lovingVue will be passed to the checked prop. The lovingVue property will then be updated when &lt;base-checkbox&gt; emits a change event with a new value. Note that you still have to declare the checked prop in the component's props option. ## 네이티브 이벤트를 컴포넌트에 바인딩 하기 There may be times when you want to listen directly to a native event on the root element of a component. In these cases, you can use the .native modifier for v-on: 1&lt;base-input v-on:focus.native=\"onFocus\"&gt;&lt;/base-input&gt; This can be useful sometimes, but it’s not a good idea when you’re trying to listen on a very specific element, like an &lt;input&gt;. For example, the &lt;base-input&gt; component above might refactor so that the root element is actually a &lt;label&gt; element: 12345678&lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input v-bind=\"$attrs\" v-bind:value=\"value\" v-on:input=\"$emit('input', $event.target.value)\" &gt;&lt;/label&gt; In that case, the .native listener in the parent would silently break. There would be no errors, but the onFocus handler wouldn’t be called when we expected it to. To solve this problem, Vue provides a $listeners property containing an object of listeners being used on the component. For example: 1234&#123; focus: function (event) &#123; /* ... */ &#125; input: function (value) &#123; /* ... */ &#125;,&#125; Using the $listeners property, you can forward all event listeners on the component to a specific child element with v-on=&quot;$listeners&quot;. For elements like &lt;input&gt;, that you also want to work with v-model, it’s often useful to create a new computed property for listeners, like inputListeners below: 1234567891011121314151617181920212223242526272829303132Vue.component('base-input', &#123; inheritAttrs: false, props: ['label', 'value'], computed: &#123; inputListeners: function () &#123; var vm = this // `Object.assign` merges objects together to form a new object return Object.assign(&#123;&#125;, // We add all the listeners from the parent this.$listeners, // Then we can add custom listeners or override the // behavior of some listeners. &#123; // This ensures that the component works with v-model input: function (event) &#123; vm.$emit('input', event.target.value) &#125; &#125; ) &#125; &#125;, template: ` &lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input v-bind=\"$attrs\" v-bind:value=\"value\" v-on=\"inputListeners\" &gt; &lt;/label&gt; `&#125;) Now the &lt;base-input&gt; component is a fully transparent wrapper, meaning it can be used exactly like a normal &lt;input&gt; element: all the same attributes and listeners will work, without the .native modifier. .sync 수식어 New in 2.3.0+ In some cases, we may need “two-way binding” for a prop. Unfortunately, true two-way binding can create maintenance issues, because child components can mutate the parent without the source of that mutation being obvious in both the parent and the child. That’s why instead, we recommend emitting events in the pattern of update:myPropName. For example, in a hypothetical component with a title prop, we could communicate the intent of assigning a new value with: 1this.$emit('update:title', newTitle) Then the parent can listen to that event and update a local data property, if it wants to. For example: 1234&lt;text-document v-bind:title=\"doc.title\" v-on:update:title=\"doc.title = $event\"&gt;&lt;/text-document&gt; For convenience, we offer a shorthand for this pattern with the .sync modifier: 1&lt;text-document v-bind:title.sync=\"doc.title\"&gt;&lt;/text-document&gt; Note that v-bind with the .sync modifier does not work with expressions (e.g. v-bind:title.sync=\"doc.title + '!'\" is invalid). Instead, you must only provide the name of the property you want to bind, similar to v-model. The `.sync` modifier can also be used with `v-bind` when using an object to set multiple props at once: 1&lt;text-document v-bind.sync=\"doc\"&gt;&lt;/text-document&gt; This passes each property in the doc object (e.g. title) as an individual prop, then adds v-on update listeners for each one. Using v-bind.sync with a literal object, such as in v-bind.sync=\"{ title: doc.title }\", will not work, because there are too many edge cases to consider in parsing a complex expression like this.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"상태 트랜지션","date":"2019-02-02T10:04:47.000Z","path":"wiki/vue/transitioning-state/","text":"Vue의 트랜지션 시스템은 진입, 진출 및 목록을 애니메이션으로 만드는 많은 간단한 방법을 제공하지만 데이터 자체에 대한 애니메이션은 어떻게 해야할까요? 숫자와 계산 색 표시 SVG노드의 위치 엘리먼트의 크기 및 기타 속성 이들 모두는 이미 원시 숫자로 저장되어 있거나 숫자로 변환 될 수 있습니다. 그렇게하면 Vue의 반응성 및 컴포넌트 시스템과 함께 써드파티 라이브러리를 사용하여 트윈 상태로 상태 변경 사항을 애니메이션으로 만들 수 있습니다. 감시자를 이용한 상태 애니메이션감시자를 사용하면 숫자 속성의 변경 사항을 다른 속성으로 애니메이션 할 수 있습니다. 처음에는 복잡해 보일 수도 있으므로 GreenSock을 사용하여 예제를 살펴 보겠습니다. 123456&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.3/TweenMax.min.js\"&gt;&lt;/script&gt;&lt;div id=\"animated-number-demo\"&gt; &lt;input v-model.number=\"number\" type=\"number\" step=\"20\"&gt; &lt;p&gt;&#123;&#123; animatedNumber &#125;&#125;&lt;/p&gt;&lt;/div&gt; 1234567891011121314151617new Vue(&#123; el: '#animated-number-demo', data: &#123; number: 0, tweenedNumber: 0 &#125;, computed: &#123; animatedNumber: function() &#123; return this.tweenedNumber.toFixed(0); &#125; &#125;, watch: &#123; number: function(newValue) &#123; TweenLite.to(this.$data, 0.5, &#123; tweenedNumber: newValue &#125;); &#125; &#125;&#125;) {{ animatedNumber }} new Vue({ el: '#animated-number-demo', data: { number: 0, tweenedNumber: 0 }, computed: { animatedNumber: function() { return this.tweenedNumber.toFixed(0); } }, watch: { number: function(newValue) { TweenLite.to(this.$data, 0.5, { tweenedNumber: newValue }); } } }) 숫자를 갱신하면 변경 사항이 입력 아래에 애니메이션으로 표시됩니다. 이것은 멋진 멋져 보이지만, 예를 들어 유효한 CSS 색상과 같이 숫자로 직접 저장되지 않은 것은 어떻게 할까요? 다음은 Tween.js와 Color.js를 추가하여 이를 수행하는 방법입니다. 1234567891011121314151617&lt;script src=\"https://cdn.jsdelivr.net/npm/tween.js@16.3.4\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/color-js@1.0.3\"&gt;&lt;/script&gt;&lt;div id=\"example-7\"&gt; &lt;input v-model=\"colorQuery\" v-on:keyup.enter=\"updateColor\" placeholder=\"Enter a color\" &gt; &lt;button v-on:click=\"updateColor\"&gt;Update&lt;/button&gt; &lt;p&gt;Preview:&lt;/p&gt; &lt;span v-bind:style=\"&#123; backgroundColor: tweenedCSSColor &#125;\" class=\"example-7-color-preview\" &gt;&lt;/span&gt; &lt;p&gt;&#123;&#123; tweenedCSSColor &#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var Color = net.brehaut.Colornew Vue(&#123; el: '#example-7', data: &#123; colorQuery: '', color: &#123; red: 0, green: 0, blue: 0, alpha: 1 &#125;, tweenedColor: &#123;&#125; &#125;, created: function () &#123; this.tweenedColor = Object.assign(&#123;&#125;, this.color) &#125;, watch: &#123; color: function () &#123; function animate () &#123; if (TWEEN.update()) &#123; requestAnimationFrame(animate) &#125; &#125; new TWEEN.Tween(this.tweenedColor) .to(this.color, 750) .start() animate() &#125; &#125;, computed: &#123; tweenedCSSColor: function () &#123; return new Color(&#123; red: this.tweenedColor.red, green: this.tweenedColor.green, blue: this.tweenedColor.blue, alpha: this.tweenedColor.alpha &#125;).toCSS() &#125; &#125;, methods: &#123; updateColor: function () &#123; this.color = new Color(this.colorQuery).toRGB() this.colorQuery = '' &#125; &#125;&#125;) 12345.example-7-color-preview &#123; display: inline-block; width: 50px; height: 50px;&#125; Update Preview: {{ tweenedCSSColor }} var Color = net.brehaut.Color new Vue({ el: '#example-7', data: { colorQuery: '', color: { red: 0, green: 0, blue: 0, alpha: 1 }, tweenedColor: {} }, created: function () { this.tweenedColor = Object.assign({}, this.color) }, watch: { color: function () { function animate () { if (TWEEN.update()) { requestAnimationFrame(animate) } } new TWEEN.Tween(this.tweenedColor) .to(this.color, 750) .start() animate() } }, computed: { tweenedCSSColor: function () { return new Color({ red: this.tweenedColor.red, green: this.tweenedColor.green, blue: this.tweenedColor.blue, alpha: this.tweenedColor.alpha }).toCSS() } }, methods: { updateColor: function () { this.color = new Color(this.colorQuery).toRGB() this.colorQuery = '' } } }) .example-7-color-preview { display: inline-block; width: 50px; height: 50px; } 동적 상태 트랜지션Vue의 트랜지션 컴포넌트와 마찬가지로 데이터 백업 상태 트랜지션을 실시간으로 업데이트 할 수 있으므로 프로토 타이핑에 특히 유용합니다! 간단한 SVG 다각형을 사용해도, 변수를 조금씩 사용하기 전까지는 생각하기 어려운 많은 효과를 얻을 수 있습니다. Sides: {{ sides }} Minimum Radius: {{ minRadius }}% Update Interval: {{ updateInterval }} milliseconds new Vue({ el: '#svg-polygon-demo', data: function () { var defaultSides = 10 var stats = Array.apply(null, { length: defaultSides }) .map(function () { return 100 }) return { stats: stats, points: generatePoints(stats), sides: defaultSides, minRadius: 50, interval: null, updateInterval: 500 } }, watch: { sides: function (newSides, oldSides) { var sidesDifference = newSides - oldSides if (sidesDifference > 0) { for (var i = 1; i","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"Props","date":"2019-02-02T10:04:47.000Z","path":"wiki/vue/components-props/","text":"This page assumes you’ve already read the Components Basics. Read that first if you are new to components. Prop Casing (camelCase vs kebab-case)HTML attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you’re using in-DOM templates, camelCased prop names need to use their kebab-cased (hyphen-delimited) equivalents: 12345Vue.component('blog-post', &#123; // camelCase in JavaScript props: ['postTitle'], template: '&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;'&#125;) 12&lt;!-- kebab-case in HTML --&gt;&lt;blog-post post-title=\"hello!\"&gt;&lt;/blog-post&gt; Again, if you’re using string templates, this limitation does not apply. Prop TypesSo far, we’ve only seen props listed as an array of strings: 1props: ['title', 'likes', 'isPublished', 'commentIds', 'author'] Usually though, you’ll want every prop to be a specific type of value. In these cases, you can list props as an object, where the properties’ names and values contain the prop names and types, respectively: 123456789props: &#123; title: String, likes: Number, isPublished: Boolean, commentIds: Array, author: Object, callback: Function, contactsPromise: Promise // or any other constructor&#125; This not only documents your component, but will also warn users in the browser’s JavaScript console if they pass the wrong type. You’ll learn much more about type checks and other prop validations further down this page. Passing Static or Dynamic PropsSo far, you’ve seen props passed a static value, like in: 1&lt;blog-post title=\"My journey with Vue\"&gt;&lt;/blog-post&gt; You’ve also seen props assigned dynamically with v-bind, such as in: 1234567&lt;!-- Dynamically assign the value of a variable --&gt;&lt;blog-post v-bind:title=\"post.title\"&gt;&lt;/blog-post&gt;&lt;!-- Dynamically assign the value of a complex expression --&gt;&lt;blog-post v-bind:title=\"post.title + ' by ' + post.author.name\"&gt;&lt;/blog-post&gt; In the two examples above, we happen to pass string values, but any type of value can actually be passed to a prop. Passing a Number123456&lt;!-- Even though `42` is static, we need v-bind to tell Vue that --&gt;&lt;!-- this is a JavaScript expression rather than a string. --&gt;&lt;blog-post v-bind:likes=\"42\"&gt;&lt;/blog-post&gt;&lt;!-- Dynamically assign to the value of a variable. --&gt;&lt;blog-post v-bind:likes=\"post.likes\"&gt;&lt;/blog-post&gt; Passing a Boolean123456789&lt;!-- Including the prop with no value will imply `true`. --&gt;&lt;blog-post is-published&gt;&lt;/blog-post&gt;&lt;!-- Even though `false` is static, we need v-bind to tell Vue that --&gt;&lt;!-- this is a JavaScript expression rather than a string. --&gt;&lt;blog-post v-bind:is-published=\"false\"&gt;&lt;/blog-post&gt;&lt;!-- Dynamically assign to the value of a variable. --&gt;&lt;blog-post v-bind:is-published=\"post.isPublished\"&gt;&lt;/blog-post&gt; Passing an Array123456&lt;!-- Even though the array is static, we need v-bind to tell Vue that --&gt;&lt;!-- this is a JavaScript expression rather than a string. --&gt;&lt;blog-post v-bind:comment-ids=\"[234, 266, 273]\"&gt;&lt;/blog-post&gt;&lt;!-- Dynamically assign to the value of a variable. --&gt;&lt;blog-post v-bind:comment-ids=\"post.commentIds\"&gt;&lt;/blog-post&gt; Passing an Object1234567891011&lt;!-- Even though the object is static, we need v-bind to tell Vue that --&gt;&lt;!-- this is a JavaScript expression rather than a string. --&gt;&lt;blog-post v-bind:author=\"&#123; name: 'Veronica', company: 'Veridian Dynamics' &#125;\"&gt;&lt;/blog-post&gt;&lt;!-- Dynamically assign to the value of a variable. --&gt;&lt;blog-post v-bind:author=\"post.author\"&gt;&lt;/blog-post&gt; Passing the Properties of an ObjectIf you want to pass all the properties of an object as props, you can use v-bind without an argument (v-bind instead of v-bind:prop-name). For example, given a post object: 1234post: &#123; id: 1, title: 'My Journey with Vue'&#125; The following template: 1&lt;blog-post v-bind=\"post\"&gt;&lt;/blog-post&gt; Will be equivalent to: 1234&lt;blog-post v-bind:id=\"post.id\" v-bind:title=\"post.title\"&gt;&lt;/blog-post&gt; One-Way Data FlowAll props form a one-way-down binding between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent’s state, which can make your app’s data flow harder to understand. In addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should not attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console. There are usually two cases where it’s tempting to mutate a prop: The prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards. In this case, it’s best to define a local data property that uses the prop as its initial value: 123456props: ['initialCounter'],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; The prop is passed in as a raw value that needs to be transformed. In this case, it’s best to define a computed property using the prop’s value: 123456props: ['size'],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; Note that objects and arrays in JavaScript are passed by reference, so if the prop is an array or object, mutating the object or array itself inside the child component **will** affect parent state. ## Prop Validation Components can specify requirements for their props, such as the types you’ve already seen. If a requirement isn’t met, Vue will warn you in the browser’s JavaScript console. This is especially useful when developing a component that’s intended to be used by others. To specify prop validations, you can provide an object with validation requirements to the value of props, instead of an array of strings. For example: 12345678910111213141516171819202122232425262728293031323334Vue.component('my-component', &#123; props: &#123; // Basic type check (`null` and `undefined` values will pass any type validation) propA: Number, // Multiple possible types propB: [String, Number], // Required string propC: &#123; type: String, required: true &#125;, // Number with a default value propD: &#123; type: Number, default: 100 &#125;, // Object with a default value propE: &#123; type: Object, // Object or array defaults must be returned from // a factory function default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // Custom validator function propF: &#123; validator: function (value) &#123; // The value must match one of these strings return ['success', 'warning', 'danger'].indexOf(value) !== -1 &#125; &#125; &#125;&#125;) When prop validation fails, Vue will produce a console warning (if using the development build). Note that props are validated **before** a component instance is created, so instance properties (e.g. `data`, `computed`, etc) will not be available inside `default` or `validator` functions. ### Type Checks The type can be one of the following native constructors: String Number Boolean Array Object Date Function Symbol In addition, type can also be a custom constructor function and the assertion will be made with an instanceof check. For example, given the following constructor function exists: 1234function Person (firstName, lastName) &#123; this.firstName = firstName this.lastName = lastName&#125; You could use: 12345Vue.component('blog-post', &#123; props: &#123; author: Person &#125;&#125;) to validate that the value of the author prop was created with new Person. Non-Prop AttributesA non-prop attribute is an attribute that is passed to a component, but does not have a corresponding prop defined. While explicitly defined props are preferred for passing information to a child component, authors of component libraries can’t always foresee the contexts in which their components might be used. That’s why components can accept arbitrary attributes, which are added to the component’s root element. For example, imagine we’re using a 3rd-party bootstrap-date-input component with a Bootstrap plugin that requires a data-date-picker attribute on the input. We can add this attribute to our component instance: 1&lt;bootstrap-date-input data-date-picker=\"activated\"&gt;&lt;/bootstrap-date-input&gt; And the data-date-picker=&quot;activated&quot; attribute will automatically be added to the root element of bootstrap-date-input. Replacing/Merging with Existing AttributesImagine this is the template for bootstrap-date-input: 1&lt;input type=\"date\" class=\"form-control\"&gt; To specify a theme for our date picker plugin, we might need to add a specific class, like this: 1234&lt;bootstrap-date-input data-date-picker=\"activated\" class=\"date-picker-theme-dark\"&gt;&lt;/bootstrap-date-input&gt; In this case, two different values for class are defined: form-control, which is set by the component in its template date-picker-theme-dark, which is passed to the component by its parent For most attributes, the value provided to the component will replace the value set by the component. So for example, passing type=&quot;text&quot; will replace type=&quot;date&quot; and probably break it! Fortunately, the class and style attributes are a little smarter, so both values are merged, making the final value: form-control date-picker-theme-dark. Disabling Attribute InheritanceIf you do not want the root element of a component to inherit attributes, you can set inheritAttrs: false in the component’s options. For example: 1234Vue.component('my-component', &#123; inheritAttrs: false, // ...&#125;) This can be especially useful in combination with the $attrs instance property, which contains the attribute names and values passed to a component, such as: 1234&#123; required: true, placeholder: 'Enter your username'&#125; With inheritAttrs: false and $attrs, you can manually decide which element you want to forward attributes to, which is often desirable for base components: 1234567891011121314Vue.component('base-input', &#123; inheritAttrs: false, props: ['label', 'value'], template: ` &lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input v-bind=\"$attrs\" v-bind:value=\"value\" v-on:input=\"$emit('input', $event.target.value)\" &gt; &lt;/label&gt; `&#125;) Note that `inheritAttrs: false` option does **not** affect `style` and `class` bindings. This pattern allows you to use base components more like raw HTML elements, without having to care about which element is actually at its root: 12345&lt;base-input v-model=\"username\" required placeholder=\"Enter your username\"&gt;&lt;/base-input&gt;","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"진입/진출 그리고 리스트 트랜지션","date":"2019-02-01T10:04:47.000Z","path":"wiki/vue/transitions/","text":"개요Vue는 항목이 DOM에 삽입, 갱신 또는 제거 될 때 트랜지션 효과를 적용하는 다양한 방법을 제공합니다. 여기에는 다음과 같은 도구가 포함됩니다. CSS 트랜지션 및 애니메이션을 위한 클래스를 자동으로 적용합니다. Animate.css와 같은 타사 CSS 애니메이션 라이브러리 통합 트랜지션 훅 중에 JavaScript를 사용하여 DOM을 직접 조작 Velocity.js와 같은 써드파티 JavaScript 애니메이션 라이브러리 통합 이 페이지에서는 진입, 진출 및 목록 트랜지션만 다루지만 다음 섹션에서는 트랜지션 상태 관리를 볼 수 있습니다. 단일 엘리먼트 / 컴포넌트 트랜지션Vue는 트랜지션 래퍼 컴포넌트를 제공하므로 다음과 같은 상황에서 모든 엘리먼트 또는 컴포넌트에 대한 진입 / 진출 트랜지션을 추가 할 수 있습니다. 조건부 렌더링 (v-if 사용) 조건부 출력 (v-show 사용) 동적 컴포넌트 컴포넌트 루트 노드 다음 매우 간단한 예제를 보겠습니다. 12345678&lt;div id=\"demo\"&gt; &lt;button v-on:click=\"show = !show\"&gt; Toggle &lt;/button&gt; &lt;transition name=\"fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#demo', data: &#123; show: true &#125;&#125;) 123456.fade-enter-active, .fade-leave-active &#123; transition: opacity .5s;&#125;.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ &#123; opacity: 0;&#125; Toggle hello new Vue({ el: '#demo', data: { show: true } }) .demo-transition-enter-active, .demo-transition-leave-active { transition: opacity .5s } .demo-transition-enter, .demo-transition-leave-to { opacity: 0 } transition 컴포넌트로 싸여진 엘리먼트가 삽입되거나 제거 될 때 일어납니다: Vue는 대상 엘리먼트에 CSS 트랜지션 또는 애니메이션이 적용되었는지 여부를 자동으로 감지합니다. 그렇다면 CSS 트랜지션 클래스가 적절한 타이밍에 추가 / 제거됩니다. 트랜지션 컴포넌트가 JavaScript 훅를 제공하면 이러한 훅은 적절한 타이밍에 호출됩니다. CSS 트랜지션 / 애니메이션이 감지되지 않고 JavaScript 훅이 제공 되지 않으면 삽입 또는 제거를 위한 DOM 작업이 다음 프레임에서 즉시 실행됩니다 (참고: 이는 Vue의 nextTick 개념과는 다른 브라우저 애니메이션 프레임입니다). 트랜지션 클래스진입 / 진출 트랜지션에는 네가지 클래스가 적용됩니다. v-enter: enter의 시작 상태. 엘리먼트가 삽입되기 전에 적용되고 한 프레임 후에 제거됩니다. v-enter-active: enter에 대한 활성 및 종료 상태. 엘리먼트가 삽입되기 전에 적용됩니다. 트랜지션 / 애니메이션이 완료되면 제거됩니다. v-enter-to: 2.1.8 이상 버전에서 지원합니다. 진입 상태의 끝에서 실행됩니다. 엘리먼트가 삽입된 후 (동시에 v-enter가 제거됨), 트랜지션/애니메이션이 끝나면 제거되는 하나의 프레임을 추가했습니다. v-leave: leave를 위한 시작 상태. 진출 트랜지션이 트리거 될 때 적용되고 한 프레임 후에 제거됩니다. v-leave-active: leave에 대한 활성 및 종료 상태. 진출 트랜지션이 트리거되면 적용되고 트랜지션 / 애니메이션이 완료되면 제거됩니다. v-leave-to: 2.1.8 이상 버전에서 지원합니다. 진출 상태의 끝에서 실행됩니다. 진출 트랜지션이 트리거되고 (동시에 v-leave가 제거됨), 트랜지션/애니메이션이 끝나면 제거되는 하나의 프레임을 추가했습니다. 각 클래스에는 트랜지션 이름이 접두어로 붙습니다. 여기서v-접두어는 이름없이 &lt;transition&gt; 엘리먼트를 사용할 때의 기본값입니다. 예를 들어&lt;transition name = &quot;my-transition&quot;&gt;을 사용하면v-enter 클래스는 my-transition-enter 가 됩니다. v-enter-active 와v-leave-active 는 입/출력 트랜지션을 위한 다른 easing curve를 지정할 수있는 기능을 제공합니다. 다음 섹션에서 그 예를 보실 수 있습니다. CSS 트랜지션가장 일반적인 트랜지션 유형 중 하나는 CSS 트랜지션을 사용합니다. 다음은 간단한 예입니다. 12345678&lt;div id=\"example-1\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle render &lt;/button&gt; &lt;transition name=\"slide-fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-1', data: &#123; show: true &#125;&#125;) 12345678910111213/* 애니메이션 진입 및 진출은 다른 지속 시간 및 *//* 타이밍 기능을 사용할 수 있습니다. */.slide-fade-enter-active &#123; transition: all .3s ease;&#125;.slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);&#125;.slide-fade-enter, .slide-fade-leave-to/* .slide-fade-leave-active below version 2.1.8 */ &#123; transform: translateX(10px); opacity: 0;&#125; Toggle render hello new Vue({ el: '#example-1', data: { show: true } }) .slide-fade-enter-active { transition: all .3s ease; } .slide-fade-leave-active { transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0); } .slide-fade-enter, .slide-fade-leave-to { transform: translateX(10px); opacity: 0; } CSS 애니메이션CSS 애니메이션은 CSS 트랜지션과 같은 방식으로 적용됩니다. 차이점은 요소가 삽입 된 직후에v-enter가 제거되지 않지만 animationend 이벤트에 있습니다. 다음은 간결함을 위해 접두사가 붙은 CSS 규칙을 생략 한 예입니다. 123456&lt;div id=\"example-2\"&gt; &lt;button @click=\"show = !show\"&gt;Toggle show&lt;/button&gt; &lt;transition name=\"bounce\"&gt; &lt;p v-if=\"show\"&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi tristique senectus et netus.&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-2', data: &#123; show: true &#125;&#125;) 1234567891011121314151617.bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-in .5s reverse;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125; Toggle show Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi tristique senectus et netus. .bounce-enter-active { -webkit-animation: bounce-in .5s; animation: bounce-in .5s; } .bounce-leave-active { -webkit-animation: bounce-in .5s reverse; animation: bounce-in .5s reverse; } @keyframes bounce-in { 0% { -webkit-transform: scale(0); transform: scale(0); } 50% { -webkit-transform: scale(1.5); transform: scale(1.5); } 100% { -webkit-transform: scale(1); transform: scale(1); } } @-webkit-keyframes bounce-in { 0% { -webkit-transform: scale(0); transform: scale(0); } 50% { -webkit-transform: scale(1.5); transform: scale(1.5); } 100% { -webkit-transform: scale(1); transform: scale(1); } } new Vue({ el: '#example-2', data: { show: true } }) 사용자 지정 트랜지션 클래스다음 속성을 제공하여 사용자 정의 트랜지션 클래스를 지정할 수도 있습니다. enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+) 이것들은 원본 클래스 명을 오버라이드 합니다. 이는 Vue의 트랜지션 시스템을 Animate.css와 같은 기존 CSS 애니메이션 라이브러리와 결합하려는 경우 특히 유용합니다. 예제 입니다. 1234567891011121314&lt;link href=\"https://cdn.jsdelivr.net/npm/animate.css@3.5.1\" rel=\"stylesheet\" type=\"text/css\"&gt;&lt;div id=\"example-3\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle render &lt;/button&gt; &lt;transition name=\"custom-classes-transition\" enter-active-class=\"animated tada\" leave-active-class=\"animated bounceOutRight\" &gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-3', data: &#123; show: true &#125;&#125;) Toggle render hello new Vue({ el: '#example-3', data: { show: true } }) 트랜지션과 애니메이션을 함께 사용하기Vue는 트랜지션이 종료 된 시점을 알기 위해 이벤트 리스너를 연결해야합니다. 적용된 CSS 규칙의 유형에 따라 transitionend 또는 animationend 가 될 수 있습니다. 둘 중 하나만 사용하는 경우 Vue는 올바른 유형을 자동으로 감지 할 수 있습니다. 그러나 어떤 경우에는 같은 엘리먼트 (예: Vue에 의해 트리거 된 CSS 애니메이션)와 함께 호버에 대한 CSS 트랜지션 효과를 둘 다 가질 수도 있습니다. 이러한 경우,type 속성에서 Vue가 지켜 볼 타입을 명시적으로 선언해야 합니다. 값은 animation 또는 transition 입니다. 명시적 트랜지션 지속 시간 2.2.0 버전에서 추가됨 대부분의 경우 Vue는 트랜지션이 완료를 자동으로 감지할 수 있습니다. 기본적으로 Vue는 루트 트랜지션 엘리먼트에서 첫 번째 transitionend 또는 animationend 이벤트를 기다립니다. 그러나 이것은 항상 이상적인 것은 아닙니다. 예를 들어, 중첩 된 내부 엘리먼트가 루트 트랜지션 엘리먼트보다 지연된 트랜지션 또는 더 긴 트랜지션 기간을 갖는 다른 엘리먼트와 함께 진행하는 트랜지션 시퀀스를 가질 수 있습니다. 이 경우, &lt;transition&gt; 컴포넌트에 duration 속성을 사용하여 명시적인 트랜지션 지속 시간(밀리 초)을 지정할 수 있습니다. 1&lt;transition :duration=\"1000\"&gt;...&lt;/transition&gt; 진입과 진출 기간에도 명시적인 값을 지정할 수 있습니다. 1&lt;transition :duration=\"&#123; enter: 500, leave: 800 &#125;\"&gt;...&lt;/transition&gt; JavaScript 훅속성에서 JavaScript 훅을 정의할 수 있습니다. 12345678910111213&lt;transition v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:after-enter=\"afterEnter\" v-on:enter-cancelled=\"enterCancelled\" v-on:before-leave=\"beforeLeave\" v-on:leave=\"leave\" v-on:after-leave=\"afterLeave\" v-on:leave-cancelled=\"leaveCancelled\"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041// ...methods: &#123; // -------- // 진입 // -------- beforeEnter: function (el) &#123; // ... &#125;, // done 콜백은 CSS와 함께 사용할 때 선택 사항입니다. enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 진출 // -------- beforeLeave: function (el) &#123; // ... &#125;, // done 콜백은 CSS와 함께 사용할 때 선택 사항입니다. leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled은 v-show와 함께 사용됩니다. leaveCancelled: function (el) &#123; // ... &#125;&#125; 이러한 훅은 CSS 트랜지션 / 애니메이션 또는 자체적으로 사용할 수 있습니다. JavaScript 전용 트랜지션을 하는 경우 `enter` 및 `leave` 훅에서 **`done` 콜백이 필요합니다.** 그렇지 않으면 동기적으로 호출되고 트랜지션 즉시 완료됩니다. Vue가 CSS 탐지를 건너 뛸 수 있도록 JavaScript 전용 트랜지션에 `v-bind:css=\"false\"`를 명시적으로 추가하는 것도 좋은 생각입니다. 이것은 CSS 규칙이 실수로 트랜지션을 방해하는 것을 방지합니다. 이제 예를 들어 보겠습니다. 다음은 Velocity.js를 사용한 간단한 JavaScript 트랜지션입니다. 12345678910111213141516171819&lt;!-- Velocity는 jQuery.animate와 매우 비슷하게 동작하며 --&gt;&lt;!-- JavaScript 애니메이션의 훌륭한 옵션입니다. --&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"&gt;&lt;/script&gt;&lt;div id=\"example-4\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle &lt;/button&gt; &lt;transition v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:leave=\"leave\" v-bind:css=\"false\" &gt; &lt;p v-if=\"show\"&gt; Demo &lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 12345678910111213141516171819202122232425new Vue(&#123; el: '#example-4', data: &#123; show: false &#125;, methods: &#123; beforeEnter: function (el) &#123; el.style.opacity = 0 &#125;, enter: function (el, done) &#123; Velocity(el, &#123; opacity: 1, fontSize: '1.4em' &#125;, &#123; duration: 300 &#125;) Velocity(el, &#123; fontSize: '1em' &#125;, &#123; complete: done &#125;) &#125;, leave: function (el, done) &#123; Velocity(el, &#123; translateX: '15px', rotateZ: '50deg' &#125;, &#123; duration: 600 &#125;) Velocity(el, &#123; rotateZ: '100deg' &#125;, &#123; loop: 2 &#125;) Velocity(el, &#123; rotateZ: '45deg', translateY: '30px', translateX: '30px', opacity: 0 &#125;, &#123; complete: done &#125;) &#125; &#125;&#125;) Toggle Demo new Vue({ el: '#example-4', data: { show: false }, methods: { beforeEnter: function (el) { el.style.opacity = 0 el.style.transformOrigin = 'left' }, enter: function (el, done) { Velocity(el, { opacity: 1, fontSize: '1.4em' }, { duration: 300 }) Velocity(el, { fontSize: '1em' }, { complete: done }) }, leave: function (el, done) { Velocity(el, { translateX: '15px', rotateZ: '50deg' }, { duration: 600 }) Velocity(el, { rotateZ: '100deg' }, { loop: 2 }) Velocity(el, { rotateZ: '45deg', translateY: '30px', translateX: '30px', opacity: 0 }, { complete: done }) } } }) 최초 렌더링 시 트랜지션노드의 초기 렌더에 트랜지션을 적용하고 싶다면 appear 속성을 추가 할 수 있습니다 : 123&lt;transition appear&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 기본적으로 진입 및 진출에 지정된 트랜지션을 사용합니다. 그러나 원하는 경우 사용자 정의 CSS 클래스를 지정할 수도 있습니다. 12345678&lt;transition appear appear-class=\"custom-appear-class\" appear-to-class=\"custom-appear-to-class\" (2.1.8+) appear-active-class=\"custom-appear-active-class\"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 그리고 사용자 정의 JavaScript 훅 입니다. 123456789&lt;transition appear v-on:before-appear=\"customBeforeAppearHook\" v-on:appear=\"customAppearHook\" v-on:after-appear=\"customAfterAppearHook\" v-on:appear-cancelled=\"customAppearCancelledHook\"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; In the example above, either appear attribute or v-on:appear hook will cause an appear transition. 엘리먼트 간 트랜지션컴포넌트 사이의 트랜지션에 대해서는 나중에 설명하지만 v-if /v-else를 사용하여 원본 엘리먼트 사이를 트랜지션 할 수도 있습니다. 가장 일반적인 두 엘리먼트 트랜지션 중 하나는 목록 컨테이너와 빈 목록을 설명하는 메시지 사이에 사용됩니다. 123456&lt;transition&gt; &lt;table v-if=\"items.length &gt; 0\"&gt; &lt;!-- ... --&gt; &lt;/table&gt; &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;&lt;/transition&gt; 이것은 잘 작동하지만 주의해야할 한 가지 주의 사항이 있습니다. **같은 태그 이름** 을 가진 엘리먼트 사이를 트랜지션할 때, Vue에 고유 한 `key` 속성을 부여함으로써 별개의 엘리먼트임을 말해야합니다. 그렇지 않으면 Vue의 컴파일러는 효율성을 위해 엘리먼트의 내용만 바꿉니다. 기술적으로 불필요한 경우 라하더라도 **여러 항목을 항상 `` 컴포넌트에 키핑하는 것이 좋습니다.** 예제: 12345678&lt;transition&gt; &lt;button v-if=\"isEditing\" key=\"save\"&gt; Save &lt;/button&gt; &lt;button v-else key=\"edit\"&gt; Edit &lt;/button&gt;&lt;/transition&gt; 이러한 경우,key 속성을 사용하여 같은 엘리먼트의 여러 상태 사이를 트랜지션 할 수 있습니다. v-if 와 v-else 대신에 위의 예제를 다음과 같이 재 작성할 수 있습니다: 12345&lt;transition&gt; &lt;button v-bind:key=\"isEditing\"&gt; &#123;&#123; isEditing ? 'Save' : 'Edit' &#125;&#125; &lt;/button&gt;&lt;/transition&gt; 실제로 여러 개의 v-if를 사용하거나 하나의 엘리먼트를 동적 속성에 바인딩하여 여러 엘리먼트 사이를 트랜지션 할 수 있습니다. 예: 1234567891011&lt;transition&gt; &lt;button v-if=\"docState === 'saved'\" key=\"saved\"&gt; Edit &lt;/button&gt; &lt;button v-if=\"docState === 'edited'\" key=\"edited\"&gt; Save &lt;/button&gt; &lt;button v-if=\"docState === 'editing'\" key=\"editing\"&gt; Cancel &lt;/button&gt;&lt;/transition&gt; 또한 다음과 같이 쓸 수 있습니다. 12345&lt;transition&gt; &lt;button v-bind:key=\"docState\"&gt; &#123;&#123; buttonMessage &#125;&#125; &lt;/button&gt;&lt;/transition&gt; 12345678910// ...computed: &#123; buttonMessage: function () &#123; switch (this.docState) &#123; case 'saved': return 'Edit' case 'edited': return 'Save' case 'editing': return 'Cancel' &#125; &#125;&#125; 트랜지션 모드아직 한 가지 문제가 있습니다. 아래 버튼을 클릭 해보십시오: on off new Vue({ el: '#no-mode-demo', data: { on: false } }) .no-mode-fade-enter-active, .no-mode-fade-leave-active { transition: opacity .5s } .no-mode-fade-enter, .no-mode-fade-leave-active { opacity: 0 } “on”버튼과 “off”버튼 사이를 트랜지션 할 때 두 버튼이 렌더링됩니다 - 다른 트랜지션이 진행되는 동안 하나의 트랜지션이 트랜지션됩니다. 이것은 &lt;transition&gt;의 기본 동작입니다 - 들어오고 나가는 것이 동시에 발생합니다. 트랜지션 항목이 절대적으로 서로의 위에 놓일 때처럼 때로는 위 기능이 훌륭합니다. on off new Vue({ el: '#no-mode-absolute-demo', data: { on: false } }) .no-mode-absolute-demo-wrapper { position: relative; height: 18px; } .no-mode-absolute-demo-wrapper button { position: absolute; } .no-mode-absolute-fade-enter-active, .no-mode-absolute-fade-leave-active { transition: opacity .5s; } .no-mode-absolute-fade-enter, .no-mode-absolute-fade-leave-active { opacity: 0; } 그런 다음 슬라이드 트랜지션처럼 보이도록 되었을 수도 있습니다. on off new Vue({ el: '#no-mode-translate-demo', data: { on: false } }) .no-mode-translate-demo-wrapper { position: relative; height: 18px; } .no-mode-translate-demo-wrapper button { position: absolute; } .no-mode-translate-fade-enter-active, .no-mode-translate-fade-leave-active { transition: all 1s; } .no-mode-translate-fade-enter, .no-mode-translate-fade-leave-active { opacity: 0; } .no-mode-translate-fade-enter { transform: translateX(31px); } .no-mode-translate-fade-leave-active { transform: translateX(-31px); } 동시 들어가고 떠나는 트랜지션이 항상 바람직한 것은 아니기 때문에 Vue는 몇 가지 대안을 제공합니다 트랜지션 모드 : in-out: 처음에는 새로운 엘리먼트가 트랜지션되고, 완료되면 현재 엘리먼트가 트랜지션됩니다. out-in: 현재 엘리먼트가 먼저 트랜지션되고, 완료되면 새로운 요소가 바뀝니다. 이제 out-in 으로 on/off 버튼의 트랜지션을 업데이트 해 보겠습니다. 123&lt;transition name=\"fade\" mode=\"out-in\"&gt; &lt;!-- ... the buttons ... --&gt;&lt;/transition&gt; on off new Vue({ el: '#with-mode-demo', data: { on: false } }) .with-mode-fade-enter-active, .with-mode-fade-leave-active { transition: opacity .5s } .with-mode-fade-enter, .with-mode-fade-leave-active { opacity: 0 } 단순한 속성 추가를 통해 특수 스타일을 추가하지 않고 원래의 트랜지션을 수정했습니다. in-out 모드는 자주 사용되지 않지만 때로는 약간 다른 트랜지션 효과에 유용 할 수 있습니다. 이전에 작업했던 슬라이드-페이드 트랜지션과 결합 해 보겠습니다. on off new Vue({ el: '#in-out-translate-demo', data: { on: false } }) .in-out-translate-demo-wrapper { position: relative; height: 18px; } .in-out-translate-demo-wrapper button { position: absolute; } .in-out-translate-fade-enter-active, .in-out-translate-fade-leave-active { transition: all .5s; } .in-out-translate-fade-enter, .in-out-translate-fade-leave-active { opacity: 0; } .in-out-translate-fade-enter { transform: translateX(31px); } .in-out-translate-fade-leave-active { transform: translateX(-31px); } 멋지지 않나요? 컴포넌트간 트랜지션컴포넌트 사이의 트랜지션은 더욱 간단합니다. 우리는key 속성이 필요 없습니다. 대신, 우리는 동적 컴포넌트를 래핑합니다. 123&lt;transition name=\"component-fade\" mode=\"out-in\"&gt; &lt;component v-bind:is=\"view\"&gt;&lt;/component&gt;&lt;/transition&gt; 1234567891011121314new Vue(&#123; el: '#transition-components-demo', data: &#123; view: 'v-a' &#125;, components: &#123; 'v-a': &#123; template: '&lt;div&gt;Component A&lt;/div&gt;' &#125;, 'v-b': &#123; template: '&lt;div&gt;Component B&lt;/div&gt;' &#125; &#125;&#125;) 1234567.component-fade-enter-active, .component-fade-leave-active &#123; transition: opacity .3s ease;&#125;.component-fade-enter, .component-fade-leave-to/* .component-fade-leave-active below version 2.1.8 */ &#123; opacity: 0;&#125; A B .component-fade-enter-active, .component-fade-leave-active { transition: opacity .3s ease; } .component-fade-enter, .component-fade-leave-to { opacity: 0; } new Vue({ el: '#transition-components-demo', data: { view: 'v-a' }, components: { 'v-a': { template: 'Component A' }, 'v-b': { template: 'Component B' } } }) 리스트 트랜지션지금까지 다음과 같은 트랜지션을 다루었습니다. 개별 노드들 한번에 하나만 렌더링 되는 여러 노드 그렇다면v-for를 사용하여 동시에 렌더링 하고자 하는 항목의 전체 목록이 있는 경우는 어떨까요? 이 경우 우리는&lt;transition-group&gt; 컴포넌트를 사용합니다. 예를 들어보기 전에 이 컴포넌트에 대해 알아야 할 몇 가지 중요한 사항이 있습니다. &lt;transition&gt; 과 달리, 실제 요소인 &lt;span&gt;을 렌더링합니다. tag 속성으로 렌더링 된 요소를 변경할 수 있습니다. Transition modes are not available, because we are no longer alternating between mutually exclusive elements. 엘리먼트의 내부 구현은 항상 필요합니다 고유한 key 속성을 갖습니다 CSS transition classes will be applied to inner elements and not to the group/container itself. 리스트의 진입 / 진출 트랜지션이제 이전에 사용한 것과 같은 CSS 클래스를 사용하여 들어가고 떠나는 간단한 예제를 살펴 보겠습니다. 123456789&lt;div id=\"list-demo\"&gt; &lt;button v-on:click=\"add\"&gt;Add&lt;/button&gt; &lt;button v-on:click=\"remove\"&gt;Remove&lt;/button&gt; &lt;transition-group name=\"list\" tag=\"p\"&gt; &lt;span v-for=\"item in items\" v-bind:key=\"item\" class=\"list-item\"&gt; &#123;&#123; item &#125;&#125; &lt;/span&gt; &lt;/transition-group&gt;&lt;/div&gt; 123456789101112131415161718new Vue(&#123; el: '#list-demo', data: &#123; items: [1,2,3,4,5,6,7,8,9], nextNum: 10 &#125;, methods: &#123; randomIndex: function () &#123; return Math.floor(Math.random() * this.items.length) &#125;, add: function () &#123; this.items.splice(this.randomIndex(), 0, this.nextNum++) &#125;, remove: function () &#123; this.items.splice(this.randomIndex(), 1) &#125;, &#125;&#125;) 1234567891011.list-item &#123; display: inline-block; margin-right: 10px;&#125;.list-enter-active, .list-leave-active &#123; transition: all 1s;&#125;.list-enter, .list-leave-to /* .list-leave-active below version 2.1.8 */ &#123; opacity: 0; transform: translateY(30px);&#125; Add Remove {{ item }} new Vue({ el: '#list-demo', data: { items: [1,2,3,4,5,6,7,8,9], nextNum: 10 }, methods: { randomIndex: function () { return Math.floor(Math.random() * this.items.length) }, add: function () { this.items.splice(this.randomIndex(), 0, this.nextNum++) }, remove: function () { this.items.splice(this.randomIndex(), 1) }, } }) .list-item { display: inline-block; margin-right: 10px; } .list-enter-active, .list-leave-active { transition: all 1s; } .list-enter, .list-leave-to { opacity: 0; transform: translateY(30px); } 이 예제에는 한 가지 문제점이 있습니다. 항목을 추가하거나 제거 할 때 항목이 순조롭게 트랜지션되는 대신 새 위치에 즉시 변화합니다. 나중에 해결할 것입니다. 리스트 이동 트랜지션&lt;transition-group&gt; 컴포넌트는 또 다른 속임수를 가지고 있습니다. 그것은 진입과 진출 것뿐만 아니라 위치의 변화도 생생하게 표현할 수 있습니다. 이 기능을 사용하기 위해 알아야 할 유일한 새로운 개념은 아이템이 위치를 바꿀 때 추가되는 v-move 클래스를 추가하는 것입니다. 다른 클래스와 마찬가지로 접두어는 제공된 name 속성 값과 일치하며 move-class 속성을 사용하여 클래스를 수동으로 지정할 수도 있습니다. 이 클래스는 다음과 같이 트랜지션 타이밍과 easing curve을 지정하는 데 주로 유용합니다. 12345678910&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"&gt;&lt;/script&gt;&lt;div id=\"flip-list-demo\" class=\"demo\"&gt; &lt;button v-on:click=\"shuffle\"&gt;Shuffle&lt;/button&gt; &lt;transition-group name=\"flip-list\" tag=\"ul\"&gt; &lt;li v-for=\"item in items\" v-bind:key=\"item\"&gt; &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt; 1234567891011new Vue(&#123; el: '#flip-list-demo', data: &#123; items: [1,2,3,4,5,6,7,8,9] &#125;, methods: &#123; shuffle: function () &#123; this.items = _.shuffle(this.items) &#125; &#125;&#125;) 123.flip-list-move &#123; transition: transform 1s;&#125; Shuffle {{ item }} new Vue({ el: '#flip-list-demo', data: { items: [1,2,3,4,5,6,7,8,9] }, methods: { shuffle: function () { this.items = _.shuffle(this.items) } } }) .flip-list-move { transition: transform 1s; } 이것은 마술처럼 보일지 모르겠지만 Vue는 FLIP이라는 간단한 애니메이션 기법을 사용하여 변형을 사용하여 이전 위치에서 새로운 위치로 요소를 부드럽게 트랜지션합니다. 이 기술을 이전 구현과 결합하여 가능한 모든 변경 사항을 목록에 적용 할 수 있습니다! 12345678910111213141516&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"&gt;&lt;/script&gt;&lt;div id=\"list-complete-demo\" class=\"demo\"&gt; &lt;button v-on:click=\"shuffle\"&gt;Shuffle&lt;/button&gt; &lt;button v-on:click=\"add\"&gt;Add&lt;/button&gt; &lt;button v-on:click=\"remove\"&gt;Remove&lt;/button&gt; &lt;transition-group name=\"list-complete\" tag=\"p\"&gt; &lt;span v-for=\"item in items\" v-bind:key=\"item\" class=\"list-complete-item\" &gt; &#123;&#123; item &#125;&#125; &lt;/span&gt; &lt;/transition-group&gt;&lt;/div&gt; 123456789101112131415161718192021new Vue(&#123; el: '#list-complete-demo', data: &#123; items: [1,2,3,4,5,6,7,8,9], nextNum: 10 &#125;, methods: &#123; randomIndex: function () &#123; return Math.floor(Math.random() * this.items.length) &#125;, add: function () &#123; this.items.splice(this.randomIndex(), 0, this.nextNum++) &#125;, remove: function () &#123; this.items.splice(this.randomIndex(), 1) &#125;, shuffle: function () &#123; this.items = _.shuffle(this.items) &#125; &#125;&#125;) 12345678910111213.list-complete-item &#123; transition: all 1s; display: inline-block; margin-right: 10px;&#125;.list-complete-enter, .list-complete-leave-to/* .list-complete-leave-active below version 2.1.8 */ &#123; opacity: 0; transform: translateY(30px);&#125;.list-complete-leave-active &#123; position: absolute;&#125; Shuffle Add Remove {{ item }} new Vue({ el: '#list-complete-demo', data: { items: [1,2,3,4,5,6,7,8,9], nextNum: 10 }, methods: { randomIndex: function () { return Math.floor(Math.random() * this.items.length) }, add: function () { this.items.splice(this.randomIndex(), 0, this.nextNum++) }, remove: function () { this.items.splice(this.randomIndex(), 1) }, shuffle: function () { this.items = _.shuffle(this.items) } } }) .list-complete-item { transition: all 1s; display: inline-block; margin-right: 10px; } .list-complete-enter, .list-complete-leave-to { opacity: 0; transform: translateY(30px); } .list-complete-leave-active { position: absolute; } 한 가지 중요한 사실은 이러한 FLIP 트랜지션은 `display:inline` 으로 설정된 요소로는 작동하지 않는다는 것입니다. 또는 `display:inline-block` 을 사용하거나 flex 컨텍스트에 요소를 배치 할 수 있습니다. 이러한 FLIP 애니메이션은 단일 축으로 제한되지 않습니다. 다차원 그리드의 항목을 [매우 쉽게](https://jsfiddle.net/chrisvfritz/sLrhk1bc/) 트랜지션 할 수 있습니다. Lazy Sudoku Keep hitting the shuffle button until you win. Shuffle {{ cell.number }} new Vue({ el: '#sudoku-demo', data: { cells: Array.apply(null, { length: 81 }) .map(function (_, index) { return { id: index, number: index % 9 + 1 } }) }, methods: { shuffle: function () { this.cells = _.shuffle(this.cells) } } }) .sudoku-container { display: flex; flex-wrap: wrap; width: 238px; margin-top: 10px; } .cell { display: flex; justify-content: space-around; align-items: center; width: 25px; height: 25px; border: 1px solid #aaa; margin-right: -1px; margin-bottom: -1px; } .cell:nth-child(3n) { margin-right: 0; } .cell:nth-child(27n) { margin-bottom: 0; } .cell-move { transition: transform 1s; } 비틀거리는 목록 트랜지션데이터 속성을 통해 JavaScript 트랜지션과 통신함으로써 목록에서 트랜지션을 비틀 수 있습니다. 12345678910111213141516171819&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"&gt;&lt;/script&gt;&lt;div id=\"staggered-list-demo\"&gt; &lt;input v-model=\"query\"&gt; &lt;transition-group name=\"staggered-fade\" tag=\"ul\" v-bind:css=\"false\" v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:leave=\"leave\" &gt; &lt;li v-for=\"(item, index) in computedList\" v-bind:key=\"item.msg\" v-bind:data-index=\"index\" &gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647new Vue(&#123; el: '#staggered-list-demo', data: &#123; query: '', list: [ &#123; msg: 'Bruce Lee' &#125;, &#123; msg: 'Jackie Chan' &#125;, &#123; msg: 'Chuck Norris' &#125;, &#123; msg: 'Jet Li' &#125;, &#123; msg: 'Kung Fury' &#125; ] &#125;, computed: &#123; computedList: function () &#123; var vm = this return this.list.filter(function (item) &#123; return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1 &#125;) &#125; &#125;, methods: &#123; beforeEnter: function (el) &#123; el.style.opacity = 0 el.style.height = 0 &#125;, enter: function (el, done) &#123; var delay = el.dataset.index * 150 setTimeout(function () &#123; Velocity( el, &#123; opacity: 1, height: '1.6em' &#125;, &#123; complete: done &#125; ) &#125;, delay) &#125;, leave: function (el, done) &#123; var delay = el.dataset.index * 150 setTimeout(function () &#123; Velocity( el, &#123; opacity: 0, height: 0 &#125;, &#123; complete: done &#125; ) &#125;, delay) &#125; &#125;&#125;) {{ item.msg }} new Vue({ el: '#example-5', data: { query: '', list: [ { msg: 'Bruce Lee' }, { msg: 'Jackie Chan' }, { msg: 'Chuck Norris' }, { msg: 'Jet Li' }, { msg: 'Kung Fury' } ] }, computed: { computedList: function () { var vm = this return this.list.filter(function (item) { return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1 }) } }, methods: { beforeEnter: function (el) { el.style.opacity = 0 el.style.height = 0 }, enter: function (el, done) { var delay = el.dataset.index * 150 setTimeout(function () { Velocity( el, { opacity: 1, height: '1.6em' }, { complete: done } ) }, delay) }, leave: function (el, done) { var delay = el.dataset.index * 150 setTimeout(function () { Velocity( el, { opacity: 0, height: 0 }, { complete: done } ) }, delay) } } }) 트랜지션 재사용트랜지션은 Vue의 컴포넌트 시스템을 통해 재사용 할 수 있습니다. 재사용 할 수있는 트랜지션을 만드려면 루트에 &lt;transition&gt;또는 &lt;transition-group&gt; 컴포넌트를 놓은 다음 자식을 트랜지션 컴포넌트에 전달하면됩니다. 다음은 템플릿 컴포넌트를 사용하는 예입니다. 12345678910111213141516171819Vue.component('my-special-transition', &#123; template: '\\ &lt;transition\\ name=\"very-special-transition\"\\ mode=\"out-in\"\\ v-on:before-enter=\"beforeEnter\"\\ v-on:after-enter=\"afterEnter\"\\ &gt;\\ &lt;slot&gt;&lt;/slot&gt;\\ &lt;/transition&gt;\\', methods: &#123; beforeEnter: function (el) &#123; // ... &#125;, afterEnter: function (el) &#123; // ... &#125; &#125;&#125;) 함수형 컴포넌트는 특히 이 작업에 적합합니다. 1234567891011121314151617181920Vue.component('my-special-transition', &#123; functional: true, render: function (createElement, context) &#123; var data = &#123; props: &#123; name: 'very-special-transition', mode: 'out-in' &#125;, on: &#123; beforeEnter: function (el) &#123; // ... &#125;, afterEnter: function (el) &#123; // ... &#125; &#125; &#125; return createElement('transition', data, context.children) &#125;&#125;) 동적 트랜지션예, Vue의 트랜지션도 데이터 기반입니다! 동적 변환의 가장 기본적인 예제는 name 속성을 동적 속성에 바인딩합니다. 123&lt;transition v-bind:name=\"transitionName\"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 이는 Vue의 트랜지션 클래스 규칙을 사용하여 CSS 트랜지션 / 애니메이션을 정의하고 단순히 트랜지션하려는 경우에 유용 할 수 있습니다. 실제로 모든 트랜지션 속성은 동적으로 바인딩 될 수 있습니다. 그리고 그것은 단지 속성이 아닙니다. 이벤트 훅은 단지 메소드이기 때문에 컨텍스트의 모든 데이터에 액세스 할 수 있습니다. 즉, 컴포넌트의 상태에 따라 JavaScript 트랜지션이 다르게 동작 할 수 있습니다. 12345678910111213141516171819202122&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"&gt;&lt;/script&gt;&lt;div id=\"dynamic-fade-demo\" class=\"demo\"&gt; Fade In: &lt;input type=\"range\" v-model=\"fadeInDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\"&gt; Fade Out: &lt;input type=\"range\" v-model=\"fadeOutDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\"&gt; &lt;transition v-bind:css=\"false\" v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:leave=\"leave\" &gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;button v-if=\"stop\" v-on:click=\"stop = false; show = false\" &gt;Start animating&lt;/button&gt; &lt;button v-else v-on:click=\"stop = true\" &gt;Stop it!&lt;/button&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344new Vue(&#123; el: '#dynamic-fade-demo', data: &#123; show: true, fadeInDuration: 1000, fadeOutDuration: 1000, maxFadeDuration: 1500, stop: true &#125;, mounted: function () &#123; this.show = false &#125;, methods: &#123; beforeEnter: function (el) &#123; el.style.opacity = 0 &#125;, enter: function (el, done) &#123; var vm = this Velocity(el, &#123; opacity: 1 &#125;, &#123; duration: this.fadeInDuration, complete: function () &#123; done() if (!vm.stop) vm.show = false &#125; &#125; ) &#125;, leave: function (el, done) &#123; var vm = this Velocity(el, &#123; opacity: 0 &#125;, &#123; duration: this.fadeOutDuration, complete: function () &#123; done() vm.show = true &#125; &#125; ) &#125; &#125;&#125;) Fade In: Fade Out: hello Start animating Stop it! new Vue({ el: '#dynamic-fade-demo', data: { show: true, fadeInDuration: 1000, fadeOutDuration: 1000, maxFadeDuration: 1500, stop: true }, mounted: function () { this.show = false }, methods: { beforeEnter: function (el) { el.style.opacity = 0 }, enter: function (el, done) { var vm = this Velocity(el, { opacity: 1 }, { duration: this.fadeInDuration, complete: function () { done() if (!vm.stop) vm.show = false } } ) }, leave: function (el, done) { var vm = this Velocity(el, { opacity: 0 }, { duration: this.fadeOutDuration, complete: function () { done() vm.show = true } } ) } } }) 마지막으로, 동적 트랜지션을 만드는 궁극적인 방법은 사용되는 트랜지션의 특성을 변경하기 위해 props을 받는 컴포넌트를 사용하는 것입니다. 별로인 것 처럼 들리지만, 유일한 한계는 실제로 당신의 상상력에 있습니다.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"컴포넌트 등록","date":"2019-02-01T10:04:47.000Z","path":"wiki/vue/components-registration/","text":"이 페이지는 여러분이 이미 컴포넌트 기초를 읽었다고 가정하고 쓴 내용입니다. 컴포넌트가 처음이라면 기초 문서를 먼저 읽으시기 바랍니다. Watch a free video lesson on Vue School ## 컴포넌트 이름 컴포넌트를 등록할 때는 항상 이름을 지어줘야 합니다. 예를 들어 우리가 살펴봤던 전역등록은 아래처럼 하죠. 1Vue.component('my-component-name', &#123; /* ... */ &#125;) 컴포넌트의 이름은 Vue.component의 첫번째 인자입니다. 컴포넌트에 부여한 이름은 그 컴포넌트를 어디에 쓸 지에 따라 다를 수 있습니다. 컴포넌트를 (스트링 템플릿이나 싱글파일 컴포넌트로 사용하지 않고) DOM에서 바로 사용할 때는 W3C 규칙에 따라서 사용자 정의 태그의 이름처럼 쓰는 것을 추천합니다(모두 소문자로 쓰고 단어는 하이픈(-)으로 연결하는 거죠). 이렇게 하면 지금 있거나 앞으로 작성할 HTML 엘리먼트와 충돌하는 것을 피할 수 있습니다. 기타 컴포넌트 이름을 지을 때 숙지할 내용은 스타일 가이드를 참고해주세요. 이름 표기법컴포넌트 이름을 지을 때는 두 가지 방법이 있습니다. 케밥-표기법1Vue.component('my-component-name', &#123; /* ... */ &#125;) 케밥-표기법으로 컴포넌트를 정의할 때는 사용자 정의 엘리먼트를 부를 때에도 &lt;my-component-name&gt;와 같이 반드시 케밥-표기법을 사용해야 합니다. 파스칼표기법1Vue.component('MyComponentName', &#123; /* ... */ &#125;) 파스칼표기법으로 컴포넌트를 정의할 때는 사용자 정의 엘리먼트를 부를 때 두 가지 표기법 모두 사용할 수 있습니다. 즉 &lt;my-component-name&gt;와 &lt;MyComponentName&gt; 모두 괜찮습니다. 단, DOM에 바로 쓸 때는 케밥-표기법 이름만 가능합니다. 전역 등록지금까지 우리는 Vue.component를 이용해서만 컴포넌트를 만들었습니다. 123Vue.component('my-component-name', &#123; // ... options ...&#125;) 이런 컴포넌트를 전역 등록되었다고 합니다. 즉 어떤 루트 Vue 인스턴스(new Vue)에서도 사용할 수 있는 거죠. 12345Vue.component('component-a', &#123; /* ... */ &#125;)Vue.component('component-b', &#123; /* ... */ &#125;)Vue.component('component-c', &#123; /* ... */ &#125;)new Vue(&#123; el: '#app' &#125;) 12345&lt;div id=\"app\"&gt; &lt;component-a&gt;&lt;/component-a&gt; &lt;component-b&gt;&lt;/component-b&gt; &lt;component-c&gt;&lt;/component-c&gt;&lt;/div&gt; 이렇게 등록한 컴포넌트들은 모든 하위 컴포넌트에도 사용가능합니다. 즉 위의 3개 컴포넌트들은 각각의 컴포넌트 안에서도 사용할 수 있습니다. 지역 등록전역 등록이 썩 좋기만 한 건 아닙니다. 예를 들어 웹팩같은 빌드 시스템을 사용하고 모든 컴포넌트를 전역 등록했으면 설사 어떤 컴포넌트를 더 이상 사용하지 않더라도 최종 빌드에는 들어가 있게 됩니다. 사용자가 내려받아야 하는 자바스크립트의 양이 불필요하게 커지는 거죠. 이 경우에 컴포넌트를 일반 자바스크립트 객체로 정의할 수 있습니다. 123var ComponentA = &#123; /* ... */ &#125;var ComponentB = &#123; /* ... */ &#125;var ComponentC = &#123; /* ... */ &#125; 그러면 사용할 컴포넌트들만 components 옵션을 통해 쓸 수 있습니다. 1234567new Vue(&#123; el: '#app', components: &#123; 'component-a': ComponentA, 'component-b': ComponentB &#125;&#125;) components 객체의 각 속성에서 키가 커스텀 엘리먼트의 이름이 되고 밸류가 사용할 컴포넌트 객체를 지정합니다. 지역 등록된 컴포넌트는 하위컴포넌트에서는 사용이 불가능하다는 점을 유의해야 합니다. 예를 들어 ComponentA를 ComponentB에서 쓰고 싶다면 아래와 같이 해야 합니다. 12345678var ComponentA = &#123; /* ... */ &#125;var ComponentB = &#123; components: &#123; 'component-a': ComponentA &#125;, // ...&#125; 바벨이나 웹팩을 이용해서 ES2015를 적용하고 있다면 싱글파일 컴포넌트를 이용해서 이렇게 할 수도 있습니다. 12345678import ComponentA from './ComponentA.vue'export default &#123; components: &#123; ComponentA &#125;, // ...&#125; ES2015 이상에서는 객체 내의 components 옵션에서 ComponentA: ComponentA라고 하지 않고 ComponentA라고만 해도 됩니다. 즉 키로 아래의 두 가지가 모두 가능합니다.(역자 주: component-a: ComponentA, ComponentA: ComponentA, ComponentA가 모두 가능합니다.) 템플릿에서 사용할 사용자정의 엘리먼트 이름 컴포넌트 옵션에 들어갈 변수명 모듈 시스템import/require를 이용한 모듈 시스템을 쓰지 않으면 이번 내용은 넘어가도 괜찮습니다. 만약 모듈 시스템을 쓴다면 특별한 소개와 팁을 드리도록 할게요. 모듈 시스템에서 컴포넌트를 다른 컴포넌트에 지역적으로 등록하기지금 읽고 있다면 당신은 모듈 시스템을 쓴다는 뜻이겠죠. 바벨이나 웹팩같은 것과 함께 말입니다. 이 경우에는 components 디렉토리를 만들고 각 컴포넌트들을 그 자체로 하나의 파일에 관리하는 것을 추천합니다. 그러면 어떤 컴포넌트를 다른 컴포넌트에 지역적으로 등록하기 전에 사용할 컴포넌트를 가져와야 합니다. 예를 들면 ComponentB.js나 ComponentB.vue같은 파일에서 아래처럼 다른 컴포넌트를 가져오는 거죠. 12345678910import ComponentA from './ComponentA'import ComponentC from './ComponentC'export default &#123; components: &#123; ComponentA, ComponentC &#125;, // ...&#125; 이제 ComponentA와 ComponentC 모두ComponentB`의 템플릿에서 사용할 수 있습니다. 기본 컴포넌트를 자동으로 전역 등록하기많은 컴포넌트들은 여기저기서 쓰이고 입력값이나 버튼 하나로 구성될 수도 있습니다. 이런 컴포넌트는 기본 컴포넌트라고 하고 여러 컴포넌트들에서 매우 빈번하게 사용합니다. 그래서 많은 컴포넌트에서 긴 기본 컴포넌트 목록을 보게 되죠. 1234567891011import BaseButton from './BaseButton.vue'import BaseIcon from './BaseIcon.vue'import BaseInput from './BaseInput.vue'export default &#123; components: &#123; BaseButton, BaseIcon, BaseInput &#125;&#125; 템플릿에서는 좀 더 짧은 마크업을 사용할 수 있습니다. 1234567&lt;BaseInput v-model=\"searchText\" @keydown.enter=\"search\"/&gt;&lt;BaseButton @click=\"search\"&gt; &lt;BaseIcon name=\"search\"/&gt;&lt;/BaseButton&gt; 다행히 웹팩을 쓴다면(Vue CLI 3+, which uses Webpack internally)을 쓴다면 그 안에 내장하고 있어요) require.context를 써서 자주 쓰는 기본 컴포넌트들을 전역 등록할 수 있습니다. 아래의 예시는 어플리케이션의 엔트리 파일(e.g. src/main.js)에 기본 컴포넌트들을 전역적으로 불러오는 코드입니다. 123456789101112131415161718192021222324252627282930313233343536import Vue from 'vue'import upperFirst from 'lodash/upperFirst'import camelCase from 'lodash/camelCase'const requireComponent = require.context( // 컴포넌트들이 있는 폴더 './components', // 하위 폴더까지 포함할 지 여부 false, // 기본 컴포넌트를 찾는데 사용할 정규표현식 /Base[A-Z]\\w+\\.(vue|js)$/)requireComponent.keys().forEach(fileName =&gt; &#123; // 컴포넌트 설정 가져오기 const componentConfig = requireComponent(fileName) // 컴포넌트의 파스칼표기법 이름 가져오기 const componentName = upperFirst( camelCase( // 폴더 위치와 무관하게 파일이름 추출 fileName .split('/') .pop() .replace(/\\.\\w+$/, '') ) ) // 컴포넌트를 전역적으로 등록 Vue.component( componentName, // `export default`를 이용한 컴포넌트는 `.default`로 컴포넌트 // 옵션을 추출하고 그렇지 않은 컴포넌트는 모듈의 루트를 호출 componentConfig.default || componentConfig )&#125;) ** 전역 등록은 (new Vue로) 루트 Vue 인스턴스가 만들어지기 전에 반드시 이뤄져야 한다는 것**을 기억해주시기 바랍니다. 실제 프로젝트에서 이 패턴이 어떻게 이뤄지는지 이 예시를 참고해주세요.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"컴포넌트","date":"2019-01-11T10:04:47.000Z","path":"wiki/vue/components/","text":"Watch a free video course on Vue School ## 컴포넌트가 무엇인가요? 컴포넌트는 Vue의 가장 강력한 기능 중 하나입니다. 기본 HTML 엘리먼트를 확장하여 재사용 가능한 코드를 캡슐화하는 데 도움이 됩니다. 상위 수준에서 컴포넌트는 Vue의 컴파일러에 의해 동작이 추가된 사용자 지정 엘리먼트입니다. 경우에 따라 특별한 is 속성으로 확장 된 원시 HTML 엘리먼트로 나타날 수도 있습니다. Vue 컴포넌트는 Vue 인스턴스이기도 합니다. 그러므로 모든 옵션 객체를 사용할 수 있습니다. (루트에만 사용하는 옵션은 제외) 그리고 같은 라이프사이클 훅을 사용할 수 있습니다. 컴포넌트 사용하기전역 등록이전 섹션에서 다음을 사용하여 새 Vue 인스턴스를 만들 수 있음을 알게 되었습니다. 1234new Vue(&#123; el: '#some-element', // 옵션&#125;) 전역 컴포넌트를 등록하려면, Vue.component(tagName, options)를 사용합니다. 123Vue.component('my-component', &#123; // 옵션&#125;) Vue는 사용자 지정 태그 이름에 대해 [W3C 규칙](http://www.w3.org/TR/custom-elements/#concepts)을 적용하지 않습니다 (모두 소문자이어야 하고 하이픈을 포함해야합니다). 그러나 이 규칙을 따르는 것이 좋습니다. 일단 등록되면, 컴포넌트는 인스턴스의 템플릿에서 커스텀 엘리먼트,``로 사용할 수 있습니다. 루트 Vue 인스턴스를 인스턴스화하기 **전에** 컴포넌트가 등록되어 있는지 확인하십시오. 전체 예제는 다음과 같습니다. 123&lt;div id=\"example\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; 123456789// 등록Vue.component('my-component', &#123; template: '&lt;div&gt;사용자 정의 컴포넌트 입니다!&lt;/div&gt;'&#125;)// 루트 인스턴스 생성new Vue(&#123; el: '#example'&#125;) 아래와 같이 렌더링 됩니다. 123&lt;div id=\"example\"&gt; &lt;div&gt;사용자 정의 컴포넌트 입니다!&lt;/div&gt;&lt;/div&gt; Vue.component('my-component', { template: '사용자 정의 컴포넌트 입니다!' }) new Vue({ el: '#example' }) 지역 등록모든 컴포넌트를 전역으로 등록 할 필요는 없습니다. 컴포넌트를 components 인스턴스 옵션으로 등록함으로써 다른 인스턴스/컴포넌트의 범위에서만 사용할 수있는 컴포넌트를 만들 수 있습니다: 1234567891011var Child = &#123; template: '&lt;div&gt;사용자 정의 컴포넌트 입니다!&lt;/div&gt;'&#125;new Vue(&#123; // ... components: &#123; // &lt;my-component&gt; 는 상위 템플릿에서만 사용할 수 있습니다. 'my-component': Child &#125;&#125;) 동일한 캡슐화는 디렉티브와 같은 다른 등록 가능한 Vue 기능에도 적용됩니다. DOM 템플릿 구문 분석 경고DOM을 템플릿으로 사용할 때 (예 : el 옵션을 사용하여 기존 콘텐츠가 있는 엘리먼트를 마운트하는 경우), Vue는 템플릿 콘텐츠만 가져올 수 있기 때문에 HTML이 작동하는 방식에 고유한 몇 가지 제한 사항이 적용됩니다. 이는 브라우저가 구문 분석과 정규화한 후에 작동합니다. 가장 중요한 것은&lt;ul&gt;,&lt;ol&gt;,&lt;table&gt;과&lt;select&gt;와 같은 일부 엘리먼트는 그 안에 어떤 엘리먼트가 나타날 수 있는지에 대한 제한을 가지고 있으며,&lt;option&gt;과 같이 특정 다른 엘리먼트 안에만 나타날 수 있습니다. 이러한 제한이 있는 엘리먼트가 있는 사용자 지정 컴포넌트를 사용하면 다음과 같은 문제가 발생할 수 있습니다. 123&lt;table&gt; &lt;my-row&gt;...&lt;/my-row&gt;&lt;/table&gt; 사용자 지정 컴포넌트 &lt;my-row&gt; 는 잘못 된 컨텐츠가 되어, 결과적으로 렌더링시 에러를 발생시킵니다. 해결 방법은 is 특수 속성을 사용하는 것입니다 : 123&lt;table&gt; &lt;tr is=\"my-row\"&gt;&lt;/tr&gt;&lt;/table&gt; 다음 소스 중 하나에 포함되면 문자열 템플릿을 사용하는 경우에는 이러한 제한 사항이 적용되지 않습니다.: &lt;script type=&quot;text/x-template&quot;&gt; JavaScript 인라인 템플릿 문자열 .vue 컴포넌트 따라서 가능한 경우 항상 문자열 템플릿을 사용하는 것이 좋습니다. data 는 반드시 함수여야합니다.Vue 생성자에 사용할 수 있는 대부분의 옵션은 컴포넌트에서 사용할 수 있습니다. 한가지 특별한 경우가 있습니다. data 는 함수여야 합니다. 실제로 이를 사용하는 경우에: 123456Vue.component('my-component', &#123; template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;', data: &#123; message: 'hello' &#125;&#125;) 그런 다음 Vue는 중단하고 콘솔에서 경고를 합니다. data는 컴포넌트 인스턴스의 함수여야합니다. 규칙이 존재하는 이유를 이해하는 것이 좋습니다. 따라서 다음과 같이 사용하십시오. 12345&lt;div id=\"example-2\"&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt;&lt;/div&gt; 1234567891011121314var data = &#123; counter: 0 &#125;Vue.component('simple-counter', &#123; template: '&lt;button v-on:click=\"counter += 1\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', // 데이터는 기술적으로 함수이므로 Vue는 따지지 않지만 // 각 컴포넌트 인스턴스에 대해 같은 객체 참조를 반환합니다. data: function () &#123; return data &#125;&#125;)new Vue(&#123; el: '#example-2'&#125;) var data = { counter: 0 } Vue.component('simple-counter', { template: '{{ counter }}', data: function () { return data } }) new Vue({ el: '#example-2' }) 이런! 세 개의 컴포넌트 인스턴스가 모두 같은 data 객체를 공유하므로 하나의 카운터를 증가 시키면 모두 증가합니다! 대신 새로운 데이터 객체를 반환하여 이 문제를 해결합시다. 12345data: function () &#123; return &#123; counter: 0 &#125;&#125; 이제 모든 카운터에는 각각 고유한 내부 상태가 있습니다. Vue.component('my-component', { template: '{{ counter }}', data: function () { return { counter: 0 } } }) new Vue({ el: '#example-2-5' }) 컴포넌트 작성컴포넌트는 부모-자식 관계에서 가장 일반적으로 함께 사용하기 위한 것입니다. 컴포넌트 A는 자체 템플릿에서 컴포넌트 B를 사용할 수 있습니다. 그들은 필연적으로 서로 의사 소통이 필요합니다. 부모는 자식에게 데이터를 전달해야 할 수도 있으며, 자식은 자신에게 일어난 일을 부모에게 알릴 필요가 있습니다. 그러나 부모와 자식이 명확하게 정의된 인터페이스를 통해 가능한한 분리된 상태로 유지하는 것도 매우 중요합니다. 이렇게하면 각 컴포넌트의 코드를 상대적으로 격리 할 수 있도록 작성하고 추론할 수 있으므로 유지 관리가 쉽고 잠재적으로 쉽게 재사용 할 수 있습니다. Vue.js에서 부모-자식 컴포넌트 관계는 props는 아래로, events 위로 라고 요약 할 수 있습니다. 부모는 props를 통해 자식에게 데이터를 전달하고 자식은 events를 통해 부모에게 메시지를 보냅니다. 어떻게 작동하는지 보겠습니다. PropsProps로 데이터 전달하기모든 컴포넌트 인스턴스에는 자체 격리 된 범위 가 있습니다. 즉, 하위 컴포넌트의 템플릿에서 상위 데이터를 직접 참조 할 수 없으며 그렇게 해서는 안됩니다. 데이터는 props 옵션 을 사용하여 하위 컴포넌트로 전달 될 수 있습니다. prop는 상위 컴포넌트의 정보를 전달하기위한 사용자 지정 특성입니다. 하위 컴포넌트는props 옵션을 사용하여 수신 할 것으로 기대되는 props를 명시적으로 선언해야합니다 1234567Vue.component('child', &#123; // props 정의 props: ['message'], // 데이터와 마찬가지로 prop은 템플릿 내부에서 사용할 수 있으며 // vm의 this.message로 사용할 수 있습니다. template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;) 그런 다음 일반 문자열을 다음과 같이 전달할 수 있습니다. 1&lt;child message=\"안녕하세요!\"&gt;&lt;/child&gt; 결과: new Vue({ el: '#prop-example-1', components: { child: { props: ['message'], template: '{{ message }}' } } }) camelCase vs. kebab-caseHTML 속성은 대소 문자를 구분하지 않으므로 문자열이 아닌 템플릿을 사용할 때 camelCased prop 이름에 해당하는 kebab-case(하이픈 구분)를 사용해야 합니다. 12345Vue.component('child', &#123; // JavaScript는 camelCase props: ['myMessage'], template: '&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;'&#125;) 12&lt;!-- HTML는 kebab-case --&gt;&lt;child my-message=\"안녕하세요!\"&gt;&lt;/child&gt; 문자열 템플릿을 사용하는 경우에는 이 제한이 적용되지 않습니다. 동적 Props정규 속성을 표현식에 바인딩하는 것과 비슷하게, v-bind를 사용하여 부모의 데이터에 props를 동적으로 바인딩 할 수 있습니다. 데이터가 상위에서 업데이트 될 때마다 하위 데이터로도 전달됩니다. 12345&lt;div&gt; &lt;input v-model=\"parentMsg\"&gt; &lt;br&gt; &lt;child v-bind:my-message=\"parentMsg\"&gt;&lt;/child&gt;&lt;/div&gt; v-bind에 대한 단축 구문을 사용하는 것이 더 간단합니다. 1&lt;child :my-message=\"parentMsg\"&gt;&lt;/child&gt; 결과: new Vue({ el: '#demo-2', data: { parentMsg: '부모로부터 전달 받은 메시지' }, components: { child: { props: ['myMessage'], template: '{{myMessage}}' } } }) 객체의 모든 속성을 props로 전달하려면, 인자없이 v-bind를 쓸 수 있습니다. (v-bind:prop-name 대신 v-bind). 예를 들어 todo 객체가 있다면, 1234todo: &#123; text: 'Learn Vue', isComplete: false&#125; 그런 다음, 1&lt;todo-item v-bind=\"todo\"&gt;&lt;/todo-item&gt; 이것은 다음과 같은 동작을합니다.: 1234&lt;todo-item v-bind:text=\"todo.text\" v-bind:is-complete=\"todo.isComplete\"&gt;&lt;/todo-item&gt; 리터럴 vs. 동적초보자가 흔히 범하는 실수는 리터럴 구문을 사용하여 숫자를 전달하려고 시도하는 것입니다. 12&lt;!-- 이것은 일반 문자열 \"1\"을 전달합니다. --&gt;&lt;comp some-prop=\"1\"&gt;&lt;/comp&gt; 그러나 이것은 리터럴 prop이기 때문에 그 값은 실제 숫자가 아닌 일반 문자열 &quot;1&quot; 로 전달됩니다. 실제 JavaScript 숫자를 전달하려면 값이 JavaScript 표현식으로 평가되도록 v-bind를 사용해야합니다. 12&lt;!-- 이것은 실제 숫자로 전달합니다. --&gt;&lt;comp v-bind:some-prop=\"1\"&gt;&lt;/comp&gt; 단방향 데이터 흐름모든 props는 하위 속성과 상위 속성 사이의 단방향 바인딩을 형성합니다. 상위 속성이 업데이트되면 하위로 흐르게 되지만 그 반대는 안됩니다. 이렇게하면 하위 컴포넌트가 실수로 부모의 상태를 변경하여 앱의 데이터 흐름을 추론하기 더 어렵게 만드는 것을 방지할 수 있습니다. 일반적으로 prop을 변경시키고 싶은 유혹을 불러 일으킬 수있는 두 가지 경우가 있습니다. 이 prop는 초기 값을 전달 하는데만 사용되며 하위 컴포넌트는 이후에 이를 로컬 데이터 속성으로 사용하기만 합니다. prop는 변경되어야 할 원시 값으로 전달됩니다. 이러한 사용 사례에 대한 적절한 대답은 다음과 같습니다. prop의 초기 값을 초기 값으로 사용하는 로컬 데이터 속성을 정의 하십시오. 1234props: ['initialCounter'],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; prop 값으로 부터 계산된 속성을 정의 합니다. 123456props: ['size'],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; 자바 스크립트의 객체와 배열은 참조로 전달되므로 prop가 배열이나 객체인 경우 하위 객체 또는 배열 자체를 부모 상태로 변경하면 부모 상태에 **영향을 줍니다**. ### Prop 검증 컴포넌트가 받는 중인 prop에 대한 요구사항을 지정할 수 있습니다. 요구사항이 충족 되지 않으면 Vue에서 경고를 내보냅니다. 이 기능은 다른 사용자가 사용할 컴포넌트를 제작할 때 특히 유용합니다. props를 문자열 배열로 정의하는 대신 유효성 검사 요구사항이 있는 객체를 사용할 수 있습니다. 12345678910111213141516171819202122232425262728293031Vue.component('example', &#123; props: &#123; // 기본 타입 확인 (`null` 은 어떤 타입이든 가능하다는 뜻입니다) propA: Number, // 여러개의 가능한 타입 propB: [String, Number], // 문자열이며 꼭 필요합니다 propC: &#123; type: String, required: true &#125;, // 숫자이며 기본 값을 가집니다 propD: &#123; type: Number, default: 100 &#125;, // 객체/배열의 기본값은 팩토리 함수에서 반환 되어야 합니다. propE: &#123; type: Object, default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 사용자 정의 유효성 검사 가능 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125; &#125;&#125;) type은 다음 네이티브 생성자 중 하나를 사용할 수 있습니다. String Number Boolean Function Object Array Symbol 또한, type 은 커스텀 생성자 함수가 될 수 있고, assertion은 instanceof 체크로 만들어 질 것입니다. props 검증이 실패하면 Vue는 콘솔에서 경고를 출력합니다(개발 빌드를 사용하는 경우). props는 컴포넌트 인스턴스가 생성되기 전에 검증되기 때문에 default 또는 validator 함수 내에서 data, computed 또는 methods와 같은 인스턴스 속성을 사용할 수 없습니다. Props가 아닌 속성Props가 아닌 속성은 컴포넌트로 전달되지만 해당 props는 정의되지 않은 속성입니다. 명시적으로 정의된 props는 하위 컴포넌트에 정보를 전달하는데 적절하지만 컴포넌트 라이브러리를 만드는 경우 컴포넌트가 사용될 수있는 상황을 항상 예측할 수는 없습니다. 이것이 컴포넌트가 컴포넌트의 루트 요소에 추가되는 임의의 속성을 허용해야하는 이유입니다. 예를 들어, 우리가 input에 data-3d-date-picker 속성을 요구하는 부트스트랩 플러그인으로 써드 파티 bs-date-input 컴포넌트를 사용하고 있다고 상상해보세요. 이 속성을 컴포넌트 인스턴스에 추가 할 수 있습니다. 1&lt;bs-date-input data-3d-date-picker=\"true\"&gt;&lt;/bs-date-input&gt; 그리고 data-3d-date-picker=&quot;true&quot;속성은 bs-date-input의 루트 엘리먼트에 자동으로 추가 될 것입니다. 존재하는 속성 교체/병합이 파일이 bs-date-input의 템플릿이라고 가정합니다: 1&lt;input type=\"date\" class=\"form-control\"&gt; 데이트피커 플러그인의 테마를 추가하려면 다음과 같이 특정 클래스를 추가해야 할 수도 있습니다. 1234&lt;bs-date-input data-3d-date-picker=\"true\" class=\"date-picker-theme-dark\"&gt;&lt;/bs-date-input&gt; 이 경우 class에 대한 두 개의 서로 다른 값이 정의됩니다. 템플릿의 컴포넌트에 의해 설정된 form-control date-picker-theme-dark는 부모에 의해 컴포넌트로 전달됩니다. 대부분의 속성의 경우 컴포넌트에 제공된 값은 컴포넌트에서 설정된 값을 대체합니다. 예를 들어, type=&quot;large&quot;가 전달되면 type=&quot;date&quot;를 대체할 것이고 아마도 망가뜨릴 것입니다! 다행스럽게도 class와 style 속성은 똑똑하기 때문에 두 값이 합쳐져서 최종 값인 form-control date-picker-theme-dark를 만듭니다. 우리는 부모가 prop을 사용하여 자식에게 데이터를 전달할 수 있다는 것을 알았지만, 문제가 발생했을 때 어떻게 부모에게 다시 알릴까요? 바로 Vue의 사용자 정의 이벤트 시스템이 들어오는 곳입니다. v-on을 이용한 사용자 지정 이벤트모든 Vue 인스턴스는 다음과 같은 이벤트 인터페이스를 구현합니다. $on(eventName)을 사용하여 이벤트를 감지 하십시오. $emit(eventName)을 사용하여 이벤트를 트리거 하십시오. Vue의 이벤트 시스템은 브라우저의 [EventTarget API](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget)와 별개입니다. 비슷하게 작동하지만 `$on` 과 `$emit` 는 `addEventListener` 와 `dispatchEvent`의 별칭이 __아닙니다__. 또한, 부모 컴포넌트는 자식 컴포넌트가 사용되는 템플릿에서 직접 `v-on` 을 사용하여 자식 컴포넌트에서 보내진 이벤트를 청취할 수 있습니다. `$on`은 자식에서 호출한 이벤트는 감지하지 않습니다. `v-on`을 템플릿에 반드시 지정해야 합니다. 아래의 예제를 보십시오. 예제: 12345&lt;div id=\"counter-event-example\"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526Vue.component('button-counter', &#123; template: '&lt;button v-on:click=\"incrementCounter\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; incrementCounter: function () &#123; this.counter += 1 this.$emit('increment') &#125; &#125;,&#125;)new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total += 1 &#125; &#125;&#125;) {{ total }} Vue.component('button-counter', { template: '{{ counter }}', data: function () { return { counter: 0 } }, methods: { incrementCounter: function () { this.counter += 1 this.$emit('increment') } } }) new Vue({ el: '#counter-event-example', data: { total: 0 }, methods: { incrementTotal: function () { this.total += 1 } } }) 이 예제에서는 하위 컴포넌트가 외부에서 발생 하는 것과 완전히 분리 된다는 점에 유의해야 합니다. 부모 컴포넌트가 신경 쓸 수 있는 경우를 대비하여 자체 활동에 대한 정보를 보고 하는 것뿐입니다. 컴포넌트에 네이티브 이벤트 바인딩컴포넌트의 루트 엘리먼트에서 네이티브 이벤트를 수신하려는 경우가 있을 수 있습니다. 이러한 경우 v-on 에 .native 수식자를 사용할 수 있습니다. 예 : 1&lt;my-component v-on:click.native=\"doTheThing\"&gt;&lt;/my-component&gt; .sync 수식어 2.3.0+ 일부 경우에 속성에 “양방향 바인딩”이 필요할 수 있습니다. Vue 1버전에 있던 .sync 수식어와 동일합니다. 자식 컴포넌트가 .sync를 가지는 속성을 변경하면 값의 변경이 부모에 반영됩니다. 편리하지만 단방향 데이터 흐름이 아니기 때문에 장기적으로 유지보수에 문제가 생깁니다. 자식 속성을 변경하는 코드는 부모의 상태에 영향을 미칩니다. 이 때문에 .sync는 2.0버전에서 삭제되었습니다. 그러나 재사용 가능한 컴포넌트를 만들 때 유용할 수 있다는 점을 알게 되었습니다. 부모 상태에 영향을 미치는 코드를 더욱 일관적이고 명백하게 만들어야합니다. 2.3 버전에서 속성을 위한 .sync 수식어를 다시 만들었습니다. 자동으로 v-on로 확장되는 신택스 슈가입니다. 따라서 아래 코드는 1&lt;comp :foo.sync=\"bar\"&gt;&lt;/comp&gt; 아래와 같습니다. 1&lt;comp :foo=\"bar\" @update:foo=\"val =&gt; bar = val\"&gt;&lt;/comp&gt; 하위 컴포넌트가 foo를 갱신하려면 속성을 변경하는 대신 명시적으로 이벤트를 보내야합니다. 1this.$emit('update:foo', newValue) 사용자 정의 이벤트를 사용하여 폼 입력 컴포넌트 만들기사용자 정의 이벤트는 v-model 에서 작동하는 사용자 정의 입력을 만드는데에도 사용할 수 있습니다. 기억하세요. 1&lt;input v-model=\"something\"&gt; 위 문장은 아래와 같습니다. 123&lt;input v-bind:value=\"something\" v-on:input=\"something = $event.target.value\"&gt; 컴포넌트와 함께 사용하면 다음과 같이 간단해집니다. 1234&lt;custom-input :value=\"something\" @input=\"value =&gt; &#123; something = value &#125;\"&gt;&lt;/custom-input&gt; 따라서 v-model을 사용하는 컴포넌트는 (2.2.0버전 이상에서 설정을 조작할 수 있습니다.) value prop를 가집니다. 새로운 값으로 input 이벤트를 내보냅니다. 매우 간단한 통화 입력을 사용하는 모습을 보겠습니다. 1&lt;currency-input v-model=\"price\"&gt;&lt;/currency-input&gt; 1234567891011121314151617181920212223242526272829303132333435Vue.component('currency-input', &#123; template: '\\ &lt;span&gt;\\ $\\ &lt;input\\ ref=\"input\"\\ v-bind:value=\"value\"\\ v-on:input=\"updateValue($event.target.value)\"&gt;\\ &lt;/span&gt;\\ ', props: ['value'], methods: &#123; // 값을 직접 업데이트하는 대신 이 메소드를 사용하여 // 입력 값에 대한 서식을 지정하고 배치 할 수 있습니다 updateValue: function (value) &#123; var formattedValue = value // 공백을 제거합니다. .trim() // 소수 자릿수 2자리로 줄입니다 .slice( 0, value.indexOf('.') === -1 ? value.length : value.indexOf('.') + 3 ) // 값이 아직 정규화 되지 않은 경우 // 이를 수동으로 재정의하여 조건을 충족시킵니다. if (formattedValue !== value) &#123; this.$refs.input.value = formattedValue &#125; // 입력 이벤트를 통해 숫자 값을 내보냅니다. this.$emit('input', Number(formattedValue)) &#125; &#125;&#125;) Vue.component('currency-input', { template: '\\ \\ $\\ \\ \\ ', props: ['value'], methods: { updateValue: function (value) { var formattedValue = value .trim() .slice( 0, value.indexOf('.') === -1 ? value.length : value.indexOf('.') + 3 ) if (formattedValue !== value) { this.$refs.input.value = formattedValue } this.$emit('input', Number(formattedValue)) } } }) new Vue({ el: '#currency-input-example', data: { price: '' } }) 위의 구현은 꽤 단순합니다. 예를 들어, 사용자는 때때로 여러 마침표와 글자를 입력 할 수 있습니다. 그렇기 때문에 보다 강력한 통화 필터를 사용할 수 있습니다. ### 컴포넌트의 `v-model` 사용자 정의 2.2.0 버전에서 추가됨 기본적으로 컴포넌트의 v-model은 value를 보조 변수로 사용하고 input을 이벤트로 사용하지만 체크 박스와 라디오 버튼과 같은 일부 입력 타입은 다른 목적으로 value 속성을 사용할 수 있습니다. model 옵션을 사용하면 다음 경우에 충돌을 피할 수 있습니다: 123456789101112Vue.component('my-checkbox', &#123; model: &#123; prop: 'checked', event: 'change' &#125;, props: &#123; // 다른 목적을 위해 `value` prop를 사용할 수 있습니다. checked: Boolean, value: String &#125;, // ...&#125;) 1&lt;my-checkbox v-model=\"foo\" value=\"some value\"&gt;&lt;/my-checkbox&gt; 아래와 같습니다 12345&lt;my-checkbox :checked=\"foo\" @change=\"val =&gt; &#123; foo = val &#125;\" value=\"some value\"&gt;&lt;/my-checkbox&gt; `checked` prop를 명시적으로 선언해야 합니다. ### 비 부모-자식간 통신 때로는 두 컴포넌트가 서로 통신 할 필요가 있지만 서로 부모/자식이 아닐 수도 있습니다. 간단한 시나리오에서는 비어있는 Vue 인스턴스를 중앙 이벤트 버스로 사용할 수 있습니다. 1var bus = new Vue() 12// 컴포넌트 A의 메소드bus.$emit('id-selected', 1) 1234// 컴포넌트 B의 created 훅bus.$on('id-selected', function (id) &#123; // ...&#125;) 보다 복잡한 경우에는 전용 상태 관리 패턴을 고려해야합니다 슬롯을 사용한 컨텐츠 배포컴포넌트를 사용할 때 다음과 같이 컴포넌트를 구성하는 것이 좋습니다. 1234&lt;app&gt; &lt;app-header&gt;&lt;/app-header&gt; &lt;app-footer&gt;&lt;/app-footer&gt;&lt;/app&gt; 주목해야할 두가지 사항이 있습니다. &lt;app&gt; 컴포넌트는 어떤 컨텐츠를 받을지 모릅니다. 그것은 &lt;app&gt;이 사용하는 컴포넌트에 의해 결정됩니다. &lt;app&gt; 컴포넌트에는 자체 템플릿이 있을 가능성이 큽니다. 위 구성으로 작동하도록 하려면 부모 “content”와 컴포넌트의 자체 템플릿을 섞는 방법이 필요합니다. 이것은 콘텐츠 배포 (또는 Angular에 익숙한 경우 “transclusion”) 프로세스입니다. Vue.js는 현재 웹 컴포넌트 사양 초안을 모델로 한 콘텐츠 배포 API를 구현하며 원본 콘텐츠의 배포판 역할을하기 위해 특수한 &lt;slot&gt; 엘리먼트를 사용합니다. 범위 컴파일API를 파헤치기 전에 먼저 내용이 컴파일되는 범위를 명확히 해야합니다. 다음과 같은 템플릿이 있다고 상상해보겠습니다. 123&lt;child-component&gt; &#123;&#123; message &#125;&#125;&lt;/child-component&gt; message가 부모 데이터 또는 자식 데이터중 어디에 바인딩되어야 할까요? 대답은 부모입니다. 컴포넌트 범위에 대한 간단한 법칙은 다음과 같습니다. 상위 템플릿의 모든 내용은 상위 범위로 컴파일됩니다. 하위 템플릿의 모든 내용은 하위 범위에서 컴파일됩니다. 일반적인 실수는 부모 템플릿의 하위 속성/메소드에 디렉티브를 바인딩하려고하는 것입니다. 12&lt;!-- 작동하지 않습니다 --&gt;&lt;child-component v-show=\"someChildProperty\"&gt;&lt;/child-component&gt; someChildProperty가 자식 컴포넌트의 속성이라고 가정하면, 위의 예제는 작동하지 않을 것입니다. 상위 템플릿은 하위 컴포넌트의 상태를 인식하지 못합니다. 컴포넌트 루트 노드에서 하위 범위 디렉티브를 바인딩 해야하는 경우 하위 컴포넌트의 자체 템플릿에서 하위 범위 디렉티브를 바인딩해야합니다. 123456789Vue.component('child-component', &#123; // 이제 작동합니다. 올바른 위치에 놓여 있습니다. template: '&lt;div v-show=\"someChildProperty\"&gt;Child&lt;/div&gt;', data: function () &#123; return &#123; someChildProperty: true &#125; &#125;&#125;) 마찬가지로 분산된 콘텐츠는 상위 범위에서 컴파일됩니다. 단일 슬롯하위 컴포넌트 템플릿에 최소한 하나의 &lt;slot&gt; 콘텐츠가 포함되어 있지 않으면 부모 콘텐츠가 삭제 됩니다. 속성이 없는 슬롯이 하나 뿐인 경우 전체 내용 조각이 DOM의 해당 위치에 삽입되어 슬롯 자체를 대체합니다. 원래 &lt;slot&gt; 태그 안에 있는 내용은 대체 콘텐츠 로 간주됩니다. 대체 콘텐츠는 하위 범위에서 컴파일되며 호스팅 엘리먼트가 비어 있고 삽입할 콘텐츠가 없는 경우에만 표시됩니다. 다음 템플릿으로 my-component라는 컴포넌트가 있다고 가정하십시오. 123456&lt;div&gt; &lt;h2&gt;나는 자식 컴포넌트의 제목입니다&lt;/h2&gt; &lt;slot&gt; 제공된 컨텐츠가 없는 경우에만 보실 수 있습니다. &lt;/slot&gt;&lt;/div&gt; 그리고 그 컴포넌트를 사용하는 부모는 1234567&lt;div&gt; &lt;h1&gt;나는 부모 컴포넌트의 제목입니다&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;이것은 원본 컨텐츠 입니다.&lt;/p&gt; &lt;p&gt;이것은 원본 중 추가 컨텐츠 입니다&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt; 아래처럼 렌더링 됩니다. 12345678&lt;div&gt; &lt;h1&gt;나는 부모 컴포넌트의 제목입니다&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;나는 자식 컴포넌트의 제목 입니다&lt;/h2&gt; &lt;p&gt;이것은 원본 컨텐츠 입니다.&lt;/p&gt; &lt;p&gt;이것은 원본 중 추가 컨텐츠 입니다&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 이름을 가지는 슬롯&lt;slot&gt; 엘리먼트는 특별한 속성 인 name 을 가지고 있습니다. 이 속성은 어떻게 내용을 배포해야 하는지를 더 커스터마이징하는 데 사용할 수 있습니다. 이름이 다른 슬롯이 여러 개 있을 수 있습니다. 이름을 가진 슬롯은 내용 조각에 해당 slot 속성이 있는 모든 엘리먼트와 일치합니다. 명명되지 않은 슬롯이 하나 있을 수 있습니다. 기본 슬롯 은 일치하지 않는 콘텐츠의 포괄적인 컨텐츠 역할을 합니다. 기본 슬롯이 없으면 일치하지 않는 콘텐츠가 삭제됩니다. 예를 들어, 다음과 같은 템플릿을 가진app-layout 컴포넌트가 있다고 가정 해보십시오 : 1234567891011&lt;div class=\"container\"&gt; &lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 부모 마크업 12345678&lt;app-layout&gt; &lt;h1 slot=\"header\"&gt;여기에 페이지 제목이 위치합니다&lt;/h1&gt; &lt;p&gt;메인 컨텐츠의 단락입니다.&lt;/p&gt; &lt;p&gt;하나 더 있습니다.&lt;/p&gt; &lt;p slot=\"footer\"&gt;여기에 연락처 정보입니다.&lt;/p&gt;&lt;/app-layout&gt; 아래와 같이 렌더링 됩니다. 123456789101112&lt;div class=\"container\"&gt; &lt;header&gt; &lt;h1&gt;여기에 페이지 제목이 위치합니다&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;메인 컨텐츠의 단락입니다.&lt;/p&gt; &lt;p&gt;하나 더 있습니다.&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;여기에 연락처 정보입니다.&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 콘텐츠 배포 API는 함께 구성할 컴포넌트를 디자인 할 때 매우 유용한 메커니즘입니다. 범위를 가지는 슬롯 2.1.0에 새롭게 추가됨. 범위가 지정된 슬롯은 이미 렌더링 된 엘리먼트 대신 재사용 가능한 템플릿(데이터를 전달할 수 있음)으로 작동하는 특별한 유형의 슬롯입니다. prop을 컴포넌트에게 전달하는 것처럼, 하위 컴포넌트에서 단순히 데이터를 슬롯에 전달하면 됩니다. 123&lt;div class=\"child\"&gt; &lt;slot text=\"hello from child\"&gt;&lt;/slot&gt;&lt;/div&gt; 부모에서, 특별한 속성 slot-scope를 가진 &lt;template&gt; 엘리먼트가 있어야 합니다. 이것은 범위를 가지는 슬롯을 위한 템플릿임을 나타냅니다. slot-scope의 값은 자식으로부터 전달 된 props 객체를 담고있는 임시 변수의 이름입니다: 12345678&lt;div class=\"parent\"&gt; &lt;child&gt; &lt;template slot-scope=\"props\"&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/child&gt;&lt;/div&gt; 위를 렌더링하면 출력은 다음과 같습니다. 123456&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;hello from child&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 2.5.0+에서, slot-scope 는 더이상 &lt;template&gt; 뿐 아니라 컴포넌트나 엘리먼트에서도 사용할 수 있습니다. 범위가 지정된 슬롯의 보다 일반적인 사용 사례는 컴포넌트 사용자가 리스트의 각 항목을 렌더링하는 방법을 사용자 정의할 수 있는 리스트 컴포넌트입니다. 123456789&lt;my-awesome-list :items=\"items\"&gt; &lt;!-- scoped slot 역시 이름을 가질 수 있습니다 --&gt; &lt;li slot=\"item\" slot-scope=\"props\" class=\"my-fancy-item\"&gt; &#123;&#123; props.text &#125;&#125; &lt;/li&gt;&lt;/my-awesome-list&gt; 그리고 리스트 컴포넌트의 템플릿 : 1234567&lt;ul&gt; &lt;slot name=\"item\" v-for=\"item in items\" :text=\"item.text\"&gt; &lt;!-- 대체 컨텐츠는 여기입니다. --&gt; &lt;/slot&gt;&lt;/ul&gt; 디스트럭처링slot-scope 값은 실제로 함수 서명의 인수 위치에 나타날 수 있는 유효한 JavaScript 표현식입니다. 이는 지원되는 환경 (싱글 파일 컴포넌트 또는 최신 브라우저)에서 ES2015 디스트럭처를 사용할 수 있다는 것을 의미합니다. 123&lt;child&gt; &lt;span slot-scope=\"&#123; text &#125;\"&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;&lt;/child&gt; 동적 컴포넌트같은 마운트 포인트를 사용하고 예약된 &lt;component&gt; 엘리먼트를 사용하여 여러 컴포넌트 간에 동적으로 트랜지션하고 is 속성에 동적으로 바인드 할 수 있습니다. 1234567891011var vm = new Vue(&#123; el: '#example', data: &#123; currentView: 'home' &#125;, components: &#123; home: &#123; /* ... */ &#125;, posts: &#123; /* ... */ &#125;, archive: &#123; /* ... */ &#125; &#125;&#125;) 123&lt;component v-bind:is=\"currentView\"&gt; &lt;!-- vm.currentView가 변경되면 컴포넌트가 변경됩니다! --&gt;&lt;/component&gt; 원하는 경우 컴포넌트 객체에 직접 바인딩 할 수도 있습니다. 12345678910var Home = &#123; template: '&lt;p&gt;Welcome home!&lt;/p&gt;'&#125;var vm = new Vue(&#123; el: '#example', data: &#123; currentView: Home &#125;&#125;) keep-alive트랜지션된 컴포넌트를 메모리에 유지하여 상태를 보존하거나 다시 렌더링하지 않도록하려면 동적 컴포넌트를 &lt;keep-alive&gt; 엘리먼트에 래핑 할 수 있습니다. 12345&lt;keep-alive&gt; &lt;component :is=\"currentView\"&gt; &lt;!-- 비활성화 된 컴포넌트는 캐시 됩니다! --&gt; &lt;/component&gt;&lt;/keep-alive&gt; API 참조에서 &lt;keep-alive&gt; 에 대한 자세한 내용을 확인하십시오. 기타재사용 가능한 컴포넌트 제작하기컴포넌트를 작성할 때 나중에 다른 곳에서 다시 사용할 것인지에 대한 여부를 명심하는 것이 좋습니다. 일회용 컴포넌트가 단단히 결합 되어도 상관 없지만 재사용 가능한 컴포넌트는 깨끗한 공용 인터페이스를 정의 해야하며 사용된 컨텍스트에 대한 가정을 하지 않아야합니다. Vue 컴포넌트의 API는 prop, 이벤트 및 슬롯의 세 부분으로 나뉩니다. Props 는 외부 환경이 데이터를 컴포넌트로 전달하도록 허용합니다. 이벤트를 통해 컴포넌트가 외부 환경에서 사이드이펙트를 발생할 수 있도록 합니다. 슬롯 을 사용하면 외부 환경에서 추가 컨텐츠가 포함 된 컴포넌트를 작성할 수 있습니다. v-bind 와 v-on 을 위한 전용 약어문을 사용하여 의도를 명확하고 간결하게 템플릿에 전달할 수 있습니다. 123456789&lt;my-component :foo=\"baz\" :bar=\"qux\" @event-a=\"doThis\" @event-b=\"doThat\"&gt; &lt;img slot=\"icon\" src=\"...\"&gt; &lt;p slot=\"main-text\"&gt;Hello!&lt;/p&gt;&lt;/my-component&gt; 자식 컴포넌트 참조props나 이벤트가 있었음에도 불구하고 때때로 JavaScript로 하위 컴포넌트에 직접 액세스 해야 할 수도 있습니다. 이를 위해 ref 를 이용하여 참조 컴포넌트 ID를 자식 컴포넌트에 할당해야 합니다. 예: 123&lt;div id=\"parent\"&gt; &lt;user-profile ref=\"profile\"&gt;&lt;/user-profile&gt;&lt;/div&gt; 123var parent = new Vue(&#123; el: '#parent' &#125;)// 자식 컴포넌트 인스턴스에 접근합니다.var child = parent.$refs.profile ref가 v-for와 함께 사용될 때, 얻을 수 있는 ref는 데이터 소스를 미러링하는 자식 컴포넌트를 포함하는 배열이 될 것입니다. `$refs` 는 컴포넌트가 렌더링 된 후에만 채워지며 반응적이지 않습니다. 그것은 직접 자식 조작을 위한 escape 해치를 의미합니다 - 템플릿이나 계산 된 속성에서 `$refs`를 사용하지 말아야합니다. ### 비동기 컴포넌트 대규모 응용 프로그램에서는 응용 프로그램을 더 작은 덩어리로 나누고 실제로 필요할 때만 서버에서 컴포넌트를 로드해야 할 수도 있습니다. Vue를 사용하면 컴포넌트 정의를 비동기식으로 해결하는 팩토리 함수로 컴포넌트를 정의 할 수 있습니다. Vue는 컴포넌트가 실제로 렌더링되어야 할 때만 팩토리 기능을 트리거하고 이후의 리렌더링을 위해 결과를 캐시합니다. 예 : 12345678Vue.component('async-example', function (resolve, reject) &#123; setTimeout(function () &#123; // 컴포넌트 정의를 resolve 콜백에 전달합니다. resolve(&#123; template: '&lt;div&gt;I am async!&lt;/div&gt;' &#125;) &#125;, 1000)&#125;) 팩토리 함수는 resolve 콜백을 받습니다. 이 콜백은 서버에서 컴포넌트 정의를 가져 왔을 때 호출 되어야 합니다. 또한 reject (reason) 을 호출하여 로드가 실패 했음을 알릴 수 있습니다. 여기서 setTimeout 은 데모 용입니다. 컴포넌트를 검색하는 방법은 전적으로 귀하에게 달려 있습니다. 권장되는 접근법 중 하나는 Webpack의 코드 분할 기능과 함께 비동기 컴포넌트를 사용하는 것입니다. 12345Vue.component('async-webpack-example', function (resolve) &#123; // 이 특별한 require 구문은 Webpack이 Ajax 요청을 통해 // 로드되는 번들로 작성된 코드를 자동으로 분리하도록 지시합니다. require(['./my-async-component'], resolve)&#125;) factory 함수에서 Promise를 반환할 수도 있습니다. 그래서 Webpack 2 + ES2015 구문을 사용하면 다음을 할 수 있습니다 : 12345Vue.component( 'async-webpack-example', // `import` 함수는 `Promise`를 반환합니다. () =&gt; import('./my-async-component')) 지역 등록을 사용하는 경우, Promise를 반환하는 함수를 제공할 수 있습니다. 123456new Vue(&#123; // ... components: &#123; 'my-component': () =&gt; import('./my-async-component') &#125;&#125;) 비동기 컴포넌트를 사용하려는 Browserify 사용자인 경우, 작성자는 불행히도 비동기로드가 Browserify에서 지원하지 않는 것이라고 [분명하게 주장합니다.](https://github.com/substack/node-browserify/issues/58#issuecomment-21978224) 적어도 공식적으로. Browserify 커뮤니티는 기존 및 복잡한 응용 프로그램에 도움이 될 수있는 [몇 가지 해결 방법](https://github.com/vuejs/vuejs.org/issues/620)을 발견했습니다. 다른 모든 시나리오의 경우 기본 제공되는 비동기식 지원을 위해 Webpack을 사용하는 것이 좋습니다. ### 고급 비동기 컴포넌트 2.3.0버전에서 추가 2.3 버전부터 비동기 컴포넌트 팩토리는 다음 형태의 객체를 반환할 수 있습니다. 12345678910111213const AsyncComp = () =&gt; (&#123; // 로드하는 컴포넌트입니다. 반드시 Promise이어야합니다. component: import('./MyComp.vue'), // 비동기 컴포넌트가 로드되는 동안 사용할 컴포넌트 loading: LoadingComp, // 실패했을 경우 사용하는 컴포넌트 error: ErrorComp, // 로딩 컴포넌트를 보여주기전 지연하는 정도. 기본값: 200ms. delay: 200, // 시간이 초과되면 에러용 컴포넌트가 표시됩니다 // 기본값: Infinity. timeout: 3000&#125;) vue-router에서 라우트 컴포넌트로 사용하는 경우 라우트 네비게이션이 발생하기전에 비동기 컴포넌트가 먼저 작동하기때문에 이러한 특성은 무시됩니다. 라우트 컴포넌트에서 위의 문법을 사용하려면 vue-router 2.4.0 이상을 사용해야합니다. 컴포넌트 이름 규약컴포넌트 (또는 prop)를 등록 할 때 kebab-case, camelCase 또는 PascalCase를 사용할 수 있습니다. 123456789// 컴포넌트 정의에서components: &#123; // kebab-case를 사용한 등록 'kebab-cased-component': &#123; /* ... */ &#125;, // camelCase를 사용한 등록 'camelCasedComponent': &#123; /* ... */ &#125;, // PascalCase를 사용한 등록 'PascalCasedComponent': &#123; /* ... */ &#125;&#125; HTML 템플릿 내에서 kebab-case와 동등한 것을 사용해야합니다. 1234&lt;!-- HTML 템플릿에서 항상 kebab-case를 사용하세요 --&gt;&lt;kebab-cased-component&gt;&lt;/kebab-cased-component&gt;&lt;camel-cased-component&gt;&lt;/camel-cased-component&gt;&lt;pascal-cased-component&gt;&lt;/pascal-cased-component&gt; 그러나 문자열 템플릿을 사용할 때 HTML의 대소문자를 구분하지 않습니다. 즉, 템플릿에서도 CamelCase, PascalCase 또는 kebab-case를 사용하여 컴포넌트와 prop을 참조할 수 있습니다. kebab-case camelCase를 사용하여 컴포넌트가 정의된 경우 camelCase 또는 kebab-case PascalCase를 사용하여 컴포넌트가 정의된 경우 kebab-case, camelCase or PascalCase 12345components: &#123; 'kebab-cased-component': &#123; /* ... */ &#125;, camelCasedComponent: &#123; /* ... */ &#125;, PascalCasedComponent: &#123; /* ... */ &#125;&#125; 12345678&lt;kebab-cased-component&gt;&lt;/kebab-cased-component&gt;&lt;camel-cased-component&gt;&lt;/camel-cased-component&gt;&lt;camelCasedComponent&gt;&lt;/camelCasedComponent&gt;&lt;pascal-cased-component&gt;&lt;/pascal-cased-component&gt;&lt;pascalCasedComponent&gt;&lt;/pascalCasedComponent&gt;&lt;PascalCasedComponent&gt;&lt;/PascalCasedComponent&gt; 이것은 PascalCase가 가장 보편적 인 _선언적 컨벤션_임을 의미하며 케밥 케이스는 가장 보편적으로 사용하는 _컨벤션_입니다. 컴포넌트가 slot 엘리먼트를 통해 내용을 전달받지 못하면 이름 뒤에 /를 사용하여 자체적으로 닫을 수도 있습니다. 1&lt;my-component/&gt; 다시 말하지만, 이것은 자기 닫는 사용자 정의 엘리먼트가 유효한 HTML이 아니므로 문자열 템플릿내에서만 작동하며 브라우저의 기본 파서는 이를 이해하지 못합니다. 재귀 컴포넌트컴포넌트는 자신의 템플릿에서 재귀적으로 호출할 수 있습니다. 그러나, 그들은 name 옵션으로만 가능합니다. 1name: 'unique-name-of-my-component' Vue.component를 사용하여 컴포넌트를 전역적으로 등록하면, 글로벌 ID가 컴포넌트의 name 옵션으로 자동 설정됩니다. 123Vue.component('unique-name-of-my-component', &#123; // ...&#125;) 주의하지 않으면 재귀적 컴포넌트로 인해 무한 루프가 발생할 수도 있습니다. 12name: 'stack-overflow',template: '&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;' 위와 같은 컴포넌트는 “최대 스택 크기 초과” 오류가 발생하므로 재귀 호출이 조건부 (즉, 마지막에 false가 될 v-if를 사용하세요)인지 확인하십시오. 컴포넌트 사이의 순환 참조Finder나 파일 탐색기와 같이 파일 디렉토리 트리를 작성한다고 가정해 보겠습니다. 이 템플릿을 가지고 tree-folder 컴포넌트를 가질 수 있습니다. 1234&lt;p&gt; &lt;span&gt;&#123;&#123; folder.name &#125;&#125;&lt;/span&gt; &lt;tree-folder-contents :children=\"folder.children\"/&gt;&lt;/p&gt; 그런 다음이 템플릿이 있는 tree-folder-contents 컴포넌트 : 123456&lt;ul&gt; &lt;li v-for=\"child in children\"&gt; &lt;tree-folder v-if=\"child.children\" :folder=\"child\"/&gt; &lt;span v-else&gt;&#123;&#123; child.name &#125;&#125;&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt; 자세히 살펴보면이 컴포넌트가 실제로 렌더링 트리에서 서로의 자식 및 조상인 패러독스라는 것을 알 수 있습니다! Vue.component를 이용해 전역으로 컴포넌트 등록할 때, 이 패러독스는 자동으로 해결됩니다. 그런 경우에 처해있으면 한번 읽어보세요. 그러나 모듈 시스템 을 사용하여 컴포넌트를 필요로하거나 가져오는 경우. Webpack 또는 Browserify를 통해 오류가 발생합니다. 1컴포넌트를 마운트하지 못했습니다 : 템플릿 또는 렌더링 함수가 정의되지 않았습니다. 설명을 위해 두 개의 컴포넌트 A와 B가 있다고 합시다. 모듈시스템은 우선 A가 필요하다고 합니다. 하지만 첫번째 A는 B를 필요로 하고, B는 A를 필요로 합니다. 첫번째 A의 의존성을 해결하지 않고서는 무한 루프에 빠져버립니다. 이를 해결하려면 모듈 시스템에 “A는 B를 필요로 하나 B를 먼저 해결할 필요가 없습니다.” 라고 말할 수있는 지점을 제공해야합니다. 여기에서는 tree-folder 컴포넌트를 그 지점으로 삼겠습니다. 패러독스를 만드는 자식은 tree-folder-contents 컴포넌트이므로, beforeCreate 라이프 사이클 훅 시점까지 기다렸다가 해당 컴포넌트를 등록합니다. 123beforeCreate: function () &#123; this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue')&#125; 또 다른 방법으론, 컴포넌트를 지역등록 하는 경우에 Webpack의 비동기 import를 이용할 수 있습니다. 123components: &#123; TreeFolderContents: () =&gt; import('./tree-folder-contents.vue')&#125; 문제가 해결되었습니다! 인라인 템플릿하위 컴포넌트에 inline-template 이라는 특수한 속성이 존재할 때, 컴포넌트는 그 내용을 분산 된 내용으로 취급하지 않고 템플릿으로 사용합니다. 따라서 보다 유연한 템플릿 작성이 가능합니다. 123456&lt;my-component inline-template&gt; &lt;div&gt; &lt;p&gt;이것은 컴포넌트의 자체 템플릿으로 컴파일됩니다.&lt;/p&gt; &lt;p&gt;부모가 만들어낸 내용이 아닙니다.&lt;/p&gt; &lt;/div&gt;&lt;/my-component&gt; 그러나, inline-template 은 템플릿의 범위를 추론하기 더 어렵게 만듭니다. 가장 좋은 방법은 template 옵션을 사용하거나.vue 파일의template 엘리먼트를 사용하여 컴포넌트 내부에 템플릿을 정의하는 것입니다. X-Templates템플리트를 정의하는 또 다른 방법은 text/x-template 유형의 스크립트 엘리먼트 내부에 ID로 템플릿을 참조하는 것입니다. 예: 123&lt;script type=\"text/x-template\" id=\"hello-world-template\"&gt; &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/script&gt; 123Vue.component('hello-world', &#123; template: '#hello-world-template'&#125;) 이 기능은 큰 템플릿이나 매우 작은 응용 프로그램의 데모에는 유용 할 수 있지만 템플릿을 나머지 컴포넌트 정의와 분리하기 때문에 피해야합니다. v-once를 이용한 비용이 적게드는 정적 컴포넌트일반 HTML 엘리먼트를 렌더링하는 것은 Vue에서 매우 빠르지만 가끔 정적 콘텐츠가 많이 포함 된 컴포넌트가 있을 수 있습니다. 이런 경우,v-once 디렉티브를 루트 엘리먼트에 추가함으로써 캐시가 한번만 실행되도록 할 수 있습니다. 12345678Vue.component('terms-of-service', &#123; template: '\\ &lt;div v-once&gt;\\ &lt;h1&gt;Terms of Service&lt;/h1&gt;\\ ... a lot of static content ...\\ &lt;/div&gt;\\ '&#125;)","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"폼 입력 바인딩","date":"2019-01-10T10:04:47.000Z","path":"wiki/vue/forms/","text":"기본 사용법v-model 디렉티브를 사용하여 폼 input과 textarea 엘리먼트에 양방향 데이터 바인딩을 생성할 수 있습니다. 입력 유형에 따라 엘리먼트를 업데이트 하는 올바른 방법을 자동으로 선택합니다. 약간 이상하지만 v-model은 기본적으로 사용자 입력 이벤트에 대한 데이터를 업데이트하는 “syntax sugar”이며 일부 경우에 특별한 주의를 해야합니다. `v-model`은 모든 form 엘리먼트의 초기 `value`와 `checked` 그리고 `selected` 속성을 무시합니다. 항상 Vue 인스턴스 데이터를 원본 소스로 취급합니다. 컴포넌트의 `data` 옵션 안에 있는 JavaScript에서 초기값을 선언해야합니다. v-model은 내부적으로 서로 다른 속성을 사용하고 서로 다른 입력 요소에 대해 서로 다른 이벤트를 전송합니다 : text 와 textarea 태그는 value속성과 input이벤트를 사용합니다. 체크박스들과 라디오버튼들은 checked 속성과 change 이벤트를 사용합니다. Select 태그는 value를 prop으로, change를 이벤트로 사용합니다. [IME](https://en.wikipedia.org/wiki/Input_method) (중국어, 일본어, 한국어 등)가 필요한 언어의 경우 IME 중 `v-model`이 업데이트 되지 않습니다. 이러한 업데이트를 처리하려면 `input` 이벤트를 대신 사용하십시오. ### 문자열 12&lt;input v-model=\"message\" placeholder=\"여기를 수정해보세요\"&gt;&lt;p&gt;메시지: &#123;&#123; message &#125;&#125;&lt;/p&gt; 메시지: {{ message }} new Vue({ el: '#example-1', data: { message: '' } }) 여러줄을 가진 문장1234&lt;span&gt;여러 줄을 가지는 메시지:&lt;/span&gt;&lt;p style=\"white-space: pre-line\"&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;br&gt;&lt;textarea v-model=\"message\" placeholder=\"여러줄을 입력해보세요\"&gt;&lt;/textarea&gt; 여러 줄을 가지는 메시지: {{ message }} new Vue({ el: '#example-textarea', data: { message: '' } }) 텍스트 영역의 보간 (&lt;textarea&gt;{{ text }}&lt;/textarea&gt;)은 작동하지 않습니다. 대신 v-model를 사용하십시오. 체크박스하나의 체크박스는 단일 boolean 값을 가집니다. 12&lt;input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\"&gt;&lt;label for=\"checkbox\"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt; {{ checked }} new Vue({ el: '#example-2', data: { checked: false } }) 여러개의 체크박스는 같은 배열을 바인딩 할 수 있습니다 12345678910&lt;div id='example-3'&gt; &lt;input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\"&gt; &lt;label for=\"jack\"&gt;Jack&lt;/label&gt; &lt;input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\"&gt; &lt;label for=\"john\"&gt;John&lt;/label&gt; &lt;input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\"&gt; &lt;label for=\"mike\"&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;체크한 이름: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-3', data: &#123; checkedNames: [] &#125;&#125;) Jack John Mike 체크한 이름: {{ checkedNames }} new Vue({ el: '#example-3', data: { checkedNames: [] } }) 라디오1234567&lt;input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\"&gt;&lt;label for=\"one\"&gt;One&lt;/label&gt;&lt;br&gt;&lt;input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\"&gt;&lt;label for=\"two\"&gt;Two&lt;/label&gt;&lt;br&gt;&lt;span&gt;선택: &#123;&#123; picked &#125;&#125;&lt;/span&gt; One Two Picked: {{ picked }} new Vue({ el: '#example-4', data: { picked: '' } }) 셀렉트하나의 셀렉트 1234567&lt;select v-model=\"selected\"&gt; &lt;option disabled value=\"\"&gt;Please select one&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt;&lt;/select&gt;&lt;span&gt;선택함: &#123;&#123; selected &#125;&#125;&lt;/span&gt; 123456new Vue(&#123; el: '...', data: &#123; selected: '' &#125;&#125;) Please select one A B C Selected: {{ selected }} new Vue({ el: '#example-5', data: { selected: '' } }) `v-model` 표현식의 초기 값이 어떤 옵션에도 없으면, `` 엘리먼트는 \"선택없음\" 상태로 렌더링됩니다. iOS에서는 이 경우 변경 이벤트가 발생하지 않아 사용자가 첫 번째 항목을 선택할 수 없게됩니다. 따라서 위 예제처럼 사용하지 않는 옵션에 빈 값을 넣는 것이 좋습니다. 다중 셀렉트 (배열을 바인딩 합니다): 1234567&lt;select v-model=\"selected\" multiple&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt;&lt;/select&gt;&lt;br&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt; A B C Selected: {{ selected }} new Vue({ el: '#example-6', data: { selected: [] } }) v-for를 이용한 동적 옵션 렌더링 123456&lt;select v-model=\"selected\"&gt; &lt;option v-for=\"option in options\" v-bind:value=\"option.value\"&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt; 1234567891011new Vue(&#123; el: '...', data: &#123; selected: 'A', options: [ &#123; text: 'One', value: 'A' &#125;, &#123; text: 'Two', value: 'B' &#125;, &#123; text: 'Three', value: 'C' &#125; ] &#125;&#125;) {{ option.text }} Selected: {{ selected }} new Vue({ el: '#example-7', data: { selected: 'A', options: [ { text: 'One', value: 'A' }, { text: 'Two', value: 'B' }, { text: 'Three', value: 'C' } ] } }) 값 바인딩하기라디오, 체크박스 및 셀렉트 옵션의 경우, v-model 바인딩 값은 보통 정적인 문자열(또는 체크 박스의 boolean) 입니다. 12345678910&lt;!-- `picked` 는 선택시 문자열 \"a\" 입니다 --&gt;&lt;input type=\"radio\" v-model=\"picked\" value=\"a\"&gt;&lt;!-- `toggle` 는 true 또는 false 입니다 --&gt;&lt;input type=\"checkbox\" v-model=\"toggle\"&gt;&lt;!-- `selected`는 \"ABC\" 선택시 \"abc\" 입니다 --&gt;&lt;select v-model=\"selected\"&gt; &lt;option value=\"abc\"&gt;ABC&lt;/option&gt;&lt;/select&gt; 그러나 때로 값을 Vue 인스턴스에 동적 속성에 바인딩 해야할 수 있습니다. v-bind를 사용할 수 있습니다. v-bind를 사용하면 입력 값을 문자열이 아닌 값에 바인딩 할 수도 있습니다. 체크박스123456&lt;input type=\"checkbox\" v-model=\"toggle\" true-value=\"yes\" false-value=\"no\"&gt; 1234// 체크된 경우vm.toggle === 'yes'// 체크 되지 않은 경우vm.toggle === 'no' `true-value` 와 `false-value` 속성은 폼 전송시 체크되지 않은 박스를 포함하지 않기 때문에 입력의 `value` 속성에 영향을 미치지 않습니다. 두 값 중 하나가 폼을 통해 전송 되려면 (예 : '예' 또는 '아니요') 라디오를 대신 사용하십시오. ### 라디오 1&lt;input type=\"radio\" v-model=\"pick\" v-bind:value=\"a\"&gt; 12// 체크 하면:vm.pick === vm.a 셀렉트 옵션1234&lt;select v-model=\"selected\"&gt; &lt;!-- inline object literal --&gt; &lt;option v-bind:value=\"&#123; number: 123 &#125;\"&gt;123&lt;/option&gt;&lt;/select&gt; 123// 선택 하면:typeof vm.selected // -&gt; 'object'vm.selected.number // -&gt; 123 수식어.lazy기본적으로, v-model은 각 입력 이벤트 후 입력과 데이터를 동기화 합니다. (단 앞에서 설명한 IME 구성은 제외됩니다.) .lazy 수식어를 추가하여 change 이벤트 이후에 동기화 할 수 있습니다. 12&lt;!-- \"input\" 대신 \"change\" 이후에 동기화 됩니다. --&gt;&lt;input v-model.lazy=\"msg\" &gt; .number사용자 입력이 자동으로 숫자로 형변환 되기를 원하면, v-model이 관리하는 input에 number 수식어를 추가하면 됩니다. 1&lt;input v-model.number=\"age\" type=\"number\"&gt; type=&quot;number&quot;를 사용하는 경우에도 HTML 입력 엘리먼트의 값은 항상 문자열을 반환하기 때문에 이것은 종종 유용하게 사용할 수 있습니다. If the value cannot be parsed with parseFloat(), then the original value is returned. .trimv-model이 관리하는 input을 자동으로 trim 하기 원하면, trim 수정자를 추가하면 됩니다. 1&lt;input v-model.trim=\"msg\"&gt; v-model 과 컴포넌트 Vue의 컴포넌트에 익숙하지 않으면 지금은 보지 않아도 괜찮습니다. HTML의 기본 제공 input 유형이 항상 사용자의 요구를 만족시킬 수는 없습니다. 다행히 Vue 컴포넌트를 사용하면 완전히 사용자 정의 된 동작으로 재사용 가능한 input을 만들 수 있습니다. 이 input은 v-model에도 작동합니다! 자세한 컴포넌트 가이드의 사용자 정의 입력을 참조하십시오.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"이벤트 핸들링","date":"2019-01-09T10:04:47.000Z","path":"wiki/vue/events/","text":"이벤트 청취v-on 디렉티브를 사용하여 DOM 이벤트를 듣고 트리거 될 때 JavaScript를 실행할 수 있습니다. 예제: 1234&lt;div id=\"example-1\"&gt; &lt;button v-on:click=\"counter += 1\"&gt;Add 1&lt;/button&gt; &lt;p&gt;위 버튼을 클릭한 횟수는 &#123;&#123; counter &#125;&#125; 번 입니다.&lt;/p&gt;&lt;/div&gt; 123456var example1 = new Vue(&#123; el: '#example-1', data: &#123; counter: 0 &#125;&#125;) 결과: Add 1 위 버튼을 클릭한 횟수는 {{ counter }} 번 입니다. var example1 = new Vue({ el: '#example-1', data: { counter: 0 } }) 메소드 이벤트 핸들러많은 이벤트 핸들러의 로직은 더 복잡할 것이므로, JavaScript를 v-on 속성 값으로 보관하는 것은 간단하지 않습니다. 이 때문에 v-on이 호출하고자 하는 메소드의 이름을 받는 이유입니다. 예제: 1234&lt;div id=\"example-2\"&gt; &lt;!-- `greet`는 메소드 이름으로 아래에 정의되어 있습니다 --&gt; &lt;button v-on:click=\"greet\"&gt;Greet&lt;/button&gt;&lt;/div&gt; 1234567891011121314151617181920var example2 = new Vue(&#123; el: '#example-2', data: &#123; name: 'Vue.js' &#125;, // 메소드는 `methods` 객체 안에 정의합니다 methods: &#123; greet: function (event) &#123; // 메소드 안에서 사용하는 `this` 는 Vue 인스턴스를 가리킵니다 alert('Hello ' + this.name + '!') // `event` 는 네이티브 DOM 이벤트입니다 if (event) &#123; alert(event.target.tagName) &#125; &#125; &#125;&#125;)// 또한 JavaScript를 이용해서 메소드를 호출할 수 있습니다.example2.greet() // =&gt; 'Hello Vue.js!' 결과: Greet var example2 = new Vue({ el: '#example-2', data: { name: 'Vue.js' }, methods: { greet: function (event) { alert('Hello ' + this.name + '!') if (event) { alert(event.target.tagName) } } } }) 인라인 메소드 핸들러메소드 이름을 직접 바인딩 하는 대신 인라인 JavaScript 구문에 메소드를 사용할 수도 있습니다. 1234&lt;div id=\"example-3\"&gt; &lt;button v-on:click=\"say('hi')\"&gt;Say hi&lt;/button&gt; &lt;button v-on:click=\"say('what')\"&gt;Say what&lt;/button&gt;&lt;/div&gt; 12345678new Vue(&#123; el: '#example-3', methods: &#123; say: function (message) &#123; alert(message) &#125; &#125;&#125;) 결과: Say hi Say what new Vue({ el: '#example-3', methods: { say: function (message) { alert(message) } } }) 때로 인라인 명령문 핸들러에서 원본 DOM 이벤트에 액세스 해야할 수도 있습니다. 특별한 $event 변수를 사용해 메소드에 전달할 수도 있습니다. 123&lt;button v-on:click=\"warn('Form cannot be submitted yet.', $event)\"&gt; Submit&lt;/button&gt; 12345678// ...methods: &#123; warn: function (message, event) &#123; // 이제 네이티브 이벤트에 액세스 할 수 있습니다 if (event) event.preventDefault() alert(message) &#125;&#125; 이벤트 수식어이벤트 핸들러 내부에서 event.preventDefault() 또는 event.stopPropagation()를 호출하는 것은 매우 보편적인 일입니다. 메소드 내에서 쉽게 이 작업을 할 수 있지만, DOM 이벤트 세부 사항을 처리하는 대신 데이터 로직에 대한 메소드만 사용할 수 있으면 더 좋을 것입니다. 이 문제를 해결하기 위해, Vue는 v-on 이벤트에 이벤트 수식어를 제공합니다. 수식어는 점으로 표시된 접미사 입니다. .stop .prevent .capture .self .once .passive 1234567891011121314151617181920&lt;!-- 클릭 이벤트 전파가 중단됩니다 --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 제출 이벤트가 페이지를 다시 로드 하지 않습니다 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 수식어는 체이닝 가능합니다 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 단순히 수식어만 사용할 수 있습니다 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 이벤트 리스너를 추가할 때 캡처모드를 사용합니다 --&gt;&lt;!-- 즉, 내부 엘리먼트를 대상으로 하는 이벤트가 해당 엘리먼트에서 처리되기 전에 여기서 처리합니다. --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- event.target이 엘리먼트 자체인 경우에만 트리거를 처리합니다 --&gt;&lt;!-- 자식 엘리먼트에서는 안됩니다 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt; 관련 코드가 동일한 순서로 생성되므로 수식어를 사용할 때 순서를 지정하세요. 다시말해 `v-on:click.prevent.self`를 사용하면 **모든 클릭**을 막을 수 있으며 `v-on:click.self.prevent`는 엘리먼트 자체에 대한 클릭만 방지합니다. > 2.1.4에 새로 추가됨 12&lt;!-- 클릭 이벤트는 최대 한번만 트리거 됩니다. --&gt;&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt; 네이티브 DOM 이벤트에 독점적인 다른 수식어와 달리,.once 수식어는 컴포넌트 이벤트에서도 사용할 수 있습니다. 아직 컴포넌트에 대해 읽지 않았더라도 지금 당장은 걱정하지 마십시오. 2.3.0+ 이후 추가됨 Vue also offers the .passive modifier, corresponding to addEventListener‘s passive option. 12&lt;!-- 스크롤의 기본 이벤트를 취소할 수 없습니다. --&gt;&lt;div v-on:scroll.passive=\"onScroll\"&gt;...&lt;/div&gt; 추가로, Vue는 .passive 수식어를 제공합니다. 특히 모바일 환경에서 성능향상에 도움이 됩니다. 예를 들어, 브라우저는 핸들러가 event.preventDefault()를 호출할지 알지 못하므로 프로세스가 완료된 후 스크롤 합니다. .passive 수식어는 이 이벤트가 기본 동작을 멈추지 않는다는 것을 브라우저에 알릴 수 있습니다. `.passive`와 `.prevent`를 함께 사용하지 마세요. because `.prevent` will be ignored and your browser will probably show you a warning. Remember, `.passive` communicates to the browser that you _don't_ want to prevent the event's default behavior. ## 키 수식어 키보드 이벤트를 청취할 때, 종종 공통 키 코드를 확인해야 합니다. Vue는 키 이벤트를 수신할 때 v-on에 대한 키 수식어를 추가할 수 있습니다. 12&lt;!-- only call `vm.submit()` when the `key` is `Enter` --&gt;&lt;input v-on:keyup.enter=\"submit\"&gt; KeyboardEvent.key를 통해 노출된 유효 키 이름을 케밥 케이스로 변환하여 수식어로 사용할 수 있습니다. 1&lt;input v-on:keyup.page-down=\"onPageDown\"&gt; 위의 예제에서 핸들러는 $event.key === &#39;PageDown&#39; 일 때에만 호출됩니다. Key CodesThe use of `keyCode` events [is deprecated](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode) and may not be supported in new browsers. Using `keyCode` attributes is also permitted: 1&lt;input v-on:keyup.13=\"submit\"&gt; Vue provides aliases for the most commonly used key codes when necessary for legacy browser support: .enter .tab .delete (“Delete” 와 “Backspace” 키 모두를 캡처합니다) .esc .space .up .down .left .right 일부 키(`.esc`와 모든 화살표 키)는 IE9에서 일관성 없는 `key` 값을 가지고 있습니다. IE9를 지원해야하는 경우 내장 별칭이 선호됩니다. 또한 전역 `config.keyCodes` 객체를 통해 [사용자 지정 키 수식어 별칭을 지정할 수 있습니다.](../api/#keyCodes) 12// `v-on:keyup.f1`을 사용할 수 있습니다.Vue.config.keyCodes.f1 = 112 시스템 수식어 키 목록 2.1.0+에서 추가됨 다음 수식어를 사용해 해당 수식어 키가 눌러진 경우에만 마우스 또는 키보드 이벤트 리스너를 트리거 할 수 있습니다. .ctrl .alt .shift .meta 참고 : 매킨토시 키보드에서 meta는 command 키 입니다 (⌘). Windows 키보드에서 meta는 windows 키 (⊞) 입니다. Sun Microsystems 키보드에서 meta는 단색의 다이아몬드 (◆)로 표시됩니다. 특정 키보드의 경우, 특히 MIT 및 Lisp 시스템 키보드와 Knight 키보드, space-cadet 키보드와 같은 제품에는 “META” 레이블이 지정됩니다. Symbolics 키보드에서 메타는 “META” 또는 “Meta”로 표시됩니다. 예제: 12345&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67=\"clear\"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl=\"doSomething\"&gt;Do something&lt;/div&gt; 수식어 키는 일반 키와 다르며 `keyup` 이벤트와 함께 사용되면 이벤트가 발생할 때 수식어 키가 눌려있어야 합니다. 즉,`keyup.ctrl`는 `ctrl`을 누른 상태에서 키를 놓으면 트리거됩니다. `ctrl` 키만 놓으면 트리거되지 않습니다. .exact 수식어 2.5.0+에서 추가됨 .exact 수식어는 다른 시스템 수식어와 조합해 그 핸들러가 실행되기 위해 정확한 조합이 눌러야하는 것을 보여줍니다. 12345678&lt;!-- Alt 또는 Shift와 함께 눌린 경우에도 실행됩니다. --&gt;&lt;button @click.ctrl=\"onClick\"&gt;A&lt;/button&gt;&lt;!-- Ctrl 키만 눌려있을 때만 실행됩니다. --&gt;&lt;button @click.ctrl.exact=\"onCtrlClick\"&gt;A&lt;/button&gt;&lt;!-- 아래 코드는 시스템 키가 눌리지 않은 상태인 경우에만 작동합니다. --&gt;&lt;button @click.exact=\"onClick\"&gt;A&lt;/button&gt; 마우스 버튼 수식어 2.2.0 버전에서 추가됨 .left .right .middle 위 수식어는 특정 마우스 버튼에 의해 트리거 된 이벤트로 핸들러를 제한합니다. 왜 HTML로 된 리스너를 사용합니까이 모든 이벤트 청취 접근 방법이 우려 사항 분리(“separation of concerns”)에 대한 오래된 규칙을 어긴다고 생각할 수 있습니다. 모든 뷰 핸들러 함수와 표현식은 현재 뷰 처리 하는 ViewModel에 엄격히 바인딩 되기 때문에 유지보수가 어렵지 않습니다. 실제로 v-on을 사용하면 몇가지 이점이 있습니다. HTML 템플릿을 간단히 하여 JavaScript 코드 내에서 핸들러 함수 구현을 찾는 것이 더 쉽습니다. JavaScript에서 이벤트 리스너를 수동으로 연결할 필요가 없으므로 ViewModel 코드는 순수 로직과 DOM이 필요하지 않습니다. 이렇게 하면 테스트가 쉬워집니다. ViewModel이 파기되면 모든 이벤트 리스너가 자동으로 제거 됩니다. 이벤트 제거에 대한 걱정이 필요 없어집니다.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"리스트 렌더링","date":"2019-01-08T10:04:47.000Z","path":"wiki/vue/list/","text":"v-for로 엘리먼트에 배열 매핑하기v-for 디렉티브를 사용하여 배열을 기반으로 리스트를 렌더링 할 수 있습니다. v-for 디렉티브는 item in items 형태로 특별한 문법이 필요합니다. 여기서 items는 원본 데이터 배열이고 item은 반복되는 배열 엘리먼트의 별칭 입니다. 기본 사용방법12345&lt;ul id=\"example-1\"&gt; &lt;li v-for=\"item in items\"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 123456789var example1 = new Vue(&#123; el: '#example-1', data: &#123; items: [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125; ] &#125;&#125;) 결과: {{item.message}} var example1 = new Vue({ el: '#example-1', data: { items: [ { message: 'Foo' }, { message: 'Bar' } ] } }) v-for 블록 안에는 부모 범위 속성에 대한 모든 권한이 있습니다. v-for는 또한 현재 항목의 인덱스에 대한 두 번째 전달인자 옵션을 제공합니다. 12345&lt;ul id=\"example-2\"&gt; &lt;li v-for=\"(item, index) in items\"&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 12345678910var example2 = new Vue(&#123; el: '#example-2', data: &#123; parentMessage: 'Parent', items: [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125; ] &#125;&#125;) 결과: {{ parentMessage }} - {{ index }} - {{ item.message }} var example2 = new Vue({ el: '#example-2', data: { parentMessage: 'Parent', items: [ { message: 'Foo' }, { message: 'Bar' } ] } }) in 대신에 of를 구분자로 사용할 수 있습니다. 그래서 JavaScript의 이터레이터에 대한 자바스크립트 구문과 유사합니다. 1&lt;div v-for=\"item of items\"&gt;&lt;/div&gt; v-for와 객체v-for를 사용하여 객체의 속성을 반복할 수도 있습니다. 12345&lt;ul id=\"v-for-object\" class=\"demo\"&gt; &lt;li v-for=\"value in object\"&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 12345678910new Vue(&#123; el: '#v-for-object', data: &#123; object: &#123; title: 'How to do lists in Vue', author: 'Jane Doe', publishedAt: '2016-04-10' &#125; &#125;&#125;) 결과: {{ value }} new Vue({ el: '#v-for-object', data: { object: { title: 'How to do lists in Vue', author: 'Jane Doe', publishedAt: '2016-04-10' } } }) 키에 대한 두번째 전달 인자를 제공할 수도 있습니다. 123&lt;div v-for=\"(value, name) in object\"&gt; &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt; 결과: {{ name }}: {{ value }} new Vue({ el: '#v-for-object-value-name', data: { object: { title: 'How to do lists in Vue', author: 'Jane Doe', publishedAt: '2016-04-10' } } }) 그리고 또 인덱스도 제공합니다 123&lt;div v-for=\"(value, name, index) in object\"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt; 결과: {{ index }}. {{ name }}: {{ value }} new Vue({ el: '#v-for-object-value-name-index', data: { object: { title: 'How to do lists in Vue', author: 'Jane Doe', publishedAt: '2016-04-10' } } }) 객체를 반복할 때 순서는 `Object.keys()`의 키 나열 순서에 따라 결정됩니다. 이 순서는 JavaScript 엔진 구현간에 **일관적이지는 않습니다.** ## Maintaining State Vue가 v-for에서 렌더링된 엘리먼트 목록을 갱신할 때 기본적으로 “in-place patch” 전략을 사용합니다. 데이터 항목의 순서가 변경된 경우 항목의 순서와 일치하도록 DOM 요소를 이동하는 대신 Vue는 각 요소를 적절한 위치에 패치하고 해당 인덱스에서 렌더링할 내용을 반영하는지 확인합니다. 이것은 Vue 1.x의 track-by=$index의 동작과 유사합니다. 이 기본 모드는 효율적이지만 목록의 출력 결과가 하위 컴포넌트 상태 또는 임시 DOM 상태(예: 폼 input)에 의존하지 않는 경우에 적합합니다. Vue에서 개별 DOM 노드들을 추적하고 기존 엘리먼트를 재사용, 재정렬하기 위해서 v-for의 각 항목들에 고유한 key 속성을 제공해야 합니다. key에 대한 이상적인 값은 각 항목을 식별할 수 있는 고유한 ID입니다. 이 특별한 속성은 1.x 버전의 track-by와 거의 비슷하지만 속성처럼 작동하기 때문에 v-bind를 사용하여 동적 값에 바인딩 해야합니다. (여기서는 약어를 이용합니다.) 123&lt;div v-for=\"item in items\" v-bind:key=\"item.id\"&gt; &lt;!-- content --&gt;&lt;/div&gt; 반복되는 DOM 내용이 단순한 경우나 의도적인 성능 향상을 위해 기본 동작에 의존하지 않는 경우를 제외하면, 가능하면 언제나 v-for에 key를 추가하는 것이 좋습니다. 객체나 배열처럼, 기본 타입(Primitive value)이 아닌 값을 키로 사용해서는 안됩니다. 대신 문자열이나 숫자를 사용하세요. `key`는 Vue가 노드를 식별하는 일반적인 메커니즘이기 때문에 `v-for`와 특별히 연관되지 않는 다른 용도로도 사용됩니다. 뒤에서 이와 관련된 내용이 나올 것입니다. 배열 변경 감지변이 메소드Vue는 감시중인 배열의 변이 메소드를 래핑하여 뷰 갱신을 트리거합니다. 래핑된 메소드는 다음과 같습니다. push() pop() shift() unshift() splice() sort() reverse() 콘솔을 열고 이전 예제의 items 배열로 변이 메소드를 호출하여 재생할 수 있습니다. 예: example1.items.push({ message: &#39;Baz&#39; }) 배열 대체이름에서 알 수 있듯 변이 메소드는 호출된 원본 배열을 변형합니다. 이와 비교하여 변형을 하지 않는 방법도 있습니다. 바로 filter(), concat() 와 slice() 입니다. 이 방법을 사용하면 원본 배열을 변형하지 않고 항상 새 배열을 반환합니다. 변형이 없는 방법으로 작업할 때 이전 배열을 새 배열로 바꿀 수 있습니다. 123example1.items = example1.items.filter(function (item) &#123; return item.message.match(/Foo/)&#125;) 이렇게 하면 Vue가 기존 DOM을 버리고 전체 목록을 다시 렌더링 한다고 생각할 수 있습니다. 다행히도, 그렇지는 않습니다. Vue는 DOM 요소 재사용을 극대화하기 위해 몇가지 똑똑한 구현을 하므로 배열을 겹치는 객체가 포함된 다른 배열로 대체하여 효율적입니다. 주의 사항JavaScript의 제한으로 인해 Vue는 배열에 대해 다음과 같은 변경 사항을 감지할 수 없습니다. 인덱스로 배열에 있는 항목을 직접 설정하는 경우, 예: vm.items[indexOfItem] = newValue 배열 길이를 수정하는 경우, 예: vm.items.length = newLength 예시: 1234567var vm = new Vue(&#123; data: &#123; items: ['a', 'b', 'c'] &#125;&#125;)vm.items[1] = 'x' // reactive하지 않음vm.items.length = 2 // reactive하지 않음 주의 사항 중 1번을 극복하기 위해 다음 두 경우 모두 vm.items[indexOfItem] = newValue 와 동일하게 수행하며, 반응형 시스템에서도 상태 변경을 트리거 합니다. 12// Vue.setVue.set(vm.items, indexOfItem, newValue) 12// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue) You can also use the vm.$set instance method, which is an alias for the global Vue.set: 1vm.$set(vm.items, indexOfItem, newValue) 주의 사항 중 2번을 극복하기 위해 splice를 사용해야 합니다. 1vm.items.splice(newLength) 객체 변경 감지에 관한 주의사항모던 JavaScript의 한계로 Vue는 속성 추가 및 삭제를 감지하지 못합니다. 예를들어, 123456789var vm = new Vue(&#123; data: &#123; a: 1 &#125;&#125;)// `vm.a` 는 반응형입니다.vm.b = 2// `vm.b` 는 반응형이 아닙니다. Vue는 이미 만들어진 인스턴스에 새로운 루트레벨의 반응형 속성을 동적으로 추가하는 것을 허용하지 않습니다. 그러나 Vue.set(object, propertyName, value) 메소드를 사용하여 중첩된 객체에 반응형 속성을 추가할 수 있습니다. 1234567var vm = new Vue(&#123; data: &#123; userProfile: &#123; name: 'Anika' &#125; &#125;&#125;) 다음과 같이 중첩된 userProfile 객체에 새로운 속성 age를 추가합니다. 1Vue.set(vm.userProfile, 'age', 27) 인스턴스 메소드인 vm.$set를 사용할 수도 있습니다. 이는 전역 Vue.set의 별칭입니다. 1vm.$set(vm.userProfile, 'age', 27) 때로는 Object.assign()이나 _.extend()를 사용해 기존의 객체에 새 속성을 할당할 수 있습니다. 이 경우 두 객체의 속성을 사용해 새 객체를 만들어야 합니다. 1234Object.assign(vm.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;) 새로운 반응형 속성을 다음과 같이 추가합니다. 1234vm.userProfile = Object.assign(&#123;&#125;, vm.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;) 필터링 / 정렬 된 결과 표시하기때로 원본 데이터를 실제로 변경하거나 재설정하지 않고 배열의 필터링 된 버전이나 정렬된 버전을 표시해야 할 필요가 있습니다. 이 경우 필터링 된 배열이나 정렬된 배열을 반환하는 계산된 속성을 만들 수 있습니다. 예: 1&lt;li v-for=\"n in evenNumbers\"&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt; 12345678910data: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,computed: &#123; evenNumbers: function () &#123; return this.numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125;&#125; 계산된 속성을 실행할 수 없는 상황(예: 중첩 된 v-for 루프 내부)에서는 다음 방법을 사용할 수 있습니다. 1&lt;li v-for=\"n in even(numbers)\"&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt; 12345678910data: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,methods: &#123; even: function (numbers) &#123; return numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125;&#125; Range v-forv-for 는 숫자를 사용할 수 있습니다. 이 경우 템플릿을 여러번 반복합니다. 123&lt;div&gt; &lt;span v-for=\"n in 10\"&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;&lt;/div&gt; 결과: {{ n }} new Vue({ el: '#range' }) v-for 템플릿템플릿 v-if와 마찬가지로, &lt;template&gt;태그를 사용해 여러 엘리먼트의 블럭을 렌더링 할 수 있습니다. 123456&lt;ul&gt; &lt;template v-for=\"item in items\"&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class=\"divider\" role=\"presentation\"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; v-for 와 v-ifNote that it's **not** recommended to use `v-if` and `v-for` together. Refer to [style guide](/v2/style-guide/#Avoid-v-if-with-v-for-essential) for details. 동일한 노드에 두가지 모두 있다면, `v-for`가 `v-if`보다 높은 우선순위를 갖습니다. 즉, `v-if`는 루프가 반복될 때마다 실행됩니다. 이는 *일부* 항목만 렌더링 하려는 경우 유용합니다. 123&lt;li v-for=\"todo in todos\" v-if=\"!todo.isComplete\"&gt; &#123;&#123; todo &#125;&#125;&lt;/li&gt; 위의 경우 완료되지 않은 할일만 렌더링합니다. 위 방법 대신 실행을 조건부로 하는 것이 목적이라면 래퍼 엘리먼트(또는 &lt;template&gt;)을 사용하세요. 123456&lt;ul v-if=\"todos.length\"&gt; &lt;li v-for=\"todo in todos\"&gt; &#123;&#123; todo &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No todos left!&lt;/p&gt; v-for 와 컴포넌트 이 섹션에서는 컴포넌트를 안다고 가정합니다. 부담없이 건너뛰어도 됩니다. v-for를 사용자 정의 컴포넌트에 직접 사용할 수 있습니다. 1&lt;my-component v-for=\"item in items\" :key=\"item.id\"&gt;&lt;/my-component&gt; 2.2.0 이상에서 v-for는 key 가 필수 입니다. 그러나 컴포넌트에는 자체 범위가 분리되어있기 때문에 컴포넌트에 데이터를 자동으로 전달하지는 않습니다. 반복할 데이터를 컴포넌트로 전달하려면 props도 사용해야합니다. 123456&lt;my-component v-for=\"(item, index) in items\" v-bind:item=\"item\" v-bind:index=\"index\" v-bind:key=\"item.id\"&gt;&lt;/my-component&gt; 컴포넌트에 item을 자동으로 주입하지 않는 이유는 컴포넌트가 v-for의 작동 방식과 밀접하게 결합되기 때문입니다. 데이터의 출처를 명확히 하면 다른 상황에서 컴포넌트를 재사용할 수 있습니다. 간단한 할일 목록 전체 예제 입니다. 1234567891011121314151617181920&lt;div id=\"todo-list-example\"&gt; &lt;form v-on:submit.prevent=\"addNewTodo\"&gt; &lt;label for=\"new-todo\"&gt;Add a todo&lt;/label&gt; &lt;input v-model=\"newTodoText\" id=\"new-todo\" placeholder=\"E.g. Feed the cat\" &gt; &lt;button&gt;Add&lt;/button&gt; &lt;/form&gt; &lt;ul&gt; &lt;li is=\"todo-item\" v-for=\"(todo, index) in todos\" v-bind:key=\"todo.id\" v-bind:title=\"todo.title\" v-on:remove=\"todos.splice(index, 1)\" &gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; `is=\"todo-item\"` 속성을 보면 `` 엘리먼트는 `` 안에서만 유효합니다. ``과 같은 일을 하지만 잠재적인 브라우저의 구문 분석 오류를 해결 합니다. 자세한 내용은 [DOM 템플릿 파싱 주의사항](components.html#DOM-Template-Parsing-Caveats)을 참조하세요. 12345678910111213141516171819202122232425262728293031323334353637383940Vue.component('todo-item', &#123; template: '\\ &lt;li&gt;\\ &#123;&#123; title &#125;&#125;\\ &lt;button v-on:click=\"$emit(\\'remove\\')\"&gt;Remove&lt;/button&gt;\\ &lt;/li&gt;\\ ', props: ['title']&#125;)new Vue(&#123; el: '#todo-list-example', data: &#123; newTodoText: '', todos: [ &#123; id: 1, title: 'Do the dishes', &#125;, &#123; id: 2, title: 'Take out the trash', &#125;, &#123; id: 3, title: 'Mow the lawn' &#125; ], nextTodoId: 4 &#125;, methods: &#123; addNewTodo: function () &#123; this.todos.push(&#123; id: this.nextTodoId++, title: this.newTodoText &#125;) this.newTodoText = '' &#125; &#125;&#125;) Add a todo Add Vue.component('todo-item', { template: '\\ \\ {{ title }}\\ Remove\\ \\ ', props: ['title'] }) new Vue({ el: '#todo-list-example', data: { newTodoText: '', todos: [ { id: 1, title: 'Do the dishes', }, { id: 2, title: 'Take out the trash', }, { id: 3, title: 'Mow the lawn' } ], nextTodoId: 4 }, methods: { addNewTodo: function () { this.todos.push({ id: this.nextTodoId++, title: this.newTodoText }) this.newTodoText = '' } } })","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"조건부 렌더링","date":"2019-01-07T10:04:47.000Z","path":"wiki/vue/conditional/","text":"v-ifHandlebars와 같은 문자열 템플릿에서는 다음과 같은 조건부 블록을 작성할 수 있습니다. 1234&lt;!-- Handlebars 템플릿 --&gt;&#123;&#123;#if ok&#125;&#125; &lt;h1&gt;Yes&lt;/h1&gt;&#123;&#123;/if&#125;&#125; Vue에서는 v-if 디렉티브를 사용하여 같은 결과를 얻을 수 있습니다. 1&lt;h1 v-if=\"ok\"&gt;Yes&lt;/h1&gt; v-else와 함께 “else 블록”을 추가하는 것도 가능합니다. 12&lt;h1 v-if=\"ok\"&gt;Yes&lt;/h1&gt;&lt;h1 v-else&gt;No&lt;/h1&gt; &lt;template&gt;에 v-if을 갖는 조건부 그룹 만들기v-if는 디렉티브기 때문에 하나의 엘리먼트에 추가해야합니다. 하지만 하나 이상의 엘리먼트를 트랜지션하려면 어떻게 해야할까요? 이 경우 우리는 보이지 않는 래퍼 역할을 하는 &lt;template&gt; 엘리먼트에 v-if를 사용할 수 있습니다. 최종 렌더링 결과에는 &lt;template&gt; 엘리먼트가 포함되지 않습니다. 12345&lt;template v-if=\"ok\"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; v-elsev-else 디렉티브를 사용하여 v-if에 대한 “else 블록”을 나타낼 수 있습니다 123456&lt;div v-if=\"Math.random() &gt; 0.5\"&gt; 이제 나를 볼 수 있어요&lt;/div&gt;&lt;div v-else&gt; 이제는 안보입니다&lt;/div&gt; v-else 엘리먼트는 v-if 엘리먼트 또는 v-else-if 엘리먼트 바로 뒤에 있어야 합니다. 그렇지 않으면 인식할 수 없습니다. v-else-if 2.1.0부터 새롭게 추가됨 v-else-if는 이름에서 알 수 있듯, v-if에 대한 “else if 블록” 역할을 합니다. 또한 여러 개를 사용할 수 있습니다. 123456789101112&lt;div v-if=\"type === 'A'\"&gt; A&lt;/div&gt;&lt;div v-else-if=\"type === 'B'\"&gt; B&lt;/div&gt;&lt;div v-else-if=\"type === 'C'\"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; v-else와 마찬가지로, v-else-if 엘리먼트는 v-if 또는 v-else-if 엘리먼트 바로 뒤에 와야 합니다. key를 이용한 재사용 가능한 엘리먼트 제어Vue는 가능한 한 효율적으로 엘리먼트를 렌더링하려고 시도하며 종종 처음부터 렌더링을 하지않고 다시 사용합니다. Vue를 매우 빠르게 만드는데 도움이 되는 것 이외에 몇가지 유용한 이점이 있습니다. 예를 들어 사용자가 여러 로그인 유형을 트랜지션할 수 있도록 허용하는 경우입니다. 12345678&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;사용자 이름&lt;/label&gt; &lt;input placeholder=\"사용자 이름을 입력하세요\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;이메일&lt;/label&gt; &lt;input placeholder=\"이메일 주소를 입력하세요\"&gt;&lt;/template&gt; 위 코드에서 loginType을 바꾸어도 사용자가 이미 입력한 내용은 지워지지 않습니다. 두 템플릿 모두 같은 요소를 사용하므로 &lt;input&gt;은 대체되지 않고 단지 placeholder만 변경됩니다. 폼 인풋에 텍스트를 입력하고 토글 버튼을 눌러 직접 확인하십시오. 사용자 이름 이메일 로그인 유형 변경 new Vue({ el: '#no-key-example', data: { loginType: 'username' }, methods: { toggleLoginType: function () { return this.loginType = this.loginType === 'username' ? 'email' : 'username' } } }) 이것은 항상 바람직하지는 않습니다. 때문에 “이 두 엘리먼트는 완전히 별개이므로 다시 사용하지 마십시오.”라고 알리는 방법을 제공합니다. 유일한 값으로 key 속성을 추가하십시오. 12345678&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;사용자 이름&lt;/label&gt; &lt;input placeholder=\"사용자 이름을 입력하세요\" key=\"username-input\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;이메일&lt;/label&gt; &lt;input placeholder=\"이메일 주소를 입력하세요\" key=\"email-input\"&gt;&lt;/template&gt; 이제 트랜지션 할 때마다 입력이 처음부터 렌더링됩니다. 직접 확인해보세요. 사용자 이름 이메일 로그인 유형 변경 new Vue({ el: '#key-example', data: { loginType: 'username' }, methods: { toggleLoginType: function () { return this.loginType = this.loginType === 'username' ? 'email' : 'username' } } }) &lt;label&gt; 엘리먼트는 key 속성이 없기 때문에 여전히 효율적으로 재사용 됩니다. v-show엘리먼트를 조건부로 표시하기 위한 또 다른 옵션은 v-show 디렉티브입니다. 사용법은 거의 동일합니다. 1&lt;h1 v-show=\"ok\"&gt;안녕하세요!&lt;/h1&gt; 차이점은 v-show가 있는 엘리먼트는 항상 렌더링 되고 DOM에 남아있다는 점입니다. v-show는 단순히 엘리먼트에 display CSS 속성을 토글합니다. `v-show`는 `` 구문을 지원하지 않으며 `v-else`와도 작동하지 않습니다. ## `v-if` vs `v-show` v-if는 조건부 블럭 안의 이벤트 리스너와 자식 컴포넌트가 토글하는 동안 적절하게 제거되고 다시 만들어지기 때문에 “진짜” 조건부 렌더링 입니다 v-if는 또한 게으릅니다 초기 렌더링에서 조건이 거짓인 경우 아무것도 하지 않습니다. 조건 블록이 처음으로 참이 될 때 까지 렌더링 되지 않습니다. 비교해보면, v-show는 훨씬 단순합니다. CSS 기반 토글만으로 초기 조건에 관계 없이 엘리먼트가 항상 렌더링 됩니다. 일반적으로 v-if는 토글 비용이 높고 v-show는 초기 렌더링 비용이 더 높습니다. 매우 자주 바꾸기를 원한다면 v-show를, 런타임 시 조건이 바뀌지 않으면 v-if를 권장합니다. v-if 와 v-forv-if와 함께 사용하는 경우, v-for는 v-if보다 높은 우선순위를 갖습니다. 자세한 내용은 리스트 렌더링 가이드를 확인하십시오.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"클래스와 스타일 바인딩","date":"2019-01-06T10:04:47.000Z","path":"wiki/vue/class-and-style/","text":"데이터 바인딩은 엘리먼트의 클래스 목록과 인라인 스타일을 조작하기 위해 일반적으로 사용됩니다. 이 두 속성은 v-bind를 사용하여 처리할 수 있습니다. 우리는 표현식으로 최종 문자열을 계산하면 됩니다. 그러나 문자열 연결에 간섭하는 것은 짜증나는 일이며 오류가 발생하기 쉽습니다. 이러한 이유로, Vue는 class와 style에 v-bind를 사용할 때 특별히 향상된 기능을 제공합니다. 표현식은 문자열 이외에 객체 또는 배열을 이용할 수 있습니다. Binding HTML ClassesWatch a free video lesson on Vue School ## HTML 클래스 바인딩하기 객체 구문클래스를 동적으로 토글하기 위해 v-bind:class에 객체를 전달할 수 있습니다. 1&lt;div v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/div&gt; 위 구문은 active 클래스의 존재 여부가 데이터 속성 isActive 의 참 속성에 의해 결정되는 것을 의미합니다. 객체에 필드가 더 있으면 여러 클래스를 토글 할 수 있습니다. 또한v-bind:class 디렉티브는 일반 class 속성과 공존할 수 있습니다. 그래서 다음과 같은 템플릿이 가능합니다: 1234&lt;div class=\"static\" v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt;&lt;/div&gt; 그리고 데이터는: 1234data: &#123; isActive: true, hasError: false&#125; 아래와 같이 렌더링 됩니다: 1&lt;div class=\"static active\"&gt;&lt;/div&gt; isActive 또는 hasError 가 변경되면 클래스 목록도 그에 따라 업데이트됩니다. 예를 들어, hasError 가 true 가 되면 클래스 목록은 &quot;static active text-danger&quot; 가됩니다. 바인딩 된 객체는 인라인 일 필요는 없습니다. 1&lt;div v-bind:class=\"classObject\"&gt;&lt;/div&gt; 123456data: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125; 같은 결과로 렌더링 됩니다. 또한 객체를 반환하는 계산된 속성에도 바인딩 할 수 있습니다. 이것은 일반적이며 강력한 패턴입니다. 1&lt;div v-bind:class=\"classObject\"&gt;&lt;/div&gt; 123456789101112data: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, 'text-danger': this.error &amp;&amp; this.error.type === 'fatal' &#125; &#125;&#125; 배열 구문우리는 배열을 v-bind:class 에 전달하여 클래스 목록을 지정할 수 있습니다. 1&lt;div v-bind:class=\"[activeClass, errorClass]\"&gt;&lt;/div&gt; 1234data: &#123; activeClass: 'active', errorClass: 'text-danger'&#125; 아래와 같이 렌더링 됩니다: 1&lt;div class=\"active text-danger\"&gt;&lt;/div&gt; 목록에 있는 클래스를 조건부 토글하려면 삼항 연산자를 이용할 수 있습니다. 1&lt;div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"&gt;&lt;/div&gt; 이것은 항상 errorClass를 적용하고 isActive가 true일 때만 activeClass를 적용합니다. 그러나 여러 조건부 클래스가 있는 경우 장황해질 수 있습니다. 그래서 배열 구문 내에서 객체 구문을 사용할 수 있습니다. 1&lt;div v-bind:class=\"[&#123; active: isActive &#125;, errorClass]\"&gt;&lt;/div&gt; 컴포넌트와 함께 사용하는 방법 이 섹션은 Vue 컴포넌트에 대해 안다고 가정합니다. 부담없이 건너 뛰고 나중에 다시 봐도 됩니다. 사용자 정의 컴포넌트로 class 속성을 사용하면, 클래스가 컴포넌트의 루트 엘리먼트에 추가 됩니다. 이 엘리먼트는 기존 클래스는 덮어쓰지 않습니다. 예를 들어, 이 컴포넌트를 선언하는 경우에: 123Vue.component('my-component', &#123; template: '&lt;p class=\"foo bar\"&gt;Hi&lt;/p&gt;'&#125;) 사용할 클래스 일부를 추가하십시오: 1&lt;my-component class=\"baz boo\"&gt;&lt;/my-component&gt; 렌더링 된 HTML 입니다: 1&lt;p class=\"foo bar baz boo\"&gt;Hi&lt;/p&gt; 클래스 바인딩도 동일합니다: 1&lt;my-component v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/my-component&gt; isActive가 참일 때 렌더링 된 HTML은 다음과 같습니다: 1&lt;p class=\"foo bar active\"&gt;Hi&lt;/p&gt; 인라인 스타일 바인딩객체 구문v-bind:style 객체 구문은 매우 직설적입니다. 거의 CSS 처럼 보이지만 JavaScript 객체입니다. 속성 이름에 camelCase와 kebab-case (따옴표를 함께 사용해야 합니다)를 사용할 수 있습니다. 1&lt;div v-bind:style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&gt;&lt;/div&gt; 1234data: &#123; activeColor: 'red', fontSize: 30&#125; 스타일 객체에 직접 바인딩 하여 템플릿이 더 간결하도록 만드는 것이 좋습니다. 1&lt;div v-bind:style=\"styleObject\"&gt;&lt;/div&gt; 123456data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125;&#125; 다시, 객체 구문은 종종 객체를 반환하는 계산된 속성과 함께 사용합니다. 배열 구문v-bind:style에 대한 배열 구문은 같은 스타일의 엘리먼트에 여러 개의 스타일 객체를 사용할 수 있게 합니다. 1&lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt;&lt;/div&gt; 자동 접두사v-bind:style 에 브라우저 벤더 접두어가 필요한 CSS 속성 (예: transform)을 사용하면 Vue는 자동으로 해당 접두어를 감지하여 스타일을 적용합니다 다중 값 제공 2.3.0+ 2.3버전 부터 스타일 속성에 접두사가 있는 여러 값을 배열로 전달할 수 있습니다. 예제입니다. 1&lt;div v-bind:style=\"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;\"&gt;&lt;/div&gt; 브라우저가 지원하는 배열의 마지막 값만 렌더링합니다. 이 예제에서는 flexbox의 접두어가 붙지않은 버전을 지원하는 브라우저에 대해 display : flex를 렌더링합니다.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"computed와 watch","date":"2019-01-05T10:04:47.000Z","path":"wiki/vue/computed/","text":"computed 속성템플릿 내에 표현식을 넣으면 편리합니다. 하지만 간단한 연산일 때만 이용하는 것이 좋습니다. 너무 많은 연산을 템플릿 안에서 하면 코드가 비대해지고 유지보수가 어렵습니다. 아래의 예를 봅시다. 123&lt;div id=\"example\"&gt; &#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/div&gt; 이 템플릿은 더 이상 간단하고 명료하지 않습니다. message를 역순으로 표시한다는 것을 알려면 찬찬히 살펴봐야 하겠죠. 템플릿에 메시지를 역순으로 표시할 일이 더 있으면 문제는 더 악화될 것입니다. 복잡한 로직이라면 반드시 computed 속성 을 사용해야 하는 이유입니다. 기본 예제1234&lt;div id=\"example\"&gt; &lt;p&gt;원본 메시지: \"&#123;&#123; message &#125;&#125;\"&lt;/p&gt; &lt;p&gt;역순으로 표시한 메시지: \"&#123;&#123; reversedMessage &#125;&#125;\"&lt;/p&gt;&lt;/div&gt; 12345678910111213var vm = new Vue(&#123; el: '#example', data: &#123; message: '안녕하세요' &#125;, computed: &#123; // 계산된 getter reversedMessage: function () &#123; // `this` 는 vm 인스턴스를 가리킵니다. return this.message.split('').reverse().join('') &#125; &#125;&#125;) 결과: 원본 메시지: \"{{ message }}\" 역순으로 표시한 메시지: \"{{ reversedMessage }}\" var vm = new Vue({ el: '#example', data: { message: '안녕하세요' }, computed: { reversedMessage: function () { return this.message.split('').reverse().join('') } } }) 이 예제에서는 computed 속성인 reversedMessage를 선언했습니다. 우리가 작성한 함수는 vm.reversedMessage속성에 대한 getter 함수로 사용됩니다. 123console.log(vm.reversedMessage) // =&gt; '요세하녕안'vm.message = 'Goodbye'console.log(vm.reversedMessage) // =&gt; 'eybdooG' 콘솔에서 이 예제를 직접 해볼 수 있습니다. vm.reversedMessage의 값은 항상 vm.message의 값에 의존합니다. 일반 속성처럼 computed 속성에도 템플릿에서 데이터 바인딩 할 수 있습니다. Vue는 vm.reversedMessage가 vm.message에 의존하는 것을 알고 있기 때문에 vm.message가 바뀔 때 vm.reversedMessage에 의존하는 바인딩을 모두 업데이트할 것입니다. 그리고 가장 중요한 것은 우리가 선언적으로(역자 주: 선언형 프로그래밍 방식에 따라서(아래 computed와 watch 비교에 추가 설명)) 의존 관계를 만들었다는 것입니다. computed 속성의 getter 함수는 사이드 이펙트가 없어 코드를 테스트하거나 이해하기 쉽습니다. computed 속성의 캐싱 vs 메소드표현식에서 메소드를 호출하여 같은 결과를 얻을 수도 있습니다. 1&lt;p&gt;뒤집힌 메시지: \"&#123;&#123; reversedMessage() &#125;&#125;\"&lt;/p&gt; 123456// 컴포넌트 내부methods: &#123; reversedMessage: function () &#123; return this.message.split('').reverse().join('') &#125;&#125; computed 속성 대신 메소드와 같은 함수를 정의할 수도 있습니다. 최종 결과에 대해 두 가지 접근 방식은 서로 동일합니다. 차이점은 computed 속성은 종속 대상을 따라 저장(캐싱)된다는 것 입니다. computed 속성은 해당 속성이 종속된 대상이 변경될 때만 함수를 실행합니다. 즉 message가 변경되지 않는 한, computed 속성인 reversedMessage를 여러 번 요청해도 계산을 다시 하지 않고 계산되어 있던 결과를 즉시 반환합니다. 또한 Date.now()처럼 아무 곳에도 의존하지 않는 computed 속성의 경우 절대로 업데이트되지 않는다는 뜻입니다. 12345computed: &#123; now: function () &#123; return Date.now() &#125;&#125; 이에 비해 메소드를 호출하면 렌더링을 다시 할 때마다 항상 함수를 실행합니다. 캐싱이 왜 필요할까요? 계산에 시간이 많이 걸리는 computed 속성인 A를 가지고 있다고 해봅시다. 이 속성을 계산하려면 거대한 배열을 반복해서 다루고 많은 계산을 해야 합니다. 그런데 A 에 의존하는 다른 computed 속성값도 있을 수 있습니다. 캐싱을 하지 않으면 A 의 getter 함수를 꼭 필요한 것보다 더 많이 실행하게 됩니다! 캐싱을 원하지 않는 경우 메소드를 사용하십시오. computed 속성 vs watch 속성Vue는 Vue 인스턴스의 데이터 변경을 관찰하고 이에 반응하는 보다 일반적인 watch 속성을 제공합니다. 다른 데이터 기반으로 변경할 필요가 있는 데이터가 있는 경우, 특히 AngularJS를 사용하던 경우 watch를 남용하는 경우가 있습니다. 하지만 명령적인 watch 콜백보다 계산된 속성을 사용하는 것이 더 좋습니다.(역자 주: watch 속성은 감시할 데이터를 지정하고 그 데이터가 바뀌면 이런 함수를 실행하라는 방식으로 소프트웨어 공학에서 이야기하는 ‘명령형 프로그래밍’ 방식. computed 속성은 계산해야 하는 목표 데이터를 정의하는 방식으로 소프트웨어 공학에서 이야기하는 ‘선언형 프로그래밍’ 방식.) 다음 예제를 살펴봅시다. 1&lt;div id=\"demo\"&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt; 12345678910111213141516var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + ' ' + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + ' ' + val &#125; &#125;&#125;) 위의 코드는 명령형이고 또 코드를 반복합니다. computed 속성을 사용하는 방식과 비교해 보세요. 123456789101112var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar' &#125;, computed: &#123; fullName: function () &#123; return this.firstName + ' ' + this.lastName &#125; &#125;&#125;) 더 낫지 않나요?(역자 주: 일반적으로 선언형 프로그래밍이 명령형 프로그래밍보다 코드 반복이 적은 등 우수하다고 평가하는 경향이 있음.) computed 속성의 setter 함수computed 속성은 기본적으로 getter 함수만 가지고 있지만, 필요한 경우 setter 함수를 만들어 쓸 수 있습니다. 12345678910111213141516// ...computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;// ... 이제 vm.fullName = &#39;John Doe&#39;를 실행하면 설정자가 호출되고 vm.firstName과 vm.lastName이 그에 따라 업데이트 됩니다. watch 속성대부분의 경우 computed 속성이 더 적합하지만 사용자가 만든 감시자가 필요한 경우가 있습니다. 그래서 Vue는 watch 옵션을 통해 데이터 변경에 반응하는 보다 일반적인 방법을 제공합니다. 이는 데이터 변경에 대한 응답으로 비동기식 또는 시간이 많이 소요되는 조작을 수행하려는 경우에 가장 유용합니다. 예제 입니다. 1234567&lt;div id=\"watch-example\"&gt; &lt;p&gt; yes/no 질문을 물어보세요: &lt;input v-model=\"question\"&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- 이미 Ajax 라이브러리의 풍부한 생태계와 범용 유틸리티 메소드 컬렉션이 있기 때문에, --&gt;&lt;!-- Vue 코어는 다시 만들지 않아 작게 유지됩니다. --&gt;&lt;!-- 이것은 이미 익숙한 것을 선택할 수 있는 자유를 줍니다. --&gt;&lt;script src=\"https://unpkg.com/axios@0.12.0/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/lodash@4.13.1/lodash.min.js\"&gt;&lt;/script&gt;&lt;script&gt;var watchExampleVM = new Vue(&#123; el: '#watch-example', data: &#123; question: '', answer: '질문을 하기 전까지는 대답할 수 없습니다.' &#125;, watch: &#123; // 질문이 변경될 때 마다 이 기능이 실행됩니다. question: function (newQuestion) &#123; this.answer = '입력을 기다리는 중...' this.getAnswer() &#125; &#125;, methods: &#123; // _.debounce는 lodash가 제공하는 기능으로 // 특히 시간이 많이 소요되는 작업을 실행할 수 있는 빈도를 제한합니다. // 이 경우, 우리는 yesno.wtf/api 에 액세스 하는 빈도를 제한하고, // 사용자가 ajax요청을 하기 전에 타이핑을 완전히 마칠 때까지 기다리길 바랍니다. // _.debounce 함수(또는 이와 유사한 _.throttle)에 대한 // 자세한 내용을 보려면 https://lodash.com/docs#debounce 를 방문하세요. getAnswer: _.debounce( function () &#123; if (this.question.indexOf('?') === -1) &#123; this.answer = '질문에는 일반적으로 물음표가 포함 됩니다. ;-)' return &#125; this.answer = '생각중...' var vm = this axios.get('https://yesno.wtf/api') .then(function (response) &#123; vm.answer = _.capitalize(response.data.answer) &#125;) .catch(function (error) &#123; vm.answer = '에러! API 요청에 오류가 있습니다. ' + error &#125;) &#125;, // 사용자가 입력을 기다리는 시간(밀리세컨드) 입니다. 500 ) &#125;&#125;)&lt;/script&gt; Result: yes/no 질문을 물어보세요: {{ answer }} var watchExampleVM = new Vue({ el: '#watch-example', data: { question: '', answer: '질문을 하기 전까지는 대답할 수 없습니다' }, watch: { question: function (newQuestion, oldQuestion) { this.answer = '입력을 기다리는 중...' this.getAnswer() } }, methods: { getAnswer: _.debounce( function () { var vm = this if (this.question.indexOf('?') === -1) { vm.answer = '질문에는 일반적으로 물음표가 포함 됩니다. ;-)' return } vm.answer = '생각중...' axios.get('https://yesno.wtf/api') .then(function (response) { vm.answer = _.capitalize(response.data.answer) }) .catch(function (error) { vm.answer = '에러! API 요청에 오류가 있습니다. ' + error }) }, 500 ) } }) 이 경우 watch 옵션을 사용하면 비동기 연산 (API 엑세스)를 수행하고, 우리가 그 연산을 얼마나 자주 수행하는지 제한하고, 최종 응답을 얻을 때까지 중간 상태를 설정할 수 있습니다. 계산된 속성은 이러한 기능을 수행할 수 없습니다. watch 옵션 외에도 명령형 vm.$watch API를 사용할 수 있습니다.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"템플릿 문법","date":"2019-01-04T10:04:47.000Z","path":"wiki/vue/syntax/","text":"Vue.js는 렌더링 된 DOM을 기본 Vue 인스턴스의 데이터에 선언적으로 바인딩 할 수있는 HTML 기반 템플릿 구문을 사용합니다. 모든 Vue.js 템플릿은 스펙을 호환하는 브라우저 및 HTML 파서로 구문 분석 할 수있는 유효한 HTML입니다. 내부적으로 Vue는 템플릿을 가상 DOM 렌더링 함수로 컴파일 합니다. 반응형 시스템과 결합된 Vue는 앱 상태가 변경 될 때 최소한으로 DOM을 조작하고 다시 적용할 수 있는 최소한의 컴포넌트를 지능적으로 파악할 수 있습니다. 가상 DOM 개념에 익숙하고 JavaScript의 기본 기능을 선호하는 경우 템플릿 대신 렌더링 함수를 직접 작성할 수 있으며 선택사항으로 JSX를 지원합니다. 보간법(Interpolation)문자열데이터 바인딩의 가장 기본 형태는 “Mustache” 구문(이중 중괄호)을 사용한 텍스트 보간입니다. 1&lt;span&gt;메시지: &#123;&#123; msg &#125;&#125;&lt;/span&gt; Mustache 태그는 해당 데이터 객체의 msg 속성 값으로 대체됩니다. 또한 데이터 객체의 msg 속성이 변경될 때 마다 갱신됩니다. v-once 디렉티브를 사용하여 데이터 변경 시 업데이트 되지 않는 일회성 보간을 수행할 수 있지만, 같은 노드의 바인딩에도 영향을 미친다는 점을 유의해야 합니다. 1&lt;span v-once&gt;다시는 변경하지 않습니다: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 원시 HTML이중 중괄호(mustaches)는 HTML이 아닌 일반 텍스트로 데이터를 해석합니다. 실제 HTML을 출력하려면 v-html 디렉티브를 사용해야 합니다. 12&lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;Using v-html directive: &lt;span v-html=\"rawHtml\"&gt;&lt;/span&gt;&lt;/p&gt; Using mustaches: {{ rawHtml }} Using v-html directive: new Vue({ el: '#example1', data: function () { return { rawHtml: 'This should be red.' } } }) span의 내용은 rawHtml로 대체됩니다. 이 때 데이터 바인딩은 무시됩니다. Vue는 문자열 기반 템플릿 엔진이 아니기 때문에 v-html을 이용해 템플릿을 사용할 수 없습니다. 이와 달리 컴포넌트는 UI 재사용 및 구성을 위한 기본 단위로 사용하는 것을 추천합니다. 웹사이트에서 임의의 HTML을 동적으로 렌더링하려면 [XSS 취약점](https://en.wikipedia.org/wiki/Cross-site_scripting)으로 쉽게 이어질 수 있으므로 매우 위험할 가능성이 있습니다. 신뢰할 수 있는 콘텐츠에서만 HTML 보간을 사용하고 사용자가 제공한 콘텐츠에서는 **절대** 사용하면 안됩니다. ### 속성 Mustaches는 HTML 속성에서 사용할 수 없습니다. 대신 v-bind 디렉티브를 사용하세요: 1&lt;div v-bind:id=\"dynamicId\"&gt;&lt;/div&gt; boolean 속성을 사용할 때 단순히 true인 경우 v-bind는 조금 다르게 작동합니다. 1&lt;button v-bind:disabled=\"isButtonDisabled\"&gt;Button&lt;/button&gt; isButtonDisabled가 null, undefined 또는false의 값을 가지면 disabled 속성은 렌더링 된&lt;button&gt;엘리먼트에 포함되지 않습니다. JavaScript 표현식 사용지금까지 템플릿의 간단한 속성 키에만 바인딩했습니다. 그러나 실제로 Vue.js는 모든 데이터 바인딩 내에서 JavaScript 표현식의 모든 기능을 지원합니다. 1234567&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;div v-bind:id=\"'list-' + id\"&gt;&lt;/div&gt; 이 표현식은 Vue 인스턴스 데이터 범위 내에서 JavaScript로 계산됩니다. 한가지 제한사항은 각 바인딩에 하나의 단일 표현식 만 포함될 수 있으므로 아래처럼 작성하면 안됩니다 12345&lt;!-- 아래는 구문입니다, 표현식이 아닙니다. --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 조건문은 작동하지 않습니다. 삼항 연산자를 사용해야 합니다. --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 템플릿 표현식은 샌드박스 처리되며 `Math`와 `Date` 같은 [전역으로 사용 가능한 것](https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9)에만 접근할 수 있습니다. 템플릿 표현식에서 사용자 정의 전역에 액세스 하지 마십시오. ## 디렉티브 디렉티브는 v- 접두사가 있는 특수 속성입니다. 디렉티브 속성 값은 단일 JavaScript 표현식 이 됩니다. (나중에 설명할 v-for는 예외입니다.) 디렉티브의 역할은 표현식의 값이 변경될 때 사이드이펙트를 반응적으로 DOM에 적용하는 것 입니다. 아래 예제에서 살펴보겠습니다. 1&lt;p v-if=\"seen\"&gt;이제 나를 볼 수 있어요&lt;/p&gt; 여기서, v-if 디렉티브는 seen 표현의 진실성에 기반하여 &lt;p&gt; 엘리먼트를 제거 또는 삽입합니다. 전달인자일부 디렉티브는 콜론으로 표시되는 “전달인자”를 사용할 수 있습니다. 예를 들어, v-bind 디렉티브는 반응적으로 HTML 속성을 갱신하는데 사용됩니다. 1&lt;a v-bind:href=\"url\"&gt; ... &lt;/a&gt; 여기서 href는 전달인자로, 엘리먼트의 href 속성을 표현식 url의 값에 바인드하는 v-bind 디렉티브에게 알려줍니다. 또 다른 예로 DOM 이벤트를 수신하는 v-on 디렉티브입니다. 1&lt;a v-on:click=\"doSomething\"&gt; ... &lt;/a&gt; 전달인자는 이벤트를 받을 이름입니다. 우리는 이벤트 핸들링에 대해 더 자세하게 살펴 볼 것입니다. 동적 전달인자 2.6.0+ 에서 추가됨 2.6.0버전부터 Javascript 표현식을 대괄호로 묶어 디렉티브 의 아규멘트로 사용하는것도 가능해졌습니다: 12345&lt;!--동적 전달인자는 \"동적 전달인자의 형식 제약\"의 부분에서 후술되는바와 같이,조금의 제약이 있는 점에 주의해주세요--&gt;&lt;a v-bind:[attributeName]=\"url\"&gt; ... &lt;/a&gt; 여기서 attributeName은 Javascript형식으로 동적 변환되어, 그 변환결과가 전달인자의 최종적인 밸류로 사용됩니다. 예를들어 당신의 Vue 인스턴스에 &quot;href&quot;라는 값을 가진 attributeName 데이터 속성을 가진 경우, 이 바인딩은 v-bind:href와 동등합니다. 이와 유사하게, 동적인 이벤트명에 핸들러를 바인딩 할 때 동적 전달인자를 활용할 수 있습니다. 1&lt;a v-on:[eventName]=\"doSomething\"&gt; ... &lt;/a&gt; 이 예시에서 eventName의 값이 &quot;focus&quot; 라고 한다면 v-on:[EventName]은 v-on:focus와 동등합니다. 동적 전달인자 값의 제약동적 전달인자는, null을 제외하고는 string으로 변환될 것으로 예상합니다. 특수 값인 null은 명시적으로 바인딩을 제거하는데 사용됩니다. 그 외의 경우, string이 아닌 값은 경고를 출력합니다. 동적 전달인자 형식의 제약동적 전달인자의 형식에는 문자상의 제약이 있습니다. 스페이스와 따옴표같은 몇몇 문자는 HTML의 속성명으로서 적합하지 않은 문자이기 때문입니다. 다음 예시는 잘못된 경우입니다: 12&lt;!-- 컴파일러 경고를 불러옵니다 --&gt;&lt;a v-bind:['foo' + bar]=\"value\"&gt; ... &lt;/a&gt; 이를 피하는 방법은, 스페이스나 따옴표를 포함하지 않는 형식을 사용하거나, 복잡한 표현식을 계산된 속성(Computed)으로 대체하는 것입니다. in-DOM 탬플릿을 사용할 때에는 (탬플릿이 HTML파일에 직접 쓰여진 경우), 브라우저가 모든 속성명을 소문자로 만드는 관계로 대문자의 사용을 피하는것이 좋습니다: 12345&lt;!--in-DOM 탬플릿에서는 이 부분이 v-bind:[someattr]로 변환됩니다.인스턴스에 \"someattr\"속성이 없는 경우, 이 코드는 동작하지 않습니다.--&gt;&lt;a v-bind:[someAttr]=\"value\"&gt; ... &lt;/a&gt; 수식어수식어는 점으로 표시되는 특수 접미사로, 디렉티브를 특별한 방법으로 바인딩 해야 함을 나타냅니다. 예를 들어, .prevent 수식어는 트리거된 이벤트에서 event.preventDefault()를 호출하도록 v-on 디렉티브에게 알려줍니다. 1&lt;form v-on:submit.prevent=\"onSubmit\"&gt; ... &lt;/form&gt; 나중에 v-on과 v-model을 더 자세히 살펴볼 때 수식어를 더 많이 사용할 것 입니다. 약어v- 접두사는 템플릿의 Vue 특정 속성을 식별하기 위한 시각적인 신호 역할을 합니다. 이 기능은 Vue.js를 사용하여 기존의 마크업에 동적인 동작을 적용할 때 유용하지만 일부 자주 사용되는 디렉티브에 대해 너무 장황하다고 느껴질 수 있습니다. 동시에 Vue.js가 모든 템플릿을 관리하는 SPA를 만들 때 v- 접두어의 필요성이 떨어집니다. 따라서 가장 자주 사용되는 두개의 디렉티브인 v-bind와 v-on에 대해 특별한 약어를 제공합니다. v-bind 약어12345678&lt;!-- 전체 문법 --&gt;&lt;a v-bind:href=\"url\"&gt; ... &lt;/a&gt;&lt;!-- 약어 --&gt;&lt;a :href=\"url\"&gt; ... &lt;/a&gt;&lt;!-- shorthand with dynamic argument (2.6.0+) --&gt;&lt;a :[key]=\"url\"&gt; ... &lt;/a&gt; v-on 약어12345678&lt;!-- 전체 문법 --&gt;&lt;a v-on:click=\"doSomething\"&gt; ... &lt;/a&gt;&lt;!-- 약어 --&gt;&lt;a @click=\"doSomething\"&gt; ... &lt;/a&gt;&lt;!-- shorthand with dynamic argument (2.6.0+) --&gt;&lt;a @[event]=\"doSomething\"&gt; ... &lt;/a&gt; 이들은 일반적인 HTML과 조금 다르게 보일 수 있습니다. 하지만 :와 @는 속성 이름에 유효한 문자이며 Vue.js를 지원하는 모든 브라우저는 올바르게 구문 분석을 할 수 있습니다. 또한 최종 렌더링 된 마크업에는 나타나지 않습니다. 약어는 완전히 선택사항이지만 나중에 익숙해지면 편할 것 입니다.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"Vue 인스턴스","date":"2019-01-03T10:04:47.000Z","path":"wiki/vue/instance/","text":"Vue 인스턴스 만들기모든 Vue 앱은 Vue 함수로 새 Vue 인스턴스를 만드는 것부터 시작합니다. 123var vm = new Vue(&#123; // 옵션&#125;) 엄격히 MVVM 패턴과 관련이 없지만 Vue의 디자인은 부분적으로 그것에 영감을 받았습니다. 컨벤션으로, Vue 인스턴스를 참조하기 위해 종종 변수 vm(ViewModel의 약자)을 사용합니다. Vue 인스턴스를 인스턴스화 할 때는 데이터, 템플릿, 마운트할 엘리먼트, 메소드, 라이프사이클 콜백 등의 옵션을 포함 할 수있는 options 객체를 전달 해야합니다. 전체 옵션 목록은 API reference에서 찾을 수 있습니다. Vue 생성자는 미리 정의 된 옵션으로 재사용 가능한 컴포넌트 생성자를 생성하도록 확장 될 수 있습니다Vue 앱은 new Vue를 통해 만들어진 루트 Vue 인스턴스로 구성되며 선택적으로 중첩이 가능하고 재사용 가능한 컴포넌트 트리로 구성됩니다. 예를 들어 Todo 앱의 컴포넌트 트리는 다음과 같습니다. 12345678Root Instance└─ TodoList ├─ TodoItem │ ├─ DeleteTodoButton │ └─ EditTodoButton └─ TodoListFooter ├─ ClearTodosButton └─ TodoListStatistics 확장된 인스턴스를 만들수는 있으나 대개 템플릿에서 사용자 지정 엘리먼트로 선언적으로 작성하는 것이 좋습니다. 나중에 컴포넌트 시스템에 대해 자세히 설명합니다. 지금은 모든 Vue 컴포넌트가 본질적으로 확장된 Vue 인스턴스라는 것을 알아야 합니다. 속성과 메소드각 Vue 인스턴스는 data 객체에 있는 모든 속성을 프록시 처리 합니다. 123456789101112131415161718// 데이터 객체var data = &#123; a: 1 &#125;// Vue인스턴스에 데이터 객체를 추가합니다.var vm = new Vue(&#123; data: data&#125;)// 같은 객체를 참조합니다!vm.a === data.a // =&gt; true// 속성 설정은 원본 데이터에도 영향을 미칩니다.vm.a = 2data.a // =&gt; 2// ... 당연하게도data.a = 3vm.a // =&gt; 3 데이터가 변경되면 화면은 다시 렌더링됩니다. 유념할 점은, data에 있는 속성들은 인스턴스가 생성될 때 존재한 것들만 반응형이라는 것입니다. 즉, 다음과 같이 새 속성을 추가하면: 1vm.b = 'hi' b가 변경되어도 화면이 갱신되지 않습니다. 어떤 속성이 나중에 필요하다는 것을 알고 있으며, 빈 값이거나 존재하지 않은 상태로 시작한다면 아래와 같이 초기값을 지정할 필요가 있습니다. 1234567data: &#123; newTodoText: '', visitCount: 0, hideCompletedTodos: false, todos: [], error: null&#125; 여기에서 유일한 예외는 Object.freeze ()를 사용하는 경우입니다. 이는 기존 속성이 변경되는 것을 막아 반응성 시스템이 추적할 수 없다는 것을 의미합니다. 12345678910var obj = &#123; foo: 'bar'&#125;Object.freeze(obj)new Vue(&#123; el: '#app', data: obj&#125;) 12345&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt; &lt;!-- obj.foo는 더이상 변하지 않습니다! --&gt; &lt;button v-on:click=\"foo = 'baz'\"&gt;Change it&lt;/button&gt;&lt;/div&gt; Vue 인스턴스는 데이터 속성 이외에도 유용한 인스턴스 속성 및 메소드를 제공합니다. 다른 사용자 정의 속성과 구분하기 위해 $ 접두어를 붙였습니다. 예: 12345678910111213var data = &#123; a: 1 &#125;var vm = new Vue(&#123; el: '#example', data: data&#125;)vm.$data === data // =&gt; truevm.$el === document.getElementById('example') // =&gt; true// $watch 는 인스턴스 메소드 입니다.vm.$watch('a', function (newVal, oldVal) &#123; // `vm.a`가 변경되면 호출 됩니다.&#125;) 나중에 API reference에서 인스턴스 속성과 메소드 전체 목록을 살펴보세요. 인스턴스 라이프사이클 훅Watch a free lesson on Vue School 각 Vue 인스턴스는 생성될 때 일련의 초기화 단계를 거칩니다. 예를 들어, 데이터 관찰 설정이 필요한 경우, 템플릿을 컴파일하는 경우, 인스턴스를 DOM에 마운트하는 경우, 그리고 데이터가 변경되어 DOM를 업데이트하는 경우가 있습니다. 그 과정에서 사용자 정의 로직을 실행할 수있는 **라이프사이클 훅** 도 호출됩니다. 예를 들어, [`created`](../api/#created) 훅은 인스턴스가 생성된 후에 호출됩니다. 예: 12345678910new Vue(&#123; data: &#123; a: 1 &#125;, created: function () &#123; // `this` 는 vm 인스턴스를 가리킵니다. console.log('a is: ' + this.a) &#125;&#125;)// =&gt; \"a is: 1\" 인스턴스 라이프사이클의 여러 단계에서 호출될 다른 훅도 있습니다. 그 예로 mounted,updated 및 destroyed가 있습니다. 모든 라이프사이클 훅은 this 컨텍스트가 호출하는 Vue 인스턴스를 가리키며 호출됩니다. Vue 세계에서 “컨트롤러”의 컨셉이 어디에 있는지 궁금할 수 있습니다. 답은 컨트롤러가 없습니다. 컴포넌트의 사용자 지정 로직은 이러한 라이프사이클 훅으로 분할됩니다. options 속성이나 콜백에 `created: () => console.log(this.a)` 이나 `vm.$watch('a', newValue => this.myMethod())` 와 같은 [화살표 함수](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98) 사용을 지양하기 바랍니다. 화살표 함수들은 부모 컨텍스트에 바인딩되기 때문에, `this` 컨텍스트가 호출하는 Vue 인스턴스에서 사용할 경우 `Uncaught TypeError: Cannot read property of undefined` 또는 `Uncaught TypeError: this.myMethod is not a function`와 같은 오류가 발생하게 됩니다. 라이프사이클 다이어그램아래는 인스턴스 라이프사이클에 대한 다이어그램입니다. 지금 당장 모든 것을 완전히 이해할 필요는 없지만 다이어그램은 앞으로 도움이 될 것입니다.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"설치방법","date":"2019-01-02T10:04:47.000Z","path":"wiki/vue/installation/","text":"호환성 정보Vue는 ECMAScript 5 기능을 사용하기 때문에 IE8 이하 버전을 지원하지 않습니다. 하지만 모든 ECMAScript 5 호환 브라우저를 지원합니다 릴리즈 노트최신 안정 버전: 각 버전에 대한 자세한 릴리즈 노트는 GitHub에서 보실 수 있습니다. Vue DevtoolsVue를 사용할 때, 브라우저에 Vue Devtools를 설치 하는것이 좋습니다. Vue 앱을 보다 사용자 친화적인 인터페이스에서 검사하고 디버깅할 수 있습니다. 직접 &lt;script&gt;에 추가다운로드 받아 script 태그에 추가하기만 하면 됩니다. Vue는 전역 변수로 등록됩니다. 개발 중에는 프로덕션 버전을 사용하지 마십시오. 경고 및 일반적인 실수를 놓칠 수 있습니다! 개발 버전모든 오류 메시지 및 디버그 모드 프로덕션 버전오류 메시지 없음, kb min+gzip CDN프로토 타이핑또는 학습 목적이라면, 아래 코드로 최신 버전을 사용할 수 있습니다. 1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; 프로덕션 환경인 경우 새 버전에서 예상치 못한 오류를 방지하려면 특정 버전의 빌드 파일을 추가하는것을 추천합니다. 1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.0\"&gt;&lt;/script&gt; 기본 ES 모듈을 사용하는 경우 이를 지원 하는 ES 모듈 호환 빌드 파일도 있습니다. 123&lt;script type=\"module\"&gt; import Vue from 'https://cdn.jsdelivr.net/npm/vue@2.6.0/dist/vue.esm.browser.js'&lt;/script&gt; cdn.jsdelivr.net/npm/vue에서 NPM 패키지의 소스를 둘러볼 수도 있습니다.. Vue는 unpkg 와 cdnjs에서도 사용할 수도 있습니다. (cdnjs는 동기화하는데 시간이 걸리므로 최신버전을 사용하지 못할 수 있습니다). 각 다른 빌드간 차이점에 대해 읽어보고 배포된 사이트에서는 프로덕션 버젼을 사용하여 vue.js를 vue.min.js로 대체해주세요. 이는 개발 경험보다는 속도에 최적화된 빌드입니다. NPMVue를 사용하여 대규모 애플리케이션을 구축할 때 NPM를 이용한 설치를 권장하고 있습니다. NPM은 Webpack 또는 Browserify와 같은 모듈 번들러와 잘 작동합니다. Vue는 싱글 파일 컴포넌트를 만들기 위한 도구도 제공합니다. 12# 최신 안정화 버전$ npm install vue CLIVue.js는 단일 페이지 애플리케이션를 빠르게 구축할 수 있는 공식 CLI를 제공합니다. 최신 프론트엔드 워크 플로우를 위해 사전 구성된 빌드 설정을 제공합니다. 핫 리로드, 저장시 린트 체크 및 프로덕션 준비가 된 빌드로 시작하고 실행하는데 몇 분 밖에 걸리지 않습니다. 상세한 내용은 Vue CLI 문서에서 찾아보실 수 있습니다. CLI는 Node.js 및 관련 빌드 도구에 대한 사전 지식을 전제로 하고 있습니다. Vue 또는 프런트엔드 빌드 도구를 처음 사용하는 경우 CLI를 사용하기 전에 빌드 도구없이 가이드를 읽어 보시기 바랍니다. Watch a video explanation on Vue Mastery ## 각 다른 빌드간 차이점 [NPM 패키지의 `dist/` 디렉터리](https://unpkg.com/vue@latest/dist/)에는 Vue.js의 다양한 빌드가 있습니다. 다음은 그 차이점에 대한 개요입니다. UMD CommonJS ES Module (for bundlers) ES Module (for browsers) Full vue.js vue.common.js vue.esm.js vue.esm.browser.js Runtime-only vue.runtime.js vue.runtime.common.js vue.runtime.esm.js - Full (production) vue.min.js - - vue.esm.browser.min.js Runtime-only (production) vue.runtime.min.js - - - 용어 Full: 컴파일러 및 런타임 버전을 모두 포함합니다. Compiler: 템플릿 문자열을 JavaScript 렌더링 함수로 컴파일하는 코드입니다. Runtime: Vue 인스턴스 생성, 가상 DOM 렌더링 및 업데이트 등을 담당하는 코드. 기본적으로 모든 컴파일러를 제외한 것입니다. UMD: UMD 빌드는 &lt;script&gt;태그를 통해 브라우저에서 직접 사용할 수 있습니다. https://unpkg.com/vue의 Unpkg CDN의 기본 파일은 Runtime + Compiler UMD 빌드 (vue.js)입니다. CommonJS: CommonJS 빌드는 browserify 또는 webpack 1와 같은 이전 번들과 함께 사용하기 위한 것입니다. 이러한 번들(pkg.main)의 기본 파일은 런타임 전용 CommonJS 빌드(vue.runtime.common.js)입니다. ES Module: ES 모듈 빌드는 webpack 2 또는 rollup과 같은 최신 번들과 함께 사용하기 위한 것입니다. 이러한 번들(pkg.module)의 기본 파일은 런타임 전용 ES 모듈 빌드(vue.runtime.esm.js)입니다. 번들러용 ESM: webpack 2 또는 Rollup과 같은 최신 번들러와 함께 사용하도록 설계되었습니다. ESM 형식은 정적으로 구문 분석이 가능하도록 설계되었으므로 번들러을 활용하여 트리 쉐이킹을 실행하여 사용하지 않는 코드를 최종 패키지에서 제거할 수 있습니다. 이러한 번들러의 제공되는 기본 파일(pkg.module)은 ES 모듈 빌드의 런타임(vue.runtime.esm.js) 전용입니다. 브라우저 ESM (2.6+ 만 해당): 최신 브라우저에서는 &lt;script type=&quot;module&quot;&gt;를 이용하여 직접 가져올 수 있습니다. 런타임 + 컴파일러와 런타임의 차이템플릿을 실시간으로 컴파일 해야하는 경우(예 : 문자열을 template 옵션에 전달하거나 템플릿으로 in-DOM HTML을 사용하여 요소에 마운트하는 경우) 컴파일러와 전체 빌드가 필요합니다. 1234567891011// 아래 내용은 컴파일러가 필요합니다new Vue(&#123; template: '&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;'&#125;)// 아래는 필요하지 않습니다new Vue(&#123; render (h) &#123; return h('div', this.hi) &#125;&#125;) vue-loader 또는 vueify를 사용할 때 *.vue 파일의 템플릿은 빌드시 JavaScript로 미리 컴파일됩니다. 최종 번들에는 실제로 컴파일러가 필요하지 않으므로 런타임 전용 빌드를 사용할 수 있습니다.런타임 전용 빌드는 전체 빌드보다 약 30% 정도 가벼우므로 언제든지 사용할 수 있습니다. 하지만 전체 빌드를 사용하려면 번들러에서 별칭을 구성해야합니다. Webpack12345678module.exports = &#123; // ... resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.esm.js' // 'vue/dist/vue.common.js' webpack 1용 입니다 &#125; &#125;&#125; Rollup12345678910const alias = require('rollup-plugin-alias')rollup(&#123; // ... plugins: [ alias(&#123; 'vue': require.resolve('vue/dist/vue.esm.js') &#125;) ]&#125;) Browserify프로젝트의 package.json에 추가하십시오. 123456&#123; // ... \"browser\": &#123; \"vue\": \"vue/dist/vue.common.js\" &#125;&#125; Parcel프로젝트의 package.json에 추가하십시오. 123456&#123; // ... \"alias\": &#123; \"vue\" : \"./node_modules/vue/dist/vue.common.js\" &#125;&#125; 개발모드와 프로덕션 모드 차이개발/배포 모드는 UMD 빌드에 대해 하드 코딩되어 있습니다. 압축되지 않는 코드는 개발 환경에서 사용되고 압축된 코드는 파일은 프로덕션 환경에서 사용됩니다. CommonJS 및 ES 모듈 빌드는 번들러용으로 제작되었으므로 압축된 버전을 제공하지 않습니다. 최종 번들을 직접 압축해야할 책임은 개발자에게 있습니다. CommonJS 및 ES 모듈 빌드는 process.env.NODE_ENV에 대한 원시 검사를 유지하여 프로덕션 모드를 결정합니다. 적절한 모드를 사용하여 Vue가 실행될 모드를 제어하려면 이러한 번들 변수를 조작해야 합니다. process.env.NODE_ENV와 문자열 리터럴을 함께 사용하면 UglifyJS와 같은 minifier가 개발 전용 코드 블록을 완전히 삭제하여 최종 파일 크기를 줄일 수 있습니다. WebpackWebpack 4+인 경우, mode 옵션을 사용하세요: 123module.exports = &#123; mode: 'production'&#125; 하지만, Webpack 3 혹은 이전 버전이라면, DefinePlugin을 사용해야합니다. 12345678910111213var webpack = require('webpack')module.exports = &#123; // ... plugins: [ // ... new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125; &#125;) ]&#125; Rolluprollup-plugin-replace를 이용하여 다음과 같이 사용하십시오. 12345678910const replace = require('rollup-plugin-replace')rollup(&#123; // ... plugins: [ replace(&#123; 'process.env.NODE_ENV': JSON.stringify('production') &#125;) ]&#125;).then(...) Browserify글로벌 envify을 적용하여 번들러에 적용하십시오. 1NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m &gt; build.js 배포 관련 팁을 참고하세요. CSP 환경Chrome 앱과 같은 일부 환경에서는 CSP(컨텐츠 보안 정책)를 적용하여 식을 평가하므로 new Function()을 사용할 수 없습니다. 템플릿의 컴파일은 전체 빌드에 의존하기 때문에 이러한 환경에서는 사용할 수 없습니다. 반면 런타임 전용 빌드는 CSP와 완전히 호환됩니다. Webpack + vue-loader 또는 Browserify + vueify로 런타임 전용 빌드를 사용하는 경우 템플릿은 CSP 환경에서 완벽하게 작동하는 render 함수로 미리 컴파일됩니다. 개발용 빌드중요합니다 : Github의 /dist 폴더에 있는 빌드된 파일은 릴리즈 중에만 체크인 됩니다. Github의 최신 코드에서 Vue를 사용하려면 직접 빌드해야 합니다. 1234git clone https://github.com/vuejs/vue.git node_modules/vuecd node_modules/vuenpm installnpm run build BowerBower는 UMD 빌드에서만 사용 가능합니다. 12# 최신 안정판$ bower install vue AMD 모듈 로더모든 UMD 빌드는 AMD 모듈로 직접 사용할 수 있습니다.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]},{"title":"시작하기","date":"2019-01-01T10:04:47.000Z","path":"wiki/vue/index/","text":"Vue.js가 무엇인가요?Vue(/vjuː/ 로 발음, view 와 발음이 같습니다.)는 사용자 인터페이스를 만들기 위한 프로그레시브 프레임워크 입니다. 다른 단일형 프레임워크와 달리 Vue는 점진적으로 채택할 수 있도록 설계하였습니다. 핵심 라이브러리는 뷰 레이어만 초점을 맞추어 다른 라이브러리나 기존 프로젝트와의 통합이 매우 쉽습니다. 그리고 Vue는 현대적 도구 및 지원하는 라이브러리와 함께 사용한다면 정교한 단일 페이지 응용프로그램을 완벽하게 지원할 수 있습니다. Vue를 알아보기 전에 Vue에 대해 자세히 알고 싶다면 핵심 원칙과 샘플 프로젝트를 바탕으로 설명하는 비디오를 만들었으니, 참고하시면 좋을 것 입니다. 이미 숙련된 프론트엔드 개발자이고 Vue를 다른 라이브러리/프레임워크와 비교하고 싶다면 다른 프레임워크와의 비교를 확인하십시오. Vue Mastery의 무료 강의 보기 ## 시작하기 설치 공식 가이드는 HTML, CSS 및 JavaScript에 대한 중간 수준의 지식을 전제로 하고 있습니다. 이제 막 프론트 엔드 개발에 대해 배우기 시작했다면 첫 번째 단계로 프레임워크를 시작하는 것은 좋은 생각이 아닙니다. 기본을 파악한 다음 다시 해보세요! 다른 프레임워크에 대한 사전 경험이 도움될 수 있지만 반드시 필요한것은 아닙니다. Vue.js를 시험해 볼 수 있는 가장 쉬운 방법은 [JSFiddle Hello World 예제](https://jsfiddle.net/chrisvfritz/50wL7mdz/)를 사용하는 것입니다. 브라우저의 새 탭에서 열어 본 후 몇 가지 기본 예제를 따라가십시오. 또는 단순히 index.html 파일을 만들고 Vue를 다음과 같이 포함할 수 있습니다. 12&lt;!-- 개발버전, 도움되는 콘솔 경고를 포함. --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; 또는: 12&lt;!-- 상용버전, 속도와 용량이 최적화됨. --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; 설치 페이지에는 Vue를 설치하기 위한 옵션이 추가로 제공됩니다. 특히 Node.js 기반 빌드 도구에 아직 익숙하지 않으면 vue-cli로 시작하는 것을 권장하지 않습니다. 보다 인터랙티브한 학습을 원한다면, 언제든지 중지/재생 할 수 있는 스크린캐스트와 코드를 테스트 할 수 있는 환경를 제공해주는 Scrimba의 튜토리얼 시리즈를 확인해보세요. 선언적 렌더링Scrimba에서 레슨 받기 Vue.js의 핵심에는 간단한 템플릿 구문을 사용하여 DOM에서 데이터를 선언적으로 렌더링 할 수있는 시스템이 있습니다. 123&lt;div id=\"app\"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el: '#app', data: &#123; message: '안녕하세요 Vue!' &#125;&#125;) {{ message }} var app = new Vue({ el: '#app', data: { message: '안녕하세요 Vue!' } }) 첫 Vue 앱을 성공적으로 만들었습니다! 이것은 문자열 템플릿을 렌더링하는 것과 매우 유사하지만, Vue.JS 내부에서는 더 많은 작업을 하고 있습니다. 이제 데이터와 DOM이 연결되었으며 모든 것이 반응형이 되었습니다. 우리는 그것을 어떻게 확인할 수 있을까요? 브라우저의 JavaScript 콘솔을 열고 app.message를 다른 값으로 설정해 보십시오. 위 예제가 업데이트 변경된 값에 따라 업데이트되는 것을 볼 수 있습니다. 텍스트 보간 이외에도 다음과 같은 엘리먼트 속성을 바인딩할 수 있습니다. 12345&lt;div id=\"app-2\"&gt; &lt;span v-bind:title=\"message\"&gt; 내 위에 잠시 마우스를 올리면 동적으로 바인딩 된 title을 볼 수 있습니다! &lt;/span&gt;&lt;/div&gt; 123456var app2 = new Vue(&#123; el: '#app-2', data: &#123; message: '이 페이지는 ' + new Date() + ' 에 로드 되었습니다' &#125;&#125;) 내 위에 잠시 마우스를 올리면 동적으로 바인딩 된 title을 볼 수 있습니다! var app2 = new Vue({ el: '#app-2', data: { message: '이 페이지는 ' + new Date() + '에 로드 되었습니다' } }) 여기서 우리는 새로운 것을 만났습니다. v-bind 속성은 디렉티브 이라고 합니다. 디렉티브는 Vue에서 제공하는 특수 속성임을 나타내는 v- 접두어가 붙어있으며 사용자가 짐작할 수 있듯 렌더링 된 DOM에 특수한 반응형 동작을 합니다. 기본적으로 “이 요소의 title 속성을 Vue 인스턴스의 message 속성으로 최신 상태를 유지 합니다.” 다시 JavaScript 콘솔을 열고 app2.message = &#39;새로운 메시지&#39;라고 입력하면 HTML(이 경우에 title 속성)이 업데이트되었음을 다시 한번 확인할 수 있습니다. 조건문과 반복문Scrimba에서 레슨 받기 엘리먼트가 표시되는지에 대한 여부를 제어하는 것은 아주 간단합니다. 123&lt;div id=\"app-3\"&gt; &lt;p v-if=\"seen\"&gt;이제 나를 볼 수 있어요&lt;/p&gt;&lt;/div&gt; 123456var app3 = new Vue(&#123; el: '#app-3', data: &#123; seen: true &#125;&#125;) 이제 나를 볼 수 있어요 var app3 = new Vue({ el: '#app-3', data: { seen: true } }) 계속해서, Javascript 콘솔에 app3.seen = false를 입력하면, 메시지가 사라지는 것을 볼 수 있습니다. 이 예제는 텍스트와 속성뿐 아니라 DOM의 구조에도 데이터를 바인딩 할 수 있음을 보여줍니다. 또한 Vue 엘리먼트가 Vue에 삽입/업데이트/제거될 때 자동으로 트랜지션 효과를 적용할 수 있는 강력한 전환 효과 시스템을 제공합니다. 몇가지 디렉티브가 있습니다. 각 디렉티브마다 고유한 기능이 있습니다. 예를 들어 v-for 디렉티브는 배열의 데이터를 바인딩하여 Todo 목록을 표시하는데 사용할 수 있습니다. 1234567&lt;div id=\"app-4\"&gt; &lt;ol&gt; &lt;li v-for=\"todo in todos\"&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 12345678910var app4 = new Vue(&#123; el: '#app-4', data: &#123; todos: [ &#123; text: 'JavaScript 배우기' &#125;, &#123; text: 'Vue 배우기' &#125;, &#123; text: '무언가 멋진 것을 만들기' &#125; ] &#125;&#125;) {{ todo.text }} var app4 = new Vue({ el: '#app-4', data: { todos: [ { text: 'JavaScript 배우기' }, { text: 'Vue 배우기' }, { text: '무언가 멋진 것을 만들기' } ] } }) 콘솔에서, app4.todos.push({ text: &#39;New item&#39; })을 입력하십시오. Todo 목록에 새 항목이 동적으로 추가 된것을 볼 수 있습니다. 사용자 입력 핸들링Scrimba에서 레슨 받기 사용자가 앱과 상호 작용할 수 있게 하기 위해 우리는 `v-on` 디렉티브를 사용하여 Vue 인스턴스에서 메소드를 호출하는 이벤트 리스너를 추가 할 수 있습니다 : 1234&lt;div id=\"app-5\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button v-on:click=\"reverseMessage\"&gt;메시지 뒤집기&lt;/button&gt;&lt;/div&gt; 1234567891011var app5 = new Vue(&#123; el: '#app-5', data: &#123; message: '안녕하세요! Vue.js!' &#125;, methods: &#123; reverseMessage: function () &#123; this.message = this.message.split('').reverse().join('') &#125; &#125;&#125;) {{ message }} 메시지 뒤집기 var app5 = new Vue({ el: '#app-5', data: { message: '안녕하세요! Vue.js!' }, methods: { reverseMessage: function () { this.message = this.message.split('').reverse().join('') } } }) 이 방법은 직접적으로 DOM을 건드리지 않고 앱의 상태만을 업데이트합니다. 모든 DOM 조작은 Vue에 의해 처리되며 작성한 코드는 기본 로직에만 초점을 맞춥니다. Vue는 또한 양식에 대한 입력과 앱 상태를 양방향으로 바인딩하는 v-model 디렉티브를 제공합니다. 1234&lt;div id=\"app-6\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=\"message\"&gt;&lt;/div&gt; 123456var app6 = new Vue(&#123; el: '#app-6', data: &#123; message: '안녕하세요 Vue!' &#125;&#125;) {{ message }} var app6 = new Vue({ el: '#app-6', data: { message: '안녕하세요 Vue!' } }) 컴포넌트를 사용한 작성방법Scrimba에서 레슨 받기 컴포넌트 시스템은 Vue의 또 다른 중요한 개념입니다. 이는 작고 독립적이며 재사용할 수 있는 컴포넌트로 구성된 대규모 애플리케이션을 구축할 수 있게 해주는 추상적 개념입니다. 생각해보면 거의 모든 유형의 애플리케이션 인터페이스를 컴포넌트 트리로 추상화할 수 있습니다. Vue에서 컴포넌트는 미리 정의된 옵션을 가진 Vue 인스턴스 입니다. Vue에서 컴포넌트를 등록하는 방법은 간단합니다. 123456// todo-item 이름을 가진 컴포넌트를 정의합니다Vue.component('todo-item', &#123; template: '&lt;li&gt;할일 항목 하나입니다.&lt;/li&gt;'&#125;)var app = new Vue(...) 이제 다른 컴포넌트의 템플릿에서 이 컴포넌트를 추가할 수 있습니다. 1234&lt;ol&gt; &lt;!-- todo-item 컴포넌트의 인스턴스 만들기 --&gt; &lt;todo-item&gt;&lt;/todo-item&gt;&lt;/ol&gt; 그러나 이것은 todo-item 컴포넌트를 사용할 때마다 똑같은 텍스트를 렌더링할뿐 무언가가 부족합니다. 부모 영역의 데이터를 자식 컴포넌트에 전달할 수 있어야 합니다. prop을 전달받을 수 있도록 todo-item 컴포넌트의 정의를 수정해봅시다. 1234567Vue.component('todo-item', &#123; // 이제 todo-item 컴포넌트는 \"prop\" 이라고 하는 // 사용자 정의 속성 같은 것을 입력받을 수 있습니다. // 이 prop은 todo라는 이름으로 정의했습니다. props: ['todo'], template: '&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'&#125;) 이제 v-bind를 사용하여 각각의 반복되는 todo-item 컴포넌트에 전달할 수 있습니다. 1234567891011121314&lt;div id=\"app-7\"&gt; &lt;ol&gt; &lt;!-- 이제 각 todo-item 에 todo 객체를 제공합니다. 화면에 나오므로, 각 항목의 컨텐츠는 동적으로 바뀔 수 있습니다. 또한 각 구성 요소에 \"키\"를 제공해야합니다 (나중에 설명 됨). --&gt; &lt;todo-item v-for=\"item in groceryList\" v-bind:todo=\"item\" v-bind:key=\"item.id\" &gt;&lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt; 123456789101112131415Vue.component('todo-item', &#123; props: ['todo'], template: '&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'&#125;)var app7 = new Vue(&#123; el: '#app-7', data: &#123; groceryList: [ &#123; id: 0, text: 'Vegetables' &#125;, &#123; id: 1, text: 'Cheese' &#125;, &#123; id: 2, text: 'Whatever else humans are supposed to eat' &#125; ] &#125;&#125;) Vue.component('todo-item', { props: ['todo'], template: '{{ todo.text }}' }) var app7 = new Vue({ el: '#app-7', data: { groceryList: [ { id: 0, text: 'Vegetables' }, { id: 1, text: 'Cheese' }, { id: 2, text: 'Whatever else humans are supposed to eat' } ] } }) 이것은 인위적으로 만든 예시이지만, 우리는 앱을 두 개의 더 작은 단위로 나눌 수 있었고, 자식을 props 인터페이스를 통하여 부모로부터 합리적인 수준으로 분리할 수 있었습니다. 이제 앞으로는 부모 앱에 영향을 주지 않으면서 &lt;todo-item&gt; 컴포넌트를 더 복잡한 템플릿과 로직으로 더욱 향상시킬 수 있을 것입니다. 대규모 애플리케이션에서는 개발을 보다 쉽게 관리 할 수 있도록 전체 앱을 컴포넌트로 나누는 것이 필수적입니다. 가이드의 뒷부분에서 컴포넌트에 대해 자세히 설명하겠지만 여기서는 컴포넌트를 사용한 앱의 모습이 어떻게 구성될지에 대한 (가상의) 예를 작성하겠습니다. 1234567&lt;div id=\"app\"&gt; &lt;app-nav&gt;&lt;/app-nav&gt; &lt;app-view&gt; &lt;app-sidebar&gt;&lt;/app-sidebar&gt; &lt;app-content&gt;&lt;/app-content&gt; &lt;/app-view&gt;&lt;/div&gt; 사용자 정의 엘리먼트와의 관계Vue 컴포넌트는 Web Components Spec의 일부인 사용자 지정 엘리먼트 와 매우 유사하다는 것을 눈치 챘을 수 있습니다. Vue의 컴포넌트 구문은 스펙 이후 느슨하게 모델링 되었기 때문입니다. 예를 들어 Vue 컴포넌트는 Slot API와 is 특수 속성을 구현합니다. 그러나 몇가지 중요한 차이가 있습니다. Web Components Spec은 최종안이 정해졌지만 모든 브라우저들이 기본적으로 구현되는 것은 아닙니다. 현재 사파리 10.1+, 크롬 54+ 그리고 파이어폭스 63+ 기본적으로 Web Components를 지원합니다. 이에 비해 Vue 컴포넌트는 지원되는 모든 브라우저 (IE 9 이상)에서 폴리필을 필요로 하지 않으며 일관된 방식으로 작동합니다. 필요한 경우 Vue 컴포넌트는 기본 사용자 정의 엘리먼트 내에 래핑할 수 있습니다. Vue 컴포넌트는 컴포넌트간 데이터의 흐름을 비롯해, 사용자 정의 이벤트와 통신, 빌드 도구와의 통합 등 기본 사용자 지정 엘리먼트에서 사용할 수 없었던 중요한 기능을 제공합니다. Vue는 내부적으로 사용자 정의 엘리먼트를 사용하지 않지만, 사용자 정의 엘리먼트로 사용 또는 배포하는 경우에는 뛰어난 상호운용성을 가집니다. Vue CLI는 자기자신을 네이티브 커스텀 엘리먼트로서 등록하는 Vue 컴포넌트의 빌드도 지원하고 있습니다. 더 해야할 것은 무엇인가요?우리는 Vue.js 코어의 가장 기본적인 기능을 간략하게 소개했습니다. 이 가이드의 나머지 부분에서 더 자세한 세부 내용이 포함된 다른 고급 기능에 대해 다룰 예정이므로 꼭 읽어보시기 바랍니다. Video by Vue Mastery. Watch Vue Mastery’s free Intro to Vue course.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://vue-guide.github.io/categories/Vue-js/"}]}]}